{
    "docs": [
        {
            "location": "/",
            "text": "",
            "title": "Home"
        },
        {
            "location": "/intro/",
            "text": "Introduction\n\n\nzend-mvc is the MVC layer shipped with Zend Framework 2 and above, and focuses\non performance and flexibility.\n\n\nThe MVC layer is built on top of the following components:\n\n\n\n\nzend-servicemanager - zend-mvc provides a set of default service definitions,\n  used to create and configure the application instance and workflow.\n\n\nzend-eventmanager - The MVC is event driven, and uses events for the initial\n  bootstrapping of the application, for returning response and request calls,\n  for matching routes, and even for rendering views.\n\n\nzend-http - specifically the request and response objects from the\n  \nZend\\Http\\PhpEnvironment\n namespace, which provide objects that ensure the\n  request is injected with the current environment (including query parameters,\n  POST parameters, HTTP headers, etc.), and that the response will interact\n  correctly with the SAPI and output buffering.\n\n\nzend-stdlib - specifically \nZend\\Stdlib\\DispatchableInterface\n. All\n  \"controllers\" are simply dispatchable objects.\n\n\nzend-router - provides routing of a request. In other\n  words, it matches the request to its respective controller (or dispatchable).\n\n\n\n\nWithin the MVC layer, several sub-components are exposed:\n\n\n\n\nZend\\Mvc\\Controller\n, a set of abstract \"controller\" classes with basic\n  responsibilities such as event wiring, action dispatching, etc., as well as\n  controller plugins.\n\n\nZend\\Mvc\\Service\n provides a set of zend-servicemanager factories and\n  definitions for the default application workflow.\n\n\nZend\\Mvc\\View\n provides default wiring for renderer selection, view script\n  resolution, helper registration, and more; additionally, it provides a\n  number of listeners that tie into the MVC workflow, providing features such\n  as automated template name resolution, automated view model creation and\n  injection, etc.\n\n\n\n\nThe gateway to the MVC is the \nZend\\Mvc\\Application\n\nobject (referred to as \nApplication\n henceforth). Its primary responsibilities\nare to \nbootstrap\n resources, to \nroute\n the request, and to retrieve and\n\ndispatch\n the controller matched during routing. Once accomplished, it will\n\nrender\n the view, and \nfinish\n the request, returning and sending the\nresponse.\n\n\nBasic Application Structure\n\n\nThe basic application structure follows:\n\n\napplication_root/\n    config/\n        application.config.php\n        autoload/\n            global.php\n            local.php\n            // etc.\n    data/\n    module/\n    vendor/\n    public/\n        .htaccess\n        index.php\n    init_autoloader.php\n\n\n\nThe \npublic/index.php\n script marshals all user requests to your website,\nretrieving an array of configuration from \nconfig/application.config.php\n. On\nreturn, it \nrun()\ns the \nApplication\n, processing the request and returning a\nresponse to the user.\n\n\nThe \nconfig\n directory as described above contains configuration used by\nzend-modulemanager to load modules and merge configuration (e.g., database\nconfiguration and credentials); we will detail this more later.\n\n\nThe \nvendor\n sub-directory should contain any third-party modules or libraries\non which your application depends. This might include Zend Framework, custom\nlibraries from your organization, or other third-party libraries from other\nprojects. Libraries and modules placed in the \nvendor\n sub-directory should not\nbe modified from their original, distributed state.  Typically, this directory\nwill be managed by \nComposer\n.\n\n\nFinally, the \nmodule\n directory will contain one or more modules delivering your\napplication's functionality.\n\n\nLet's now turn to modules, as they are the basic units of a web application.\n\n\nBasic Module Structure\n\n\nA module may contain anything: PHP code, including MVC functionality; library\ncode; view scripts; and/or or public assets such as images, CSS, and JavaScript.\nThe only requirement \u2014 and even this is optional \u2014 is that a module\nacts as a PHP namespace and that it contains a \nModule\n class under that\nnamespace.  This class is eventually consumed by zend-modulemanager to perform a\nnumber of tasks.\n\n\nThe recommended module structure follows:\n\n\nmodule_root<named-after-module-namespace>/\n    Module.php\n    autoload_classmap.php\n    autoload_function.php\n    autoload_register.php\n    config/\n        module.config.php\n    public/\n        images/\n        css/\n        js/\n    src/\n        <module_namespace>/\n            <code files>\n    test/\n        phpunit.xml\n        bootstrap.php\n        <module_namespace>/\n            <test code files>\n    view/\n        <dir-named-after-module-namespace>/\n            <dir-named-after-a-controller>/\n                <.phtml files>\n\n\n\nSince a module acts as a namespace, the module root directory should be that\nnamespace. This namespace could also include a vendor prefix of sorts. As an\nexample a module centered around \"User\" functionality delivered by Zend might be\nnamed \"ZendUser\", and this is also what the module root directory will be named.\n\n\n\n\nSource and test code organization\n\n\nThe above details a \nPSR-0\n structure for\nthe source and test code directories. You can also use\n\nPSR-4\n so long as you have setup\nautoloading correctly to do so.\n\n\n\n\nThe \nModule.php\n file directly under the module root directory will be in the\nmodule namespace shown below.\n\n\nnamespace ZendUser;\n\nclass Module\n{\n}\n\n\n\n\n\nModule class location\n\n\nIf you have an autoloader defined, such as detailed later around the various\n\nautoload_*.php\n files or using Composer's \nautoloading features\n,\nthen your \nModule.php\n file can be co-located with your source code.\n\n\nOur current recommendation is to define autoloading for your\napplication-specific modules via Composer.\n\n\n\n\nWhen an \ninit()\n method is defined, this method will be triggered by a\nzend-modulemanager listener when it loads the module class, and passed a\n\nModuleManager\n instance by default. This allows you to perform tasks such as\nsetting up module-specific event listeners. But be cautious, the \ninit()\n method\nis called for \nevery\n module on \nevery\n page request and should \nonly\n be\nused for performing \nlightweight\n tasks such as registering event listeners.\nSimilarly, an \nonBootstrap()\n method (which accepts an \nMvcEvent\n instance) may\nbe defined; it is also triggered for every page request, and should be used for\nlightweight tasks as well.\n\n\nThe three \nautoload_*.php\n files are not required, but recommended if you are\nnot using Composer to provide autoloading for your module. They provide the\nfollowing:\n\n\n\n\n\n\n\n\nFile\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nautoload_classmap.php\n\n\nShould return an array classmap of class name/filename pairs (with the filenames resolved via the \n__DIR__\n magic constant).\n\n\n\n\n\n\nautoload_function.php\n\n\nShould return a PHP callback that can be passed to \nspl_autoload_register()\n. Typically, this callback should utilize the map returned by \nautoload_classmap.php.\n\n\n\n\n\n\nautoload_register.php\n\n\nshould register a PHP callback (is typically returned by \nautoload_function.php\n with \nspl_autoload_register()\n.\n\n\n\n\n\n\n\n\nThe point of these three files is to provide reasonable default mechanisms for autoloading the\nclasses contained in the module, thus providing a trivial way to consume the module without\nrequiring zend-modulemanager (e.g., for use outside a ZF2 application).\n\n\nThe \nconfig\n directory should contain any module-specific configuration. These\nfiles may be in any format zend-config supports. We recommend naming the main\nconfiguration \nmodule.config.<format>\n (e.g., for PHP-based configuration,\n\nmodule.config.php\n). Typically, you will create configuration for the router as\nwell as for the service manager.\n\n\nThe \nsrc\n directory should be a \nPSR-0\n or\n\nPSR-4\n compliant directory structure with\nyour module's source code.\n\n\nThe \ntest\n directory should contain your unit tests. Typically, these are written using\n\nPHPUnit\n.\n\n\nThe \npublic\n directory can be used for assets that you may want to expose in\nyour application's document root. These might include images, CSS files,\nJavaScript files, etc. How these are exposed is left to the developer.\n\n\nThe \nview\n directory contains view scripts related to your controllers.\n\n\nBootstrapping an Application\n\n\nThe \nApplication\n has seven basic dependencies.\n\n\n\n\nconfiguration\n, usually an array or object implementing \nTraversable\n.\n\n\nServiceManager\n instance.\n\n\nEventManager\n instance, which, by default, is pulled from the\n  \nServiceManager\n, by the service name \"EventManager\".\n\n\nSharedEventManager\n instance, which, by default, is pulled from the\n  \nServiceManager\n, by the service name \"SharedEventManager\"; this is injected\n  into the \nEventManager\n instance, and then pushed into every new\n  \nEventManager\n instance created.\n\n\nModuleManager\n instance, which, by default, is pulled from the\n  \nServiceManager\n, by the service name \"ModuleManager\".\n\n\nRequest\n instance, which, by default, is pulled from the \nServiceManager\n,\n  by the service name \"Request\".\n\n\nResponse\n instance, which, by default, is pulled from the \nServiceManager\n,\n  by the service name \"Response\".\n\n\n\n\nThese may be satisfied at instantiation:\n\n\nuse Zend\\EventManager\\EventManager;\nuse Zend\\EventManager\\SharedEventManager;\nuse Zend\\Http\\PhpEnvironment;\nuse Zend\\ModuleManager\\ModuleManager;\nuse Zend\\Mvc\\Application;\nuse Zend\\ServiceManager\\ServiceManager;\n\n$config = include 'config/application.config.php';\n\n$serviceManager = new ServiceManager();\n$serviceManager->setService('SharedEventManager', new SharedEventManager());\n$serviceManager->setService('ModuleManager', new ModuleManager($config));\n$serviceManager->setService('Request', new PhpEnvironment\\Request());\n$serviceManager->setService('Response', new PhpEnvironment\\Response());\n$serviceManager->setFactory('EventManager', function ($serviceManager) {\n    return new EventManager($serviceManager->get('SharedEventManager'));\n});\n$serviceManager->setShared('EventManager', false);\n\n$application = new Application($config, $serviceManager);\n\n\n\nOnce you've done this, there are two additional actions you can take. The first is to \"bootstrap\"\nthe application. In the default implementation, this does the following:\n\n\n\n\nAttaches the default route listener (\nZend\\Mvc\\RouteListener\n).\n\n\nAttaches the middleware dispatch listener (\nZend\\Mvc\\MiddlewareListener\n)\n  (v2.7.0 and up).\n\n\nAttaches the default dispatch listener (\nZend\\Mvc\\DispatchListener\n).\n\n\nAttaches the \nViewManager\n listener (\nZend\\Mvc\\View\\ViewManager\n).\n\n\nCreates the \nMvcEvent\n, and injects it with the application, request, and\n  response; it also retrieves the router (\nZend\\Router\\Http\\TreeRouteStack\n)\n  at this time and attaches it to the event.\n\n\nTriggers the \"bootstrap\" event.\n\n\n\n\nIf you do not want these actions, or want to provide alternatives, you can do so by extending the\n\nApplication\n class and/or manually coding what actions you want to occur.\n\n\nThe second action you can take with the configured \nApplication\n is to \nrun()\n\nit. Calling this method performs the following:\n\n\n\n\nit triggers the \"route\" event,\n\n\nfollowed by the \"dispatch\" event, and, depending on execution,\n\n\nthe \"render\" event\n\n\n\n\nWhen done, it triggers the \"finish\" event, and then returns the response\ninstance. If an error occurs during either the \"route\" or \"dispatch\" event, a\n\"dispatch.error\" event is triggered as well.\n\n\nThis is a lot to remember in order to bootstrap the application; in fact, we haven't covered all the\nservices available by default yet. You can greatly simplify things by using the default\n\nServiceManager\n configuration shipped with the MVC.\n\n\nuse Zend\\Loader\\AutoloaderFactory;\nuse Zend\\Mvc\\Service\\ServiceManagerConfig;\nuse Zend\\ServiceManager\\ServiceManager;\n\n// setup autoloader\nAutoloaderFactory::factory();\n\n// get application stack configuration\n$configuration = include 'config/application.config.php';\n\n// setup service manager\n$serviceManager = new ServiceManager(new ServiceManagerConfig());\n$serviceManager->setService('ApplicationConfig', $configuration);\n\n// load modules -- which will provide services, configuration, and more\n$serviceManager->get('ModuleManager')->loadModules();\n\n// bootstrap and run application\n$application = $serviceManager->get('Application');\n$application->bootstrap();\n$application->run();\n\n\n\nYou can make this even simpler by using the \ninit()\n method of the\n\nApplication\n. This is a static method for quick and easy initialization of the\n\nApplication\n instance.\n\n\nuse Zend\\Loader\\AutoloaderFactory;\nuse Zend\\Mvc\\Application;\nuse Zend\\Mvc\\Service\\ServiceManagerConfig;\nuse Zend\\ServiceManager\\ServiceManager;\n\n// setup autoloader\nAutoloaderFactory::factory();\n\n// get application stack configuration\n$configuration = include 'config/application.config.php';\n\n// The init() method does something very similar with the previous example.\nApplication::init($configuration)->run();\n\n\n\nThe \ninit()\n does the following:\n\n\n\n\nGrabs the application configuration and pulls from the \nservice_manager\n key,\n  creating a \nServiceManager\n instance with it and with the default services\n  shipped with zend-mvc;\n\n\nCreates a service named \nApplicationConfig\n with the application configuration array;\n\n\nGrabs the \nModuleManager\n service and loads the modules;\n\n\nbootstrap()\ns the \nApplication\n and returns its instance.\n\n\n\n\n\n\nApplicationConfig service\n\n\nIf you use the \ninit()\n method, you cannot specify a service with the name of\n'ApplicationConfig' in your service manager config. This name is reserved to\nhold the array from \napplication.config.php\n.  The following services can only\nbe overridden from \napplication.config.php\n:\n\n\n\n\nModuleManager\n\n\nSharedEventManager\n\n\nEventManager\n and \nZend\\EventManager\\EventManagerInterface\n\n\n\n\nAll other services are configured after module loading, thus can be overridden\nby modules.\n\n\n\n\nYou'll note that you have a great amount of control over the workflow. Using the\n\nServiceManager\n, you have fine-grained control over what services are\navailable, how they are instantiated, and what dependencies are injected into\nthem. Using the \nEventManager\n's priority system, you can intercept any of the\napplication events (\"bootstrap\", \"route\", \"dispatch\", \"dispatch.error\",\n\"render\", and \"finish\") anywhere during execution, allowing you to craft your\nown application workflows as needed.\n\n\nBootstrapping a Modular Application\n\n\nWhile the previous approach largely works, where does the configuration come\nfrom? When we create a modular application, the assumption will be that it's\nfrom the modules themselves. How do we get that information and aggregate it,\nthen?\n\n\nThe answer is via zend-modulemanager. This component allows you to specify what\nmodules the application will use; it then locates each module and initializes\nit. Module classes can tie into various listeners in order to provide\nconfiguration, services, listeners, and more to the application. Sounds\ncomplicated? It's not.\n\n\nConfiguring the Module Manager\n\n\nThe first step is configuring the module manager. Inform the module manager\nwhich modules to load, and potentially provide configuration for the module\nlisteners.\n\n\nRemember the \napplication.config.php\n from earlier? We're going to provide some\nconfiguration.\n\n\n// config/application.config.php\nreturn array(\n    'modules' => array(\n        /* ... */\n    ),\n    'module_listener_options' => array(\n        'module_paths' => array(\n            './module',\n            './vendor',\n        ),\n    ),\n);\n\n\n\nAs we add modules to the system, we'll add items to the \nmodules\n array.\n\n\nEach \nModule\n class that has configuration it wants the \nApplication\n to know\nabout should define a \ngetConfig()\n method. That method should return an array\nor \nTraversable\n object such as a \nZend\\Config\\Config\n instance. As an example:\n\n\nnamespace ZendUser;\n\nclass Module\n{\n    public function getConfig()\n    {\n        return include __DIR__ . '/config/module.config.php'\n    }\n}\n\n\n\nThere are a number of other methods you can define for tasks ranging from\nproviding autoloader configuration, to providing services to the\n\nServiceManager\n, to listening to the bootstrap event.  The\n\nModuleManager documentation\n\ngoes into more detail on these.\n\n\nConclusion\n\n\nzend-mvc is incredibly flexible, offering an opt-in, easy to create modular\ninfrastructure, as well as the ability to craft your own application workflows\nvia the \nServiceManager\n and \nEventManager\n. The \nModuleManager\n is a\nlightweight and simple approach to enforcing a modular architecture that\nencourages clean separation of concerns and code re-use.",
            "title": "Introduction"
        },
        {
            "location": "/intro/#introduction",
            "text": "zend-mvc is the MVC layer shipped with Zend Framework 2 and above, and focuses\non performance and flexibility.  The MVC layer is built on top of the following components:   zend-servicemanager - zend-mvc provides a set of default service definitions,\n  used to create and configure the application instance and workflow.  zend-eventmanager - The MVC is event driven, and uses events for the initial\n  bootstrapping of the application, for returning response and request calls,\n  for matching routes, and even for rendering views.  zend-http - specifically the request and response objects from the\n   Zend\\Http\\PhpEnvironment  namespace, which provide objects that ensure the\n  request is injected with the current environment (including query parameters,\n  POST parameters, HTTP headers, etc.), and that the response will interact\n  correctly with the SAPI and output buffering.  zend-stdlib - specifically  Zend\\Stdlib\\DispatchableInterface . All\n  \"controllers\" are simply dispatchable objects.  zend-router - provides routing of a request. In other\n  words, it matches the request to its respective controller (or dispatchable).   Within the MVC layer, several sub-components are exposed:   Zend\\Mvc\\Controller , a set of abstract \"controller\" classes with basic\n  responsibilities such as event wiring, action dispatching, etc., as well as\n  controller plugins.  Zend\\Mvc\\Service  provides a set of zend-servicemanager factories and\n  definitions for the default application workflow.  Zend\\Mvc\\View  provides default wiring for renderer selection, view script\n  resolution, helper registration, and more; additionally, it provides a\n  number of listeners that tie into the MVC workflow, providing features such\n  as automated template name resolution, automated view model creation and\n  injection, etc.   The gateway to the MVC is the  Zend\\Mvc\\Application \nobject (referred to as  Application  henceforth). Its primary responsibilities\nare to  bootstrap  resources, to  route  the request, and to retrieve and dispatch  the controller matched during routing. Once accomplished, it will render  the view, and  finish  the request, returning and sending the\nresponse.",
            "title": "Introduction"
        },
        {
            "location": "/intro/#basic-application-structure",
            "text": "The basic application structure follows:  application_root/\n    config/\n        application.config.php\n        autoload/\n            global.php\n            local.php\n            // etc.\n    data/\n    module/\n    vendor/\n    public/\n        .htaccess\n        index.php\n    init_autoloader.php  The  public/index.php  script marshals all user requests to your website,\nretrieving an array of configuration from  config/application.config.php . On\nreturn, it  run() s the  Application , processing the request and returning a\nresponse to the user.  The  config  directory as described above contains configuration used by\nzend-modulemanager to load modules and merge configuration (e.g., database\nconfiguration and credentials); we will detail this more later.  The  vendor  sub-directory should contain any third-party modules or libraries\non which your application depends. This might include Zend Framework, custom\nlibraries from your organization, or other third-party libraries from other\nprojects. Libraries and modules placed in the  vendor  sub-directory should not\nbe modified from their original, distributed state.  Typically, this directory\nwill be managed by  Composer .  Finally, the  module  directory will contain one or more modules delivering your\napplication's functionality.  Let's now turn to modules, as they are the basic units of a web application.",
            "title": "Basic Application Structure"
        },
        {
            "location": "/intro/#basic-module-structure",
            "text": "A module may contain anything: PHP code, including MVC functionality; library\ncode; view scripts; and/or or public assets such as images, CSS, and JavaScript.\nThe only requirement \u2014 and even this is optional \u2014 is that a module\nacts as a PHP namespace and that it contains a  Module  class under that\nnamespace.  This class is eventually consumed by zend-modulemanager to perform a\nnumber of tasks.  The recommended module structure follows:  module_root<named-after-module-namespace>/\n    Module.php\n    autoload_classmap.php\n    autoload_function.php\n    autoload_register.php\n    config/\n        module.config.php\n    public/\n        images/\n        css/\n        js/\n    src/\n        <module_namespace>/\n            <code files>\n    test/\n        phpunit.xml\n        bootstrap.php\n        <module_namespace>/\n            <test code files>\n    view/\n        <dir-named-after-module-namespace>/\n            <dir-named-after-a-controller>/\n                <.phtml files>  Since a module acts as a namespace, the module root directory should be that\nnamespace. This namespace could also include a vendor prefix of sorts. As an\nexample a module centered around \"User\" functionality delivered by Zend might be\nnamed \"ZendUser\", and this is also what the module root directory will be named.",
            "title": "Basic Module Structure"
        },
        {
            "location": "/intro/#source-and-test-code-organization",
            "text": "The above details a  PSR-0  structure for\nthe source and test code directories. You can also use PSR-4  so long as you have setup\nautoloading correctly to do so.   The  Module.php  file directly under the module root directory will be in the\nmodule namespace shown below.  namespace ZendUser;\n\nclass Module\n{\n}",
            "title": "Source and test code organization"
        },
        {
            "location": "/intro/#module-class-location",
            "text": "If you have an autoloader defined, such as detailed later around the various autoload_*.php  files or using Composer's  autoloading features ,\nthen your  Module.php  file can be co-located with your source code.  Our current recommendation is to define autoloading for your\napplication-specific modules via Composer.   When an  init()  method is defined, this method will be triggered by a\nzend-modulemanager listener when it loads the module class, and passed a ModuleManager  instance by default. This allows you to perform tasks such as\nsetting up module-specific event listeners. But be cautious, the  init()  method\nis called for  every  module on  every  page request and should  only  be\nused for performing  lightweight  tasks such as registering event listeners.\nSimilarly, an  onBootstrap()  method (which accepts an  MvcEvent  instance) may\nbe defined; it is also triggered for every page request, and should be used for\nlightweight tasks as well.  The three  autoload_*.php  files are not required, but recommended if you are\nnot using Composer to provide autoloading for your module. They provide the\nfollowing:     File  Description      autoload_classmap.php  Should return an array classmap of class name/filename pairs (with the filenames resolved via the  __DIR__  magic constant).    autoload_function.php  Should return a PHP callback that can be passed to  spl_autoload_register() . Typically, this callback should utilize the map returned by  autoload_classmap.php.    autoload_register.php  should register a PHP callback (is typically returned by  autoload_function.php  with  spl_autoload_register() .     The point of these three files is to provide reasonable default mechanisms for autoloading the\nclasses contained in the module, thus providing a trivial way to consume the module without\nrequiring zend-modulemanager (e.g., for use outside a ZF2 application).  The  config  directory should contain any module-specific configuration. These\nfiles may be in any format zend-config supports. We recommend naming the main\nconfiguration  module.config.<format>  (e.g., for PHP-based configuration, module.config.php ). Typically, you will create configuration for the router as\nwell as for the service manager.  The  src  directory should be a  PSR-0  or PSR-4  compliant directory structure with\nyour module's source code.  The  test  directory should contain your unit tests. Typically, these are written using PHPUnit .  The  public  directory can be used for assets that you may want to expose in\nyour application's document root. These might include images, CSS files,\nJavaScript files, etc. How these are exposed is left to the developer.  The  view  directory contains view scripts related to your controllers.",
            "title": "Module class location"
        },
        {
            "location": "/intro/#bootstrapping-an-application",
            "text": "The  Application  has seven basic dependencies.   configuration , usually an array or object implementing  Traversable .  ServiceManager  instance.  EventManager  instance, which, by default, is pulled from the\n   ServiceManager , by the service name \"EventManager\".  SharedEventManager  instance, which, by default, is pulled from the\n   ServiceManager , by the service name \"SharedEventManager\"; this is injected\n  into the  EventManager  instance, and then pushed into every new\n   EventManager  instance created.  ModuleManager  instance, which, by default, is pulled from the\n   ServiceManager , by the service name \"ModuleManager\".  Request  instance, which, by default, is pulled from the  ServiceManager ,\n  by the service name \"Request\".  Response  instance, which, by default, is pulled from the  ServiceManager ,\n  by the service name \"Response\".   These may be satisfied at instantiation:  use Zend\\EventManager\\EventManager;\nuse Zend\\EventManager\\SharedEventManager;\nuse Zend\\Http\\PhpEnvironment;\nuse Zend\\ModuleManager\\ModuleManager;\nuse Zend\\Mvc\\Application;\nuse Zend\\ServiceManager\\ServiceManager;\n\n$config = include 'config/application.config.php';\n\n$serviceManager = new ServiceManager();\n$serviceManager->setService('SharedEventManager', new SharedEventManager());\n$serviceManager->setService('ModuleManager', new ModuleManager($config));\n$serviceManager->setService('Request', new PhpEnvironment\\Request());\n$serviceManager->setService('Response', new PhpEnvironment\\Response());\n$serviceManager->setFactory('EventManager', function ($serviceManager) {\n    return new EventManager($serviceManager->get('SharedEventManager'));\n});\n$serviceManager->setShared('EventManager', false);\n\n$application = new Application($config, $serviceManager);  Once you've done this, there are two additional actions you can take. The first is to \"bootstrap\"\nthe application. In the default implementation, this does the following:   Attaches the default route listener ( Zend\\Mvc\\RouteListener ).  Attaches the middleware dispatch listener ( Zend\\Mvc\\MiddlewareListener )\n  (v2.7.0 and up).  Attaches the default dispatch listener ( Zend\\Mvc\\DispatchListener ).  Attaches the  ViewManager  listener ( Zend\\Mvc\\View\\ViewManager ).  Creates the  MvcEvent , and injects it with the application, request, and\n  response; it also retrieves the router ( Zend\\Router\\Http\\TreeRouteStack )\n  at this time and attaches it to the event.  Triggers the \"bootstrap\" event.   If you do not want these actions, or want to provide alternatives, you can do so by extending the Application  class and/or manually coding what actions you want to occur.  The second action you can take with the configured  Application  is to  run() \nit. Calling this method performs the following:   it triggers the \"route\" event,  followed by the \"dispatch\" event, and, depending on execution,  the \"render\" event   When done, it triggers the \"finish\" event, and then returns the response\ninstance. If an error occurs during either the \"route\" or \"dispatch\" event, a\n\"dispatch.error\" event is triggered as well.  This is a lot to remember in order to bootstrap the application; in fact, we haven't covered all the\nservices available by default yet. You can greatly simplify things by using the default ServiceManager  configuration shipped with the MVC.  use Zend\\Loader\\AutoloaderFactory;\nuse Zend\\Mvc\\Service\\ServiceManagerConfig;\nuse Zend\\ServiceManager\\ServiceManager;\n\n// setup autoloader\nAutoloaderFactory::factory();\n\n// get application stack configuration\n$configuration = include 'config/application.config.php';\n\n// setup service manager\n$serviceManager = new ServiceManager(new ServiceManagerConfig());\n$serviceManager->setService('ApplicationConfig', $configuration);\n\n// load modules -- which will provide services, configuration, and more\n$serviceManager->get('ModuleManager')->loadModules();\n\n// bootstrap and run application\n$application = $serviceManager->get('Application');\n$application->bootstrap();\n$application->run();  You can make this even simpler by using the  init()  method of the Application . This is a static method for quick and easy initialization of the Application  instance.  use Zend\\Loader\\AutoloaderFactory;\nuse Zend\\Mvc\\Application;\nuse Zend\\Mvc\\Service\\ServiceManagerConfig;\nuse Zend\\ServiceManager\\ServiceManager;\n\n// setup autoloader\nAutoloaderFactory::factory();\n\n// get application stack configuration\n$configuration = include 'config/application.config.php';\n\n// The init() method does something very similar with the previous example.\nApplication::init($configuration)->run();  The  init()  does the following:   Grabs the application configuration and pulls from the  service_manager  key,\n  creating a  ServiceManager  instance with it and with the default services\n  shipped with zend-mvc;  Creates a service named  ApplicationConfig  with the application configuration array;  Grabs the  ModuleManager  service and loads the modules;  bootstrap() s the  Application  and returns its instance.",
            "title": "Bootstrapping an Application"
        },
        {
            "location": "/intro/#applicationconfig-service",
            "text": "If you use the  init()  method, you cannot specify a service with the name of\n'ApplicationConfig' in your service manager config. This name is reserved to\nhold the array from  application.config.php .  The following services can only\nbe overridden from  application.config.php :   ModuleManager  SharedEventManager  EventManager  and  Zend\\EventManager\\EventManagerInterface   All other services are configured after module loading, thus can be overridden\nby modules.   You'll note that you have a great amount of control over the workflow. Using the ServiceManager , you have fine-grained control over what services are\navailable, how they are instantiated, and what dependencies are injected into\nthem. Using the  EventManager 's priority system, you can intercept any of the\napplication events (\"bootstrap\", \"route\", \"dispatch\", \"dispatch.error\",\n\"render\", and \"finish\") anywhere during execution, allowing you to craft your\nown application workflows as needed.",
            "title": "ApplicationConfig service"
        },
        {
            "location": "/intro/#bootstrapping-a-modular-application",
            "text": "While the previous approach largely works, where does the configuration come\nfrom? When we create a modular application, the assumption will be that it's\nfrom the modules themselves. How do we get that information and aggregate it,\nthen?  The answer is via zend-modulemanager. This component allows you to specify what\nmodules the application will use; it then locates each module and initializes\nit. Module classes can tie into various listeners in order to provide\nconfiguration, services, listeners, and more to the application. Sounds\ncomplicated? It's not.",
            "title": "Bootstrapping a Modular Application"
        },
        {
            "location": "/intro/#configuring-the-module-manager",
            "text": "The first step is configuring the module manager. Inform the module manager\nwhich modules to load, and potentially provide configuration for the module\nlisteners.  Remember the  application.config.php  from earlier? We're going to provide some\nconfiguration.  // config/application.config.php\nreturn array(\n    'modules' => array(\n        /* ... */\n    ),\n    'module_listener_options' => array(\n        'module_paths' => array(\n            './module',\n            './vendor',\n        ),\n    ),\n);  As we add modules to the system, we'll add items to the  modules  array.  Each  Module  class that has configuration it wants the  Application  to know\nabout should define a  getConfig()  method. That method should return an array\nor  Traversable  object such as a  Zend\\Config\\Config  instance. As an example:  namespace ZendUser;\n\nclass Module\n{\n    public function getConfig()\n    {\n        return include __DIR__ . '/config/module.config.php'\n    }\n}  There are a number of other methods you can define for tasks ranging from\nproviding autoloader configuration, to providing services to the ServiceManager , to listening to the bootstrap event.  The ModuleManager documentation \ngoes into more detail on these.",
            "title": "Configuring the Module Manager"
        },
        {
            "location": "/intro/#conclusion",
            "text": "zend-mvc is incredibly flexible, offering an opt-in, easy to create modular\ninfrastructure, as well as the ability to craft your own application workflows\nvia the  ServiceManager  and  EventManager . The  ModuleManager  is a\nlightweight and simple approach to enforcing a modular architecture that\nencourages clean separation of concerns and code re-use.",
            "title": "Conclusion"
        },
        {
            "location": "/quick-start/",
            "text": "Quick Start\n\n\nNow that you have basic knowledge of applications, modules, and how they are\neach structured, we'll show you the easy way to get started.\n\n\nInstall the Zend Skeleton Application\n\n\nThe easiest way to get started is to install the skeleton application via\nComposer.\n\n\nIf you have not yet done so, \ninstall Composer\n.\n\n\nOnce you have, use the \ncreate-project\n command to create a new application:\n\n\n$ composer create-project -sdev zendframework/skeleton-application my-application\n\n\n\nCreate a New Module\n\n\nBy default, one module is provided with the \nZendSkeletonApplication\n, named\n\"Application\". It provides a controller to handle the \"home\" page of the\napplication, the layout template, and templates for 404 and error pages.\n\n\nTypically, you will not need to touch this other than to provide an alternate\nentry page for your site and/or alternate error page.\n\n\nAdditional functionality will be provided by creating new modules.\n\n\nTo get you started with modules, we recommend using the \nZendSkeletonModule\n as\na base. Download it from here:\n\n\n\n\nZendSkeletonModule zip package\n\n\nZendSkeletonModule tarball\n\n\n\n\nDeflate the package, and rename the directory \"ZendSkeletonModule\" to reflect\nthe name of the new module you want to create; when done, move the module into\nyour new project's \nmodule/\n directory.\n\n\nAt this point, it's time to create some functionality.\n\n\nUpdate the Module Class\n\n\nLet's update the \nModule\n class. We'll want to make sure the namespace is correct,\nconfiguration is enabled and returned, and that we setup autoloading on\ninitialization. Since we're actively working on this module, the class list will\nbe in flux; we probably want to be pretty lenient in our autoloading approach,\nso let's keep it flexible by using the \nStandardAutoloader\n. Let's begin.\n\n\nFirst, let's have \nautoload_classmap.php\n return an empty array:\n\n\n<?php\n// autoload_classmap.php\nreturn array();\n\n\n\nWe'll also edit our \nconfig/module.config.php\n file to read as follows:\n\n\nreturn array(\n    'view_manager' => array(\n        'template_path_stack' => array(\n            '<module-name>' => __DIR__ . '/../view'\n        ),\n    ),\n);\n\n\n\nFill in \nmodule-name\n with a lowercased, dash-separated version of your module\nname; e.g., \"ZendUser\" would become \"zend-user\".\n\n\nNext, edit the namespace declaration of the \nModule.php\n file. Replace the\nfollowing line:\n\n\nnamespace ZendSkeletonModule;\n\n\n\nwith the namespace you want to use for your application.\n\n\nNext, rename the directory \nsrc/ZendSkeletonModule\n to \nsrc/<YourModuleName>\n,\nand the directory \nview/zend-skeleton-module\n to \nsrc/<your-module-name>\n.\n\n\nAt this point, you now have your module configured properly. Let's create a\ncontroller!\n\n\nCreate a Controller\n\n\nControllers are objects that implement \nZend\\Stdlib\\DispatchableInterface\n. This\nmeans they need to implement a \ndispatch()\n method that takes minimally a\n\nRequest\n object as an argument.\n\n\nIn practice, though, this would mean writing logic to branch based on matched\nrouting within every controller. As such, we've created several base controller\nclasses for you to start with:\n\n\n\n\nZend\\Mvc\\Controller\\AbstractActionController\n allows routes to match an\n  \"action\". When matched, a method named after the action will be called by the\n  controller. As an example, if you had a route that returned \"foo\" for the\n  \"action\" key, the \"fooAction\" method would be invoked.\n\n\nZend\\Mvc\\Controller\\AbstractRestfulController\n introspects the \nRequest\n to\n  determine what HTTP method was used, and calls a method according to that.\n\n\nGET\n will call either the \ngetList()\n method, or, if an \"id\" was matched\n    during routing, the \nget()\n method (with that identifier value).\n\n\nPOST\n will call the \ncreate()\n method, passing in the \n$_POST\n values.\n\n\nPUT\n expects an \"id\" to be matched during routing, and will call the\n    \nupdate()\n method, passing in the identifier, and any data found in the raw\n    post body.\n\n\nDELETE\n expects an \"id\" to be matched during routing, and will call the\n    \ndelete()\n method.\n\n\nZend\\Mvc\\Console\\Controller\\AbstractConsoleController\n extends from\n  \nAbstractActionController\n, but provides methods for retrieving the\n  \nZend\\Console\\Adapter\\AdapterInterface\n instance, and ensuring that execution\n  fails in non-console environments.\n\n\n\n\n\n\nFor version 3, the integration component \nzend-mvc-console\n must be installed. It can be done via Composer:\n\n`bash\ncomposer require zendframework/zend-mvc-console\n\nIf you are not using the component installer, you will need to \nadd this component as a module\n.\n\n\n\n\nTo get started, we'll create a \"hello world\"-style controller, with a single\naction. First, create the file \nHelloController.php\n in the directory\n\nsrc/<module name>/Controller\n. Edit it in your favorite text editor or IDE,\nand insert the following contents:\n\n\n<?php\nnamespace <module name>\\Controller;\n\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\View\\Model\\ViewModel;\n\nclass HelloController extends AbstractActionController\n{\n    public function worldAction()\n    {\n        $message = $this->params()->fromQuery('message', 'foo');\n        return new ViewModel(['message' => $message]);\n    }\n}\n\n\n\nSo, what are we doing here?\n\n\n\n\nWe're creating an action controller.\n\n\nWe're defining an action, \"world\".\n\n\nWe're pulling a message from the query parameters (yes, this is a superbly bad\n  idea in production!  Always sanitize your inputs!).\n\n\nWe're returning a \nViewModel\n with an array of values to be processed later.\n\n\n\n\nWe return a \nViewModel\n. The view layer will use this when rendering the view,\npulling variables and the template name from it. By default, you can omit the\ntemplate name, and it will resolve to \"lowercase-module-name/lowercase-controller-name/lowercase-action-name\".\nHowever, you can override this to specify something different by calling\n\nsetTemplate()\n on the \nViewModel\n instance. Typically, templates will resolve\nto files with a \".phtml\" suffix in your module's \nview\n directory.\n\n\nSo, with that in mind, let's create a view script.\n\n\nCreate a View Script\n\n\nCreate the directory \nview/<module-name>/hello\n. Inside that directory, create a\nfile named \nworld.phtml\n. Inside that, paste in the following:\n\n\n<h1>Greetings!</h1>\n\n<p>You said \"<?php echo $this->escapeHtml($message) ?>\".</p>\n\n\n\nThat's it. Save the file.\n\n\n\n\nEscaping output\n\n\nWhat is the method \nescapeHtml()\n? It's actually a \nview helper\n,\nand it's designed to help mitigate XSS attacks. Never trust user input; if you\nare at all uncertain about the source of a given variable in your view script,\nescape it using one of the provided escape view helpers depending on the type\nof data you have.\n\n\n\n\nView scripts for module names with subnamespaces\n\n\nAs per PSR-0, modules should be named following the rule: \n<Vendor Name>\\<Namespace>\\*\n.\n\n\nSince version 3.0, the default template name resolver uses fully qualified\ncontroller class names, stripping only the \n\\Controller\\\\\n subnamespace, if\npresent.  For example, \nAwesomeMe\\MyModule\\Controller\\HelloWorldController\n\nresolves to the template name \nawesome-me/my-module/hello-world\n via the\nfollowing configuration:\n\n\n'view_manager' => array(\n    'controller_map' => array(\n        'AwesomeMe\\MyModule' => true,\n    ),\n),\n\n\n\n(In v2 releases, the default was to strip subnamespaces, but optional mapping rules\nallowed whitelisting namespaces in module configuration to enable current\nresolver behavior. See the \nmigration guide\n\nfor more details.)\n\n\nCreate a Route\n\n\nNow that we have a controller and a view script, we need to create a route to it.\n\n\n\n\nDefault routing\n\n\nZendSkeletonModule\n ships with a \"default route\" that will likely get\nyou to this action. That route is defined roughly as\n\n/{module}/{controller}/{action}\n, which means that the path\n\n/zend-user/hello/world\n will map to \nZendUser\\Controller\\HelloController::worldAction()\n\n(assuming the module name were \nZendUser\n).\n\n\nWe're going to create an explicit route in this example, as\ncreating explicit routes is a recommended practice. The application will look for a\n\nZend\\Router\\RouteStackInterface\n instance to setup routing. The default generated router is a\n\nZend\\Router\\Http\\TreeRouteStack\n.\n\n\nTo use the \"default route\" functionality, you will need to edit the shipped\nrouting definition in the module's \nconfig/module.config.php\n, and replace:\n\n\n\n\n/module-specific-root\n with a module-specific root path.\n\n\nZendSkeletonModule\\Controller\n with \n<YourModuleName>\\Controller\n.\n\n\n\n\n\n\nAdditionally, we need to tell the application we have a controller:\n\n\n// module.config.php\nreturn [\n    'controllers' => [\n        'invokables' => [\n            '<module-namespace>\\Controller\\Index' => '<module-namespace>\\Controller\\IndexController',\n            // Do similar for each other controller in your module\n        ],\n    ],\n   // ... other configuration ...\n];\n\n\n\n\n\nController services\n\n\nWe inform the application about controllers we expect to have in the\napplication. This is to prevent somebody requesting any service the\n\nServiceManager\n knows about in an attempt to break the application. The\ndispatcher uses a special, scoped container that will only pull controllers\nthat are specifically registered with it, either as invokable classes or via\nfactories.\n\n\n\n\nOpen your \nconfig/module.config.php\n file, and modify it to add to the \"routes\"\nand \"controller\" parameters so it reads as follows:\n\n\nreturn [\n    'router' => [\n        'routes' => [\n            '<module name>-hello-world' => [\n                'type'    => 'Literal',\n                    'options' => [\n                    'route' => '/hello/world',\n                    'defaults' => [\n                        'controller' => '<module name>\\Controller\\Hello',\n                        'action'     => 'world',\n                    ],\n                ],\n            ],\n        ],\n    ],\n    'controllers' => [\n        'invokables' => [\n            '<module namespace>\\Controller\\Hello' => '<module\nnamespace>\\Controller\\HelloController',\n        ],\n    ],\n    // ... other configuration ...\n];\n\n\n\nTell the Application About our Module\n\n\nOne problem: we haven't told our application about our new module!\n\n\nBy default, modules are not utilized unless we tell the module manager about them.\nAs such, we need to notify the application about them.\n\n\nRemember the \nconfig/application.config.php\n file? Let's modify it to add our\nnew module. Once done, it should read as follows:\n\n\n<?php\nreturn array(\n    'modules' => array(\n        'Application',\n        '<module namespace>',\n    ),\n    'module_listener_options' => array(\n        'module_paths' => array(\n            './module',\n            './vendor',\n        ),\n    ),\n);\n\n\n\nReplace \n<module namespace>\n with the namespace of your module.\n\n\nTest it Out!\n\n\nNow we can test things out! Create a new vhost pointing its document root to the \npublic\n directory\nof your application, and fire it up in a browser. You should see the default homepage template of\nZendSkeletonApplication.\n\n\nNow alter the location in your URL to append the path \"/hello/world\", and load the page. You should\nnow get the following content:\n\n\n<h1>Greetings!</h1>\n\n<p>You said \"foo\".</p>\n\n\n\nNow alter the location to append \"?message=bar\" and load the page. You should now get:\n\n\n<h1>Greetings!</h1>\n\n<p>You said \"bar\".</p>\n\n\n\nCongratulations! You've created your first ZF2 MVC module!",
            "title": "Quick Start"
        },
        {
            "location": "/quick-start/#quick-start",
            "text": "Now that you have basic knowledge of applications, modules, and how they are\neach structured, we'll show you the easy way to get started.",
            "title": "Quick Start"
        },
        {
            "location": "/quick-start/#install-the-zend-skeleton-application",
            "text": "The easiest way to get started is to install the skeleton application via\nComposer.  If you have not yet done so,  install Composer .  Once you have, use the  create-project  command to create a new application:  $ composer create-project -sdev zendframework/skeleton-application my-application",
            "title": "Install the Zend Skeleton Application"
        },
        {
            "location": "/quick-start/#create-a-new-module",
            "text": "By default, one module is provided with the  ZendSkeletonApplication , named\n\"Application\". It provides a controller to handle the \"home\" page of the\napplication, the layout template, and templates for 404 and error pages.  Typically, you will not need to touch this other than to provide an alternate\nentry page for your site and/or alternate error page.  Additional functionality will be provided by creating new modules.  To get you started with modules, we recommend using the  ZendSkeletonModule  as\na base. Download it from here:   ZendSkeletonModule zip package  ZendSkeletonModule tarball   Deflate the package, and rename the directory \"ZendSkeletonModule\" to reflect\nthe name of the new module you want to create; when done, move the module into\nyour new project's  module/  directory.  At this point, it's time to create some functionality.",
            "title": "Create a New Module"
        },
        {
            "location": "/quick-start/#update-the-module-class",
            "text": "Let's update the  Module  class. We'll want to make sure the namespace is correct,\nconfiguration is enabled and returned, and that we setup autoloading on\ninitialization. Since we're actively working on this module, the class list will\nbe in flux; we probably want to be pretty lenient in our autoloading approach,\nso let's keep it flexible by using the  StandardAutoloader . Let's begin.  First, let's have  autoload_classmap.php  return an empty array:  <?php\n// autoload_classmap.php\nreturn array();  We'll also edit our  config/module.config.php  file to read as follows:  return array(\n    'view_manager' => array(\n        'template_path_stack' => array(\n            '<module-name>' => __DIR__ . '/../view'\n        ),\n    ),\n);  Fill in  module-name  with a lowercased, dash-separated version of your module\nname; e.g., \"ZendUser\" would become \"zend-user\".  Next, edit the namespace declaration of the  Module.php  file. Replace the\nfollowing line:  namespace ZendSkeletonModule;  with the namespace you want to use for your application.  Next, rename the directory  src/ZendSkeletonModule  to  src/<YourModuleName> ,\nand the directory  view/zend-skeleton-module  to  src/<your-module-name> .  At this point, you now have your module configured properly. Let's create a\ncontroller!",
            "title": "Update the Module Class"
        },
        {
            "location": "/quick-start/#create-a-controller",
            "text": "Controllers are objects that implement  Zend\\Stdlib\\DispatchableInterface . This\nmeans they need to implement a  dispatch()  method that takes minimally a Request  object as an argument.  In practice, though, this would mean writing logic to branch based on matched\nrouting within every controller. As such, we've created several base controller\nclasses for you to start with:   Zend\\Mvc\\Controller\\AbstractActionController  allows routes to match an\n  \"action\". When matched, a method named after the action will be called by the\n  controller. As an example, if you had a route that returned \"foo\" for the\n  \"action\" key, the \"fooAction\" method would be invoked.  Zend\\Mvc\\Controller\\AbstractRestfulController  introspects the  Request  to\n  determine what HTTP method was used, and calls a method according to that.  GET  will call either the  getList()  method, or, if an \"id\" was matched\n    during routing, the  get()  method (with that identifier value).  POST  will call the  create()  method, passing in the  $_POST  values.  PUT  expects an \"id\" to be matched during routing, and will call the\n     update()  method, passing in the identifier, and any data found in the raw\n    post body.  DELETE  expects an \"id\" to be matched during routing, and will call the\n     delete()  method.  Zend\\Mvc\\Console\\Controller\\AbstractConsoleController  extends from\n   AbstractActionController , but provides methods for retrieving the\n   Zend\\Console\\Adapter\\AdapterInterface  instance, and ensuring that execution\n  fails in non-console environments.    For version 3, the integration component  zend-mvc-console  must be installed. It can be done via Composer: `bash\ncomposer require zendframework/zend-mvc-console \nIf you are not using the component installer, you will need to  add this component as a module .   To get started, we'll create a \"hello world\"-style controller, with a single\naction. First, create the file  HelloController.php  in the directory src/<module name>/Controller . Edit it in your favorite text editor or IDE,\nand insert the following contents:  <?php\nnamespace <module name>\\Controller;\n\nuse Zend\\Mvc\\Controller\\AbstractActionController;\nuse Zend\\View\\Model\\ViewModel;\n\nclass HelloController extends AbstractActionController\n{\n    public function worldAction()\n    {\n        $message = $this->params()->fromQuery('message', 'foo');\n        return new ViewModel(['message' => $message]);\n    }\n}  So, what are we doing here?   We're creating an action controller.  We're defining an action, \"world\".  We're pulling a message from the query parameters (yes, this is a superbly bad\n  idea in production!  Always sanitize your inputs!).  We're returning a  ViewModel  with an array of values to be processed later.   We return a  ViewModel . The view layer will use this when rendering the view,\npulling variables and the template name from it. By default, you can omit the\ntemplate name, and it will resolve to \"lowercase-module-name/lowercase-controller-name/lowercase-action-name\".\nHowever, you can override this to specify something different by calling setTemplate()  on the  ViewModel  instance. Typically, templates will resolve\nto files with a \".phtml\" suffix in your module's  view  directory.  So, with that in mind, let's create a view script.",
            "title": "Create a Controller"
        },
        {
            "location": "/quick-start/#create-a-view-script",
            "text": "Create the directory  view/<module-name>/hello . Inside that directory, create a\nfile named  world.phtml . Inside that, paste in the following:  <h1>Greetings!</h1>\n\n<p>You said \"<?php echo $this->escapeHtml($message) ?>\".</p>  That's it. Save the file.",
            "title": "Create a View Script"
        },
        {
            "location": "/quick-start/#escaping-output",
            "text": "What is the method  escapeHtml() ? It's actually a  view helper ,\nand it's designed to help mitigate XSS attacks. Never trust user input; if you\nare at all uncertain about the source of a given variable in your view script,\nescape it using one of the provided escape view helpers depending on the type\nof data you have.",
            "title": "Escaping output"
        },
        {
            "location": "/quick-start/#view-scripts-for-module-names-with-subnamespaces",
            "text": "As per PSR-0, modules should be named following the rule:  <Vendor Name>\\<Namespace>\\* .  Since version 3.0, the default template name resolver uses fully qualified\ncontroller class names, stripping only the  \\Controller\\\\  subnamespace, if\npresent.  For example,  AwesomeMe\\MyModule\\Controller\\HelloWorldController \nresolves to the template name  awesome-me/my-module/hello-world  via the\nfollowing configuration:  'view_manager' => array(\n    'controller_map' => array(\n        'AwesomeMe\\MyModule' => true,\n    ),\n),  (In v2 releases, the default was to strip subnamespaces, but optional mapping rules\nallowed whitelisting namespaces in module configuration to enable current\nresolver behavior. See the  migration guide \nfor more details.)",
            "title": "View scripts for module names with subnamespaces"
        },
        {
            "location": "/quick-start/#create-a-route",
            "text": "Now that we have a controller and a view script, we need to create a route to it.",
            "title": "Create a Route"
        },
        {
            "location": "/quick-start/#default-routing",
            "text": "ZendSkeletonModule  ships with a \"default route\" that will likely get\nyou to this action. That route is defined roughly as /{module}/{controller}/{action} , which means that the path /zend-user/hello/world  will map to  ZendUser\\Controller\\HelloController::worldAction() \n(assuming the module name were  ZendUser ).  We're going to create an explicit route in this example, as\ncreating explicit routes is a recommended practice. The application will look for a Zend\\Router\\RouteStackInterface  instance to setup routing. The default generated router is a Zend\\Router\\Http\\TreeRouteStack .  To use the \"default route\" functionality, you will need to edit the shipped\nrouting definition in the module's  config/module.config.php , and replace:   /module-specific-root  with a module-specific root path.  ZendSkeletonModule\\Controller  with  <YourModuleName>\\Controller .    Additionally, we need to tell the application we have a controller:  // module.config.php\nreturn [\n    'controllers' => [\n        'invokables' => [\n            '<module-namespace>\\Controller\\Index' => '<module-namespace>\\Controller\\IndexController',\n            // Do similar for each other controller in your module\n        ],\n    ],\n   // ... other configuration ...\n];",
            "title": "Default routing"
        },
        {
            "location": "/quick-start/#controller-services",
            "text": "We inform the application about controllers we expect to have in the\napplication. This is to prevent somebody requesting any service the ServiceManager  knows about in an attempt to break the application. The\ndispatcher uses a special, scoped container that will only pull controllers\nthat are specifically registered with it, either as invokable classes or via\nfactories.   Open your  config/module.config.php  file, and modify it to add to the \"routes\"\nand \"controller\" parameters so it reads as follows:  return [\n    'router' => [\n        'routes' => [\n            '<module name>-hello-world' => [\n                'type'    => 'Literal',\n                    'options' => [\n                    'route' => '/hello/world',\n                    'defaults' => [\n                        'controller' => '<module name>\\Controller\\Hello',\n                        'action'     => 'world',\n                    ],\n                ],\n            ],\n        ],\n    ],\n    'controllers' => [\n        'invokables' => [\n            '<module namespace>\\Controller\\Hello' => '<module\nnamespace>\\Controller\\HelloController',\n        ],\n    ],\n    // ... other configuration ...\n];",
            "title": "Controller services"
        },
        {
            "location": "/quick-start/#tell-the-application-about-our-module",
            "text": "One problem: we haven't told our application about our new module!  By default, modules are not utilized unless we tell the module manager about them.\nAs such, we need to notify the application about them.  Remember the  config/application.config.php  file? Let's modify it to add our\nnew module. Once done, it should read as follows:  <?php\nreturn array(\n    'modules' => array(\n        'Application',\n        '<module namespace>',\n    ),\n    'module_listener_options' => array(\n        'module_paths' => array(\n            './module',\n            './vendor',\n        ),\n    ),\n);  Replace  <module namespace>  with the namespace of your module.",
            "title": "Tell the Application About our Module"
        },
        {
            "location": "/quick-start/#test-it-out",
            "text": "Now we can test things out! Create a new vhost pointing its document root to the  public  directory\nof your application, and fire it up in a browser. You should see the default homepage template of\nZendSkeletonApplication.  Now alter the location in your URL to append the path \"/hello/world\", and load the page. You should\nnow get the following content:  <h1>Greetings!</h1>\n\n<p>You said \"foo\".</p>  Now alter the location to append \"?message=bar\" and load the page. You should now get:  <h1>Greetings!</h1>\n\n<p>You said \"bar\".</p>  Congratulations! You've created your first ZF2 MVC module!",
            "title": "Test it Out!"
        },
        {
            "location": "/services/",
            "text": "Default Services\n\n\nThe default and recommended way to write zend-mvc applications uses a set of\nservices defined in the \nZend\\Mvc\\Service\n namespace. This chapter details what\neach of those services are, the classes they represent, and the configuration\noptions available.\n\n\nMany of the services are provided by other components, and the factories and\nabstract factories themselves are defined in the individual components. We will\ncover those factories in this chapter, however, as usage is generally the same\nbetween each.\n\n\nTheory of Operation\n\n\nTo allow easy configuration of all the different parts of the MVC system, a\nsomewhat complex set of services and their factories has been created. We'll try\nto give a simplified explanation of the process.\n\n\nWhen a \nZend\\Mvc\\Application\n is created, a \nZend\\ServiceManager\\ServiceManager\n\nobject is created and configured via \nZend\\Mvc\\Service\\ServiceManagerConfig\n.\nThe \nServiceManagerConfig\n gets the configuration from\n\nconfig/application.config.php\n (or some other application configuration you\npassed to the \nApplication\n when creating it). From all the service and\nfactories provided in the \nZend\\Mvc\\Service\n namespace, \nServiceManagerConfig\n\nis responsible of configuring only three: \nSharedEventManager\n, \nEventManager\n,\nand \nModuleManager\n.\n\n\nAfter this, the \nApplication\n fetches the \nModuleManager\n. At this point, the\n\nModuleManager\n further configures the \nServiceManager\n with services and\nfactories provided in \nZend\\Mvc\\Service\\ServiceListenerFactory\n. This approach\nallows us to keep the main application configuration concise, and to give the\ndeveloper the power to configure different parts of the MVC system from within\nthe modules, overriding any default configuration in these MVC services.\n\n\nServiceManager\n\n\nAs a quick review, the following service types may be configured:\n\n\n\n\nInvokable services\n, which map a service name to a class that has no\n  constructor or a constructor that accepts no arguments.\n\n\nFactories\n, which map a service name to a factory which will create and\n  return an object. A factory receives the service manager as an argument, and\n  may be any PHP callable, or a class or object that implements\n  \nZend\\ServiceManager\\FactoryInterface\n.\n\n\nAbstract factories\n, which are factories that can create any number of\n  named services that share the same instantiation pattern; examples include\n  database adapters, cache adapters, loggers, etc. The factory receives the\n  service manager as an argument, the resolved service name, and the requested\n  service name; it \nmust\n be a class or object implementing\n  \nZend\\ServiceManager\\AbstractFactoryInterface\n. See the section on\n  \nabstract factories\n\n  for configuration information.\n\n\nAliases\n, which alias one service name to another. Aliases can also\n  reference other aliases.\n\n\nInitializers\n, which receive the newly created instance and the service\n  manager, and which can be used to perform additional initialization tasks. The\n  most common use case is to test the instance against specific \"Aware\"\n  interfaces, and, if matching, inject them with the appropriate service.\n\n\nDelegators\n, which typically \ndecorate\n retrieval of a service to either\n  substitute an alternate service, decorate the created service, or perform\n  pre/post initialization tasks when creating a service.\n\n\nLazy services\n, which are decorators for services with expensive\n  initialization; the service manager essentially returns a proxy service that\n  defers initialization until the first call is made to the service.\n\n\nPlugin managers\n, which are specialized service managers used to manage\n  objects that are of a related type, such as view helpers, controller plugins,\n  controllers, etc. Plugin managers accept configuration just like service\n  managers, and as such can compose each of the service types listed above.\n  They are also \nServiceLocatorAware\n, and will be injected with the application\n  service manager instance, giving factories and abstract factories access to\n  application-level services when needed. See the heading\n  \nPlugin managers\n for a list of available plugin managers.\n\n\n\n\nThe application service manager is referenced directly during bootstrapping, and has the following\nservices configured out of the box.\n\n\nInvokable services\n\n\n\n\nDispatchListener\n, mapping to \nZend\\Mvc\\DispatchListener\n.\n\n\nZend\\Mvc\\MiddlewareListener\n.\n\n\nRouteListener\n, mapping to \nZend\\Mvc\\RouteListener\n.\n\n\nSendResponseListener\n, mapping to \nZend\\Mvc\\SendResponseListener\n.\n\n\nSharedEventManager\n, mapping to \nZend\\EventManager\\SharedEventManager\n.\n\n\n\n\nFactories\n\n\n\n\n\n\nApplication\n, mapping to \nZend\\Mvc\\Service\\ApplicationFactory\n.\n\n\n\n\n\n\nConfig\n, mapping to \nZend\\Mvc\\Service\\ConfigFactory\n. Internally, this\n  pulls the \nModuleManager\n service, calls its \nloadModules()\n method, and\n  retrieves the merged configuration from the module event. As such, this\n  service contains the entire, merged application configuration.\n\n\n\n\n\n\nControllerManager\n, mapping to \nZend\\Mvc\\Service\\ControllerLoaderFactory\n.\n  This creates an instance of \nZend\\Mvc\\Controller\\ControllerManager\n, passing\n  the service manager instance.  Additionally, it uses the\n  \nDiStrictAbstractServiceFactory\n service, effectively allowing you to fall\n  back to DI in order to retrieve your controllers. If you want to use\n  \nZend\\Di\n to retrieve your controllers, you must white-list them in your DI\n  configuration under the \nallowed_controllers\n key (otherwise, they will just\n  be ignored).  The \nControllerManager\n provides initializers for the\n  following:\n\n\n\n\n\n\nIf the controller implements \nZend\\ServiceManager\\ServiceLocatorAwareInterface\n\n  (or the methods it defines), an instance of the \nServiceManager\n will be\n  injected into it.\n\n\n\n\n\n\nIf the controller implements \nZend\\EventManager\\EventManagerAwareInterface\n,\n  an instance of the \nEventManager\n will be injected into it.\n\n\n\n\n\n\nFinally, an initializer will inject it with the \nControllerPluginManager\n\n  service, as long as the \nsetPluginManager\n method is implemented.\n\n\n\n\n\n\n\n\n\n\nControllerPluginManager\n, mapping to\n  \nZend\\Mvc\\Service\\ControllerPluginManagerFactory\n. This instantiates the\n  \nZend\\Mvc\\Controller\\PluginManager\n instance, passing it the service manager\n  instance. It also uses the \nDiAbstractServiceFactory\n service, effectively\n  allowing you to fall back to DI in order to retrieve your \ncontroller plugins\n.\n  It registers a set of default controller plugins, and contains an\n  initializer for injecting plugins with the current controller.\n\n\n\n\n\n\nConsoleAdapter\n, mapping to \nZend\\Mvc\\Service\\ConsoleAdapterFactory\n. This\n  grabs the \nConfig\n service, pulls from the \nconsole\n key, and do the\n  following:\n\n\n\n\n\n\nIf the \nadapter\n subkey is present, it is used to get the adapter\n  instance, otherwise, \nZend\\Console\\Console::detectBestAdapter()\n will be\n  called to configure an adapter instance.\n\n\n\n\n\n\nIf the \ncharset\n subkey is present, the value is used to set the adapter\n  charset.\n\n\n\n\n\n\n\n\n\n\nConsoleRouter\n, mapping to \nZend\\Mvc\\Console\\Router\\ConsoleRouterFactory\n. This\n  grabs the \nConfig\n service, and pulls from the \nconsole\n key and \nrouter\n\n  subkey, configuring a \nZend\\Mvc\\Console\\Router\\SimpleRouteStack\n instance.\n\n\n\n\n\n\nConsoleViewManager\n, mapping to \nZend\\Mvc\\Service\\ConsoleViewManagerFactory\n.\n  This creates and returns an instance of \nZend\\Mvc\\View\\Console\\ViewManager\n,\n  which in turn registers and initializes a number of console-specific view\n  services.\n\n\n\n\n\n\nDependencyInjector\n, mapping to \nZend\\Mvc\\Service\\DiFactory\n. This pulls\n  the \nConfig\n service, and looks for a \"di\" key; if found, that value is used\n  to configure a new \nZend\\Di\\Di\n instance.\n\n\n\n\n\n\nDiAbstractServiceFactory\n, mapping to\n  \nZend\\Mvc\\Service\\DiAbstractServiceFactoryFactory\n. This creates an instance\n  of \nZend\\ServiceManager\\Di\\DiAbstractServiceFactory\n injecting the \nDi\n\n  service instance. That instance is attached to the service manager as an\n  abstract factory, effectively enabling DI as a fallback for providing\n  services.\n\n\n\n\n\n\nDiServiceInitializer\n, mapping to \nZend\\Mvc\\Service\\DiServiceInitializerFactory\n.\n  This creates an instance of \nZend\\ServiceManager\\Di\\DiServiceInitializer\n\n  injecting the \nDi\n service and the service manager itself.\n\n\n\n\n\n\nDiStrictAbstractServiceFactory\n, mapping to \nZend\\Mvc\\Service\\DiStrictAbstractServiceFactoryFactory\n.\n  This creates an instance of \nZend\\Mvc\\Service\\DiStrictAbstractServiceFactoryFactory\n,\n  injecting the \nDi\n service instance.\n\n\n\n\n\n\nEventManager\n, mapping to \nZend\\Mvc\\Service\\EventManagerFactory\n. This\n  factory returns a \ndiscrete\n instance of \nZend\\EventManager\\EventManager\n on\n  each request. This service is not shared by default, allowing the ability to\n  have an \nEventManager\n per service, with a shared \nSharedEventManager\n\n  injected in each.\n\n\n\n\n\n\nFilterManager\n, mapping to \nZend\\Mvc\\Service\\FilterManagerFactory\n. This\n  instantiates the \nZend\\Filter\\FilterPluginManager\n instance, passing it the\n  service manager instance; this is used to manage filters for \nfilter chains\n.\n  It also uses the \nDiAbstractServiceFactory\n service, effectively allowing\n  you to fall back to DI in order to retrieve filters.\n\n\n\n\n\n\nFormElementManager\n, mapping to \nZend\\Mvc\\Service\\FormElementManagerFactory\n.\n  This instantiates the \nZend\\Form\\FormElementManager\n instance, passing it\n  the service manager instance; this is used to manage \nform elements\n.\n  It also uses the \nDiAbstractServiceFactory\n service, effectively allowing\n  you to fall back to DI in order to retrieve form elements.\n\n\n\n\n\n\nHttpRouter\n, mapping to \nZend\\Router\\Http\\HttpRouterFactory\n. This grabs\n  the \nConfig\n service, and pulls from the \nrouter\n key, configuring a\n  \nZend\\Router\\Http\\TreeRouteStack\n instance.\n\n\n\n\n\n\nHttpViewManager\n, mapping to \nZend\\Mvc\\Service\\HttpViewManagerFactory\n.\n  This creates and returns an instance of \nZend\\Mvc\\View\\Http\\ViewManager\n,\n  which in turn registers and initializes a number of HTTP-specific view\n  services.\n\n\n\n\n\n\nHydratorManager\n, mapping to \nZend\\Mvc\\Service\\HydratorManagerFactory\n.\n  This creates and returns an instance of \nZend\\Stdlib\\Hydrator\\HydratorPluginManager\n,\n  which can be used to manage and persist hydrator instances.\n\n\n\n\n\n\nInputFilterManager\n, mapping to \nZend\\Mvc\\Service\\InputFilterManagerFactory\n.\n  This creates and returns an instance of \nZend\\InputFilter\\InputFilterPluginManager\n,\n  which can be used to manage and persist input filter instances.\n\n\n\n\n\n\nModuleManager\n, mapping to \nZend\\Mvc\\Service\\ModuleManagerFactory\n. This is\n  perhaps the most complex factory in the MVC stack. It expects that an\n  \nApplicationConfig\n service has been injected, with keys for\n  \nmodule_listener_options\n and \nmodules\n; see the quick start for samples.\n  It creates an instance of \nZend\\ModuleManager\\Listener\\DefaultListenerAggregate\n,\n  using the \nmodule_listener_options\n retrieved. It then checks if a service\n  with the name \nServiceListener\n exists; if not, it sets a factory with that\n  name mapping to \nZend\\Mvc\\Service\\ServiceListenerFactory\n. A bunch of\n  service listeners will be added to the \nServiceListener\n, like listeners for\n  the \ngetServiceConfig\n, \ngetControllerConfig\n, \ngetControllerPluginConfig\n,\n  and \ngetViewHelperConfig\n module methods.  Next, it retrieves the\n  \nEventManager\n service, and attaches the above listeners.  It instantiates a\n  \nZend\\ModuleManager\\ModuleEvent\n instance, setting the \"ServiceManager\"\n  parameter to the service manager object.  Finally, it instantiates a\n  \nZend\\ModuleManager\\ModuleManager\n instance, and injects the \nEventManager\n\n  and \nModuleEvent\n.\n\n\n\n\n\n\nMvcTranslator\n, mapping to \nZend\\Mvc\\Service\\TranslatorServiceFactory\n, and\n  returning an instance of \nZend\\Mvc\\I18n\\Translator\n, which extends\n  \nZend\\I18n\\Translator\\Translator\n and implements \nZend\\Validator\\Translator\\TranslatorInterface\n,\n  allowing the instance to be used anywhere a translator may be required in\n  the framework.\n\n\n\n\n\n\nPaginatorPluginManager\n, mapping to \nZend\\Mvc\\Service\\PaginatorPluginManagerFactory\n.\n  This instantiates the \nZend\\Paginator\\AdapterPluginManager\n instance,\n  passing it the service manager instance. This is used to manage\n  \npaginator adapters\n.\n  It also uses the \nDiAbstractServiceFactory\n service, effectively allowing\n  you to fall back to DI in order to retrieve paginator adapters.\n\n\n\n\n\n\nRequest\n, mapping to \nZend\\Mvc\\Service\\RequestFactory\n. The factory is used\n  to create and return a request instance, according to the current\n  environment. If the current environment is a console environment, it will\n  create a \nZend\\Console\\Request\n; otherwise, for HTTP environments, it\n  creates a \nZend\\Http\\PhpEnvironment\\Request\n.\n\n\n\n\n\n\nResponse\n, mapping to \nZend\\Mvc\\Service\\ResponseFactory\n. The factory is\n  used to create and return a response instance, according to the current\n  environment. If the current environment is a console environment, it will\n  create a \nZend\\Console\\Response\n; otherwise, for HTTP environments, it\n  creates a \nZend\\Http\\PhpEnvironment\\Response\n.\n\n\n\n\n\n\nRouter\n, mapping to \nZend\\Router\\RouterFactory\n. If in a console\n  environment, it proxies to the \nConsoleRouter\n service; otherwise, it proxies\n  to the \nHttpRouter\n service.\n\n\n\n\n\n\nRoutePluginManager\n, mapping to \nZend\\Mvc\\Service\\RoutePluginManagerFactory\n.\n  This instantiates the \nZend\\Router\\RoutePluginManager\n instance, passing\n  it the service manager instance; this is used to manage \nroute types\n.\n  It also uses the \nDiAbstractServiceFactory\n service, effectively allowing\n  you to fall back to DI in order to retrieve route types.\n\n\n\n\n\n\nSerializerAdapterManager\n, mapping to \nZend\\Mvc\\Service\\SerializerAdapterPluginManagerFactory\n,\n  which returns an instance of \nZend\\Serializer\\AdapterPluginManager\n. This is\n  a plugin manager for managing serializer adapter instances.\n\n\n\n\n\n\nServiceListener\n, mapping to \nZend\\Mvc\\Service\\ServiceListenerFactory\n. The\n  factory is used to instantiate the \nServiceListener\n, while allowing easy\n  extending. It checks if a service with the name \nServiceListenerInterface\n\n  exists, which must implement \nZend\\ModuleManager\\Listener\\ServiceListenerInterface\n,\n  before instantiating the default \nServiceListener\n.\n  In addition to this, it retrieves the \nApplicationConfig\n and looks for the\n  \nservice_listener_options\n key. This allows you to register own listeners\n  for module methods and configuration keys to create an own service manager;\n  see the \napplication configuration options\n for samples.\n\n\n\n\n\n\nValidatorManager\n, mapping to \nZend\\Mvc\\Service\\ValidatorManagerFactory\n.\n  This instantiates the \nZend\\Validator\\ValidatorPluginManager\n instance,\n  passing it the service manager instance. This is used to manage\n  \nvalidators\n.\n  It also uses the \nDiAbstractServiceFactory\n service, effectively allowing\n  you to fall back to DI in order to retrieve validators.\n\n\n\n\n\n\nViewFeedRenderer\n, mapping to \nZend\\Mvc\\Service\\ViewFeedRendererFactory\n,\n  which returns an instance of \nZend\\View\\Renderer\\FeedRenderer\n, used to\n  render feeds.\n\n\n\n\n\n\nViewFeedStrategy\n, mapping to \nZend\\Mvc\\Service\\ViewFeedStrategyFactory\n,\n  which returns an instance of \nZend\\View\\Strategy\\FeedStrategy\n, used to\n  select the \nViewFeedRenderer\n given the appropriate criteria.\n\n\n\n\n\n\nViewHelperManager\n, mapping to \nZend\\Mvc\\Service\\ViewHelperManagerFactory\n,\n  which returns an instance of \nZend\\View\\HelperManager\n. This is a plugin\n  manager for managing view helper instances.\n\n\n\n\n\n\nViewJsonRenderer\n, mapping to \nZend\\Mvc\\Service\\ViewJsonRendererFactory\n,\n  which returns an instance of \nZend\\View\\Renderer\\JsonRenderer\n, used to\n  render JSON structures.\n\n\n\n\n\n\nViewJsonStrategy\n, mapping to \nZend\\Mvc\\Service\\ViewJsonStrategyFactory\n,\n  which returns an instance of \nZend\\View\\Strategy\\JsonStrategy\n, used to\n  select the \nViewJsonRenderer\n given the appropriate criteria.\n\n\n\n\n\n\nViewManager\n, mapping to \nZend\\Mvc\\Service\\ViewManagerFactory\n. The factory\n  is used to create and return a view manager, according to the current\n  environment. If the current environment is a console environment, it will\n  create a \nZend\\Mvc\\View\\Console\\ViewManager\n; otherwise, for HTTP\n  environments, it returns a \nZend\\Mvc\\View\\Http\\ViewManager\n.\n\n\n\n\n\n\nViewResolver\n, mapping to \nZend\\Mvc\\Service\\ViewResolverFactory\n, which\n  creates and returns the aggregate view resolver. It also attaches the\n  \nViewTemplateMapResolver\n and \nViewTemplatePathStack\n services to it.\n\n\n\n\n\n\nViewTemplateMapResolver\n, mapping to \nZend\\Mvc\\Service\\ViewTemplateMapResolverFactory\n,\n  which creates, configures and returns the \nZend\\View\\Resolver\\TemplateMapResolver\n.\n\n\n\n\n\n\nViewTemplatePathStack\n, mapping to \nZend\\Mvc\\Service\\ViewTemplatePathStackFactory\n,\n  which creates, configures and returns the \nZend\\View\\Resolver\\TemplatePathStack\n.\n\n\n\n\n\n\nAbstract factories\n\n\n\n\nZend\\Cache\\Service\\StorageCacheAbstractServiceFactory\n (opt-in; registered\n  by default in the skeleton application).\n\n\nZend\\Db\\Adapter\\AdapterAbstractServiceFactory\n (opt-in).\n\n\nZend\\Form\\FormAbstractServiceFactory\n is registered by default.\n\n\nZend\\Log\\LoggerAbstractServiceFactory\n (opt-in; registered by default in the skeleton application).\n\n\n\n\nAliases\n\n\n\n\nConfiguration\n, mapping to the \nConfig\n service.\n\n\nConsole\n, mapping to the \nConsoleAdapter\n service.\n\n\nDi\n, mapping to the \nDependencyInjector\n service.\n\n\nMiddlewareListener\n, mapping to the \nZend\\Mvc\\MiddlewareListener\n service.\n\n\nZend\\Di\\LocatorInterface\n, mapping to the \nDependencyInjector\n service.\n\n\nZend\\EventManager\\EventManagerInterface\n, mapping to the \nEventManager\n\n  service. This is mainly to ensure that when falling through to DI, classes\n  are still injected via the \nServiceManager\n.\n\n\nZend\\Mvc\\Controller\\PluginManager\n, mapping to the\n  \nControllerPluginManager\n service. This is mainly to ensure that when\n  falling through to DI, classes are still injected via the \nServiceManager\n.\n\n\nZend\\View\\Resolver\\TemplateMapResolver\n, mapping to the\n  \nViewTemplateMapResolver\n service.\n\n\nZend\\View\\Resolver\\TemplatePathStack\n, mapping to the\n  \nViewTemplatePathStack\n service.\n\n\nZend\\View\\Resolver\\AggregateResolver\n, mapping to the \nViewResolver\n service.\n\n\nZend\\View\\Resolver\\ResolverInterface\n, mapping to the \nViewResolver\n service.\n\n\n\n\nInitializers\n\n\n\n\n\n\nFor objects that implement \nZend\\EventManager\\EventManagerAwareInterface\n,\n  the \nEventManager\n service will be retrieved and injected. This service is\n  \nnot\n shared, though each instance it creates is injected with a shared\n  instance of \nSharedEventManager\n.\n\n\n\n\n\n\nFor objects that implement \nZend\\ServiceManager\\ServiceLocatorAwareInterface\n\n  (or the methods it defines), the \nServiceManager\n will inject itself into\n  the object.\n\n\n\n\n\n\nThe \nServiceManager\n registers itself as the \nServiceManager\n service, and\n  aliases itself to the class names \nZend\\ServiceManager\\ServiceLocatorInterface\n\n  and \nZend\\ServiceManager\\ServiceManager\n.\n\n\n\n\n\n\nAbstract Factories\n\n\nAs noted in the previous section, Zend Framework provides a number of abstract\nservice factories by default. Each is noted below, along with sample\nconfiguration.\n\n\nIn each instance, the abstract factory looks for a top-level configuration key,\nconsisting of key/value pairs where the key is the service name, and the value\nis the configuration to use to create the given service.\n\n\nZend\\Cache\\Service\\StorageCacheAbstractServiceFactory\n\n\nThis abstract factory is opt-in, but registered by default in the skeleton application. It uses the\ntop-level configuration key \"caches\".\n\n\nreturn [\n    'caches' => [\n        'Cache\\Transient' => [\n            'adapter' => 'redis',\n            'ttl'     => 60,\n            'plugins' => [\n                'exception_handler' => [\n                    'throw_exceptions' => false,\n                ],\n            ],\n        ],\n        'Cache\\Persistence' => [\n            'adapter' => 'filesystem',\n            'ttl'     => 86400,\n        ],\n    ],\n];\n\n\n\nSee the \ncache documentation\n\nfor more configuration options.\n\n\nZend\\Db\\Adapter\\AdapterAbstractServiceFactory\n\n\nThis abstract factory is opt-in. It uses the top-level configuration key \"db\",\nwith a subkey \"adapters\".\n\n\nreturn [\n    'db' => ['adapters' => [\n        'Db\\ReadOnly' => [\n            'driver'   => 'Pdo_Sqlite',\n            'database' => 'data/db/users.db',\n        ],\n        'Db\\Writeable' => [\n            'driver'   => 'Mysqli',\n            'database' => 'users',\n            'username' => 'developer',\n            'password' => 'developer_password',\n        ],\n    ]],\n];\n\n\n\nSee the \nDB adapter documentation\n\nfor more configuration options.\n\n\nZend\\Form\\FormAbstractServiceFactory\n\n\nThis abstract factory is registered by default. It uses the top-level\nconfiguration key \"forms\". It makes use of the \nFilterManager\n,\n\nFormElementManager\n, \nHydratorManager\n, \nInputFilterManager\n, and\n\nValidatorManager\n plugin managers in order to allow instantiation and creation\nof form objects and all related objects in the form hierarchy.\n\n\nreturn [\n    'forms' => [\n        'Form\\Foo' => [\n            'hydrator' => 'ObjectProperty',\n            'type'     => 'Zend\\Form\\Form',\n            'elements' => [\n                [\n                    'spec' => [\n                        'type' => 'Zend\\Form\\Element\\Email',\n                        'name' => 'email',\n                        'options' => [\n                            'label' => 'Your email address',\n                        ],\n                    ],\n                ],\n            ],\n        ],\n    ],\n];\n\n\n\nForm configuration follows the same configuration you would use with a form\nfactory; the primary difference is that all plugin managers have already been\ninjected for you, allowing you the possibility of custom objects or\nsubstitutions.\n\n\nSee the \nform factory documentation\n\nfor more configuration options.\n\n\nZend\\Log\\LoggerAbstractServiceFactory\n\n\nThis abstract factory is opt-in, but registered by default in the skeleton\napplication. It uses the top-level configuration key \"log\".\n\n\nreturn [\n    'log' => [\n        'Log\\App' => [\n            'writers' => [\n                [\n                    'name' => 'stream',\n                    'priority' => 1000,\n                    'options' => [\n                        'stream' => 'data/logs/app.log',\n                    ],\n                ],\n            ],\n        ],\n    ],\n];\n\n\n\nSee the \nlog documentation\n\nfor more configuration options.\n\n\nPlugin Managers\n\n\nThe following plugin managers are configured by default:\n\n\n\n\nControllerManager\n, corresponding to \nZend\\Mvc\\Controller\\ControllerManager\n,\n  and used to manage controller instances.\n\n\nControllerPluginManager\n, corresponding to \nZend\\Mvc\\Controller\\PluginManager\n,\n  and used to manage controller plugin instances.\n\n\nFilterManager\n, corresponding to \nZend\\Filter\\FilterPluginManager\n, and\n  used to manage filter instances.\n\n\nFormElementManager\n, corresponding to \nZend\\Form\\FormElementManager\n, and\n  used to manage instances of form elements and fieldsets.\n\n\nHydratorManager\n, corresponding to \nZend\\Stdlib\\Hydrator\\HydratorPluginManager\n,\n  and used to manage hydrator instances.\n\n\nInputFilterManager\n, corresponding to \nZend\\InputFilter\\InputFilterPluginManager\n,\n  and used to manage input filter instances.\n\n\nRoutePluginManager\n, corresponding to \nZend\\Router\\RoutePluginManager\n,\n  and used to manage route instances.\n\n\nSerializerAdapterManager\n, corresponding to \nZend\\Serializer\\AdapterPluginManager\n,\n  and used to manage serializer instances.\n\n\nValidatorManager\n, corresponding to \nZend\\Validator\\ValidatorPluginManager\n,\n  and used to manage validator instances.\n\n\nViewHelperManager\n, corresponding to \nZend\\View\\HelperPluginManager\n, and\n  used to manage view helper instances.\n\n\n\n\nAs noted in the previous section, all plugin managers share the same\nconfiguration and service types as the standard service manager; they are simply\nscoped, and only allow instances of certain types to be created or registered.\nDefault types available are listed in the documentation for each component.\n\n\nViewManager\n\n\nThe View layer within zend-mvc consists of a large number of collaborators and\nevent listeners. As such, \nZend\\Mvc\\View\\ViewManager\n was created to handle\ncreation of the various objects, as well as wiring them together and\nestablishing event listeners.\n\n\nThe \nViewManager\n itself is an event listener on the \nbootstrap\n event. It\nretrieves the \nServiceManager\n from the \nApplication\n object, as well as its\ncomposed \nEventManager\n.\n\n\nConfiguration for all members of the \nViewManager\n fall under the \nview_manager\n\nconfiguration key, and expect values as noted below. The following services are\ncreated and managed by the \nViewManager\n:\n\n\n\n\n\n\nViewHelperManager\n, representing and aliased to \nZend\\View\\HelperPluginManager\n.\n  It is seeded with the \nServiceManager\n. Created via the\n  \nZend\\Mvc\\Service\\ViewHelperManagerFactory\n.\n\n\n\n\n\n\nThe \nRouter\n service is retrieved, and injected into the \nUrl\n helper.\n\n\n\n\n\n\nIf the \nbase_path\n key is present, it is used to inject the \nBasePath\n view\n  helper; otherwise, the \nRequest\n service is retrieved, and the value of its\n  \ngetBasePath()\n method is used.\n\n\n\n\n\n\nIf the \nbase_path_console\n key is present, it is used to inject the\n  \nBasePath\n view helper for console requests; otherwise, the \nRequest\n\n  service is retrieved, and the value of its \ngetBasePath()\n method is used.\n  This can be useful for sending urls in emails via a cronjob.\n\n\n\n\n\n\nIf the \ndoctype\n key is present, it will be used to set the value of the\n  \nDoctype\n view helper.\n\n\n\n\n\n\n\n\n\n\nViewTemplateMapResolver\n, representing and aliased to\n  \nZend\\View\\Resolver\\TemplateMapResolver\n.  If a \ntemplate_map\n key is present,\n  it will be used to seed the template map.\n\n\n\n\n\n\nViewTemplatePathStack\n, representing and aliased to\n  \nZend\\View\\Resolver\\TemplatePathStack\n.\n\n\n\n\n\n\nIf a \ntemplate_path_stack\n key is present, it will be used to seed the\n  stack.\n\n\n\n\n\n\nIf a \ndefault_template_suffix\n key is present, it will be used as the\n  default suffix for template scripts resolving.\n\n\n\n\n\n\n\n\n\n\nViewResolver\n, representing and aliased to \nZend\\View\\Resolver\\AggregateResolver\n\n  and \nZend\\View\\Resolver\\ResolverInterface\n. It is seeded with the\n  \nViewTemplateMapResolver\n and \nViewTemplatePathStack\n services as resolvers.\n\n\n\n\n\n\nViewRenderer\n, representing and aliased to \nZend\\View\\Renderer\\PhpRenderer\n\n  and \nZend\\View\\Renderer\\RendererInterface\n. It is seeded with the\n  \nViewResolver\n and \nViewHelperManager\n services. Additionally, the \nViewModel\n\n  helper gets seeded with the \nViewModel\n as its root (layout) model.\n\n\n\n\n\n\nViewPhpRendererStrategy\n, representing and aliased to\n  \nZend\\View\\Strategy\\PhpRendererStrategy\n. It gets seeded with the\n  \nViewRenderer\n service.\n\n\n\n\n\n\nView\n, representing and aliased to \nZend\\View\\View\n. It gets seeded with the\n  \nEventManager\n service, and attaches the \nViewPhpRendererStrategy\n as an\n  aggregate listener.\n\n\n\n\n\n\nDefaultRenderingStrategy\n, representing and aliased to\n  \nZend\\Mvc\\View\\DefaultRenderingStrategy\n.  If the \nlayout\n key is present, it\n  is used to seed the strategy's layout template. It is seeded with the \nView\n\n  service.\n\n\n\n\n\n\nExceptionStrategy\n, representing and aliased to \nZend\\Mvc\\View\\ExceptionStrategy\n.\n  If the \ndisplay_exceptions\n or \nexception_template\n keys are present, they are\n  used to configure the strategy.\n\n\n\n\n\n\nRouteNotFoundStrategy\n, representing and aliased to \nZend\\Mvc\\View\\RouteNotFoundStrategy\n\n  and \n404Strategy\n. If the \ndisplay_not_found_reason\n or \nnot_found_template\n\n  keys are present, they are used to configure the strategy.\n\n\n\n\n\n\nViewModel\n. In this case, no service is registered; the \nViewModel\n is\n  retrieved from the \nMvcEvent\n and injected with the layout template name.\n\n\n\n\n\n\nThe \nViewManager\n also creates several other listeners, but does not expose them\nas services; these include \nZend\\Mvc\\View\\CreateViewModelListener\n,\n\nZend\\Mvc\\View\\InjectTemplateListener\n, and \nZend\\Mvc\\View\\InjectViewModelListener\n.\nThese, along with \nRouteNotFoundStrategy\n, \nExceptionStrategy\n, and\n\nDefaultRenderingStrategy\n are attached as listeners either to the application\n\nEventManager\n instance or the \nSharedEventManager\n instance.\n\n\nFinally, if you have a \nstrategies\n key in your configuration, the \nViewManager\n\nwill loop over these and attach them in order to the \nView\n service as\nlisteners, at a priority of 100 (allowing them to execute before the\n\nDefaultRenderingStrategy\n).\n\n\nApplication Configuration Options\n\n\nThe following options may be used to provide initial configuration for the\n\nServiceManager\n, \nModuleManager\n, and \nApplication\n instances, allowing them to\nthen find and aggregate the configuration used for the \nConfig\n service, which\nis intended for configuring all other objects in the system. These configuration\ndirectives go to the \nconfig/application.config.php\n file.\n\n\n<?php\nreturn [\n    // This should be an array of module namespaces used in the application.\n    'modules' => [\n    ],\n\n    // These are various options for the listeners attached to the ModuleManager\n    'module_listener_options' => [\n        // This should be an array of paths in which modules reside.\n        // If a string key is provided, the listener will consider that a module\n        // namespace, the value of that key the specific path to that module's\n        // Module class.\n        'module_paths' => [\n        ],\n\n        // An array of paths from which to glob configuration files after\n        // modules are loaded. These effectively override configuration\n        // provided by modules themselves. Paths may use GLOB_BRACE notation.\n        'config_glob_paths' => [\n        ],\n\n        // Whether or not to enable a configuration cache.\n        // If enabled, the merged configuration will be cached and used in\n        // subsequent requests.\n        'config_cache_enabled' => $booleanValue,\n\n        // The key used to create the configuration cache file name.\n        'config_cache_key' => $stringKey,\n\n        // Whether or not to enable a module class map cache.\n        // If enabled, creates a module class map cache which will be used\n        // by in future requests, to reduce the autoloading process.\n        'module_map_cache_enabled' => $booleanValue,\n\n        // The key used to create the class map cache file name.\n        'module_map_cache_key' => $stringKey,\n\n        // The path in which to cache merged configuration.\n        'cache_dir' => $stringPath,\n\n        // Whether or not to enable modules dependency checking.\n        // Enabled by default, prevents usage of modules that depend on other modules\n        // that weren't loaded.\n        'check_dependencies' => $booleanValue,\n    ],\n\n    // Used to create an own service manager. May contain one or more child arrays.\n    'service_listener_options' => [\n       [\n         'service_manager' => $stringServiceManagerName,\n         'config_key'      => $stringConfigKey,\n         'interface'       => $stringOptionalInterface,\n         'method'          => $stringRequiredMethodName,\n       ],\n    ]\n\n    // Initial configuration with which to seed the ServiceManager.\n    // Should be compatible with Zend\\ServiceManager\\Config.\n    'service_manager' => [\n    ],\n];\n\n\n\nFor an example, see the\n\nZendSkeletonApplication configuration file\n.\n\n\nDefault Configuration Options\n\n\nThe following options are available when using the default services configured\nby the \nServiceManagerConfig\n and \nViewManager\n.\n\n\nThese configuration directives can go to the \nconfig/autoload/{{,*.}global,{,*.}local}.php\n\nfiles, or in the \nmodule/<module name>/config/module.config.php\n configuration\nfiles. The merging of these configuration files is done by the \nModuleManager\n.\nIt first merges each module's \nmodule.config.php\n file, and then the files in\n\nconfig/autoload\n (first the \n*.global.php\n and then the \n*.local.php\n files).\nThe order of the merge is relevant so you can override a module's configuration\nwith your application configuration. If you have both a \nconfig/autoload/my.global.config.php\n\nand \nconfig/autoload/my.local.config.php\n, the local configuration file\noverrides the global configuration.\n\n\n\n\nDo not commit local configuration\n\n\nLocal configuration files are intended to keep sensitive information, such as\ndatabase credentials, and as such, it is highly recommended to keep these\nlocal configuration files out of your VCS. The \nZendSkeletonApplication\n's\n\nconfig/autoload/.gitignore\n file ignores \n*.local.php\n files by default.\n\n\n\n\n<?php\nreturn [\n    // The following are used to configure controller loader\n    // Should be compatible with Zend\\ServiceManager\\Config.\n    'controllers' => [\n        // Map of controller \"name\" to class\n        // This should be used if you do not need to inject any dependencies\n        // in your controller\n        'invokables' => [\n        ],\n\n        // Map of controller \"name\" to factory for creating controller instance\n        // You may provide either the class name of a factory, or a PHP callback.\n        'factories' => [\n        ],\n    ],\n\n    // The following are used to configure controller plugin loader\n    // Should be compatible with Zend\\ServiceManager\\Config.\n    'controller_plugins' => [\n    ],\n\n    // The following are used to configure view helper manager\n    // Should be compatible with Zend\\ServiceManager\\Config.\n    'view_helpers' => [\n    ],\n\n    // The following is used to configure a Zend\\Di\\Di instance.\n    // The array should be in a format that Zend\\Di\\Config can understand.\n    'di' => [\n    ],\n\n    // Configuration for the Router service\n    // Can contain any router configuration, but typically will always define\n    // the routes for the application. See the router documentation for details\n    // on route configuration.\n    'router' => [\n        'routes' => [\n        ],\n    ],\n\n    // ViewManager configuration\n    'view_manager' => [\n        // Base URL path to the application\n        'base_path' => $stringBasePath,\n\n        // Doctype with which to seed the Doctype helper\n        'doctype' => $doctypeHelperConstantString, // e.g. HTML5, XHTML1\n\n        // TemplateMapResolver configuration\n        // template/path pairs\n        'template_map' => [\n        ],\n\n        // TemplatePathStack configuration\n        // module/view script path pairs\n        'template_path_stack' => [\n        ],\n        // Default suffix to use when resolving template scripts, if none, 'phtml' is used\n        'default_template_suffix' => $templateSuffix, // e.g. 'php'\n\n        // Controller namespace to template map\n        'controller_map' => [\n        ],\n\n        // Layout template name\n        'layout' => $layoutTemplateName, // e.g. 'layout/layout'\n\n        // ExceptionStrategy configuration\n        'display_exceptions' => $bool, // display exceptions in template\n        'exception_template' => $stringTemplateName, // e.g. 'error'\n\n        // RouteNotFoundStrategy configuration\n        'display_not_found_reason' => $bool, // display 404 reason in template\n        'not_found_template' => $stringTemplateName, // e.g. '404'\n\n        // Additional strategies to attach\n        // These should be class names or service names of View strategy classes\n        // that act as ListenerAggregates. They will be attached at priority 100,\n        // in the order registered.\n        'strategies' => [\n            'ViewJsonStrategy', // register JSON renderer strategy\n            'ViewFeedStrategy', // register Feed renderer strategy\n        ],\n    ],\n];\n\n\n\nFor an example, see the\n\nApplication module configuration file\n\nin the ZendSkeletonApplication.",
            "title": "Default Services"
        },
        {
            "location": "/services/#default-services",
            "text": "The default and recommended way to write zend-mvc applications uses a set of\nservices defined in the  Zend\\Mvc\\Service  namespace. This chapter details what\neach of those services are, the classes they represent, and the configuration\noptions available.  Many of the services are provided by other components, and the factories and\nabstract factories themselves are defined in the individual components. We will\ncover those factories in this chapter, however, as usage is generally the same\nbetween each.",
            "title": "Default Services"
        },
        {
            "location": "/services/#theory-of-operation",
            "text": "To allow easy configuration of all the different parts of the MVC system, a\nsomewhat complex set of services and their factories has been created. We'll try\nto give a simplified explanation of the process.  When a  Zend\\Mvc\\Application  is created, a  Zend\\ServiceManager\\ServiceManager \nobject is created and configured via  Zend\\Mvc\\Service\\ServiceManagerConfig .\nThe  ServiceManagerConfig  gets the configuration from config/application.config.php  (or some other application configuration you\npassed to the  Application  when creating it). From all the service and\nfactories provided in the  Zend\\Mvc\\Service  namespace,  ServiceManagerConfig \nis responsible of configuring only three:  SharedEventManager ,  EventManager ,\nand  ModuleManager .  After this, the  Application  fetches the  ModuleManager . At this point, the ModuleManager  further configures the  ServiceManager  with services and\nfactories provided in  Zend\\Mvc\\Service\\ServiceListenerFactory . This approach\nallows us to keep the main application configuration concise, and to give the\ndeveloper the power to configure different parts of the MVC system from within\nthe modules, overriding any default configuration in these MVC services.",
            "title": "Theory of Operation"
        },
        {
            "location": "/services/#servicemanager",
            "text": "As a quick review, the following service types may be configured:   Invokable services , which map a service name to a class that has no\n  constructor or a constructor that accepts no arguments.  Factories , which map a service name to a factory which will create and\n  return an object. A factory receives the service manager as an argument, and\n  may be any PHP callable, or a class or object that implements\n   Zend\\ServiceManager\\FactoryInterface .  Abstract factories , which are factories that can create any number of\n  named services that share the same instantiation pattern; examples include\n  database adapters, cache adapters, loggers, etc. The factory receives the\n  service manager as an argument, the resolved service name, and the requested\n  service name; it  must  be a class or object implementing\n   Zend\\ServiceManager\\AbstractFactoryInterface . See the section on\n   abstract factories \n  for configuration information.  Aliases , which alias one service name to another. Aliases can also\n  reference other aliases.  Initializers , which receive the newly created instance and the service\n  manager, and which can be used to perform additional initialization tasks. The\n  most common use case is to test the instance against specific \"Aware\"\n  interfaces, and, if matching, inject them with the appropriate service.  Delegators , which typically  decorate  retrieval of a service to either\n  substitute an alternate service, decorate the created service, or perform\n  pre/post initialization tasks when creating a service.  Lazy services , which are decorators for services with expensive\n  initialization; the service manager essentially returns a proxy service that\n  defers initialization until the first call is made to the service.  Plugin managers , which are specialized service managers used to manage\n  objects that are of a related type, such as view helpers, controller plugins,\n  controllers, etc. Plugin managers accept configuration just like service\n  managers, and as such can compose each of the service types listed above.\n  They are also  ServiceLocatorAware , and will be injected with the application\n  service manager instance, giving factories and abstract factories access to\n  application-level services when needed. See the heading\n   Plugin managers  for a list of available plugin managers.   The application service manager is referenced directly during bootstrapping, and has the following\nservices configured out of the box.",
            "title": "ServiceManager"
        },
        {
            "location": "/services/#invokable-services",
            "text": "DispatchListener , mapping to  Zend\\Mvc\\DispatchListener .  Zend\\Mvc\\MiddlewareListener .  RouteListener , mapping to  Zend\\Mvc\\RouteListener .  SendResponseListener , mapping to  Zend\\Mvc\\SendResponseListener .  SharedEventManager , mapping to  Zend\\EventManager\\SharedEventManager .",
            "title": "Invokable services"
        },
        {
            "location": "/services/#factories",
            "text": "Application , mapping to  Zend\\Mvc\\Service\\ApplicationFactory .    Config , mapping to  Zend\\Mvc\\Service\\ConfigFactory . Internally, this\n  pulls the  ModuleManager  service, calls its  loadModules()  method, and\n  retrieves the merged configuration from the module event. As such, this\n  service contains the entire, merged application configuration.    ControllerManager , mapping to  Zend\\Mvc\\Service\\ControllerLoaderFactory .\n  This creates an instance of  Zend\\Mvc\\Controller\\ControllerManager , passing\n  the service manager instance.  Additionally, it uses the\n   DiStrictAbstractServiceFactory  service, effectively allowing you to fall\n  back to DI in order to retrieve your controllers. If you want to use\n   Zend\\Di  to retrieve your controllers, you must white-list them in your DI\n  configuration under the  allowed_controllers  key (otherwise, they will just\n  be ignored).  The  ControllerManager  provides initializers for the\n  following:    If the controller implements  Zend\\ServiceManager\\ServiceLocatorAwareInterface \n  (or the methods it defines), an instance of the  ServiceManager  will be\n  injected into it.    If the controller implements  Zend\\EventManager\\EventManagerAwareInterface ,\n  an instance of the  EventManager  will be injected into it.    Finally, an initializer will inject it with the  ControllerPluginManager \n  service, as long as the  setPluginManager  method is implemented.      ControllerPluginManager , mapping to\n   Zend\\Mvc\\Service\\ControllerPluginManagerFactory . This instantiates the\n   Zend\\Mvc\\Controller\\PluginManager  instance, passing it the service manager\n  instance. It also uses the  DiAbstractServiceFactory  service, effectively\n  allowing you to fall back to DI in order to retrieve your  controller plugins .\n  It registers a set of default controller plugins, and contains an\n  initializer for injecting plugins with the current controller.    ConsoleAdapter , mapping to  Zend\\Mvc\\Service\\ConsoleAdapterFactory . This\n  grabs the  Config  service, pulls from the  console  key, and do the\n  following:    If the  adapter  subkey is present, it is used to get the adapter\n  instance, otherwise,  Zend\\Console\\Console::detectBestAdapter()  will be\n  called to configure an adapter instance.    If the  charset  subkey is present, the value is used to set the adapter\n  charset.      ConsoleRouter , mapping to  Zend\\Mvc\\Console\\Router\\ConsoleRouterFactory . This\n  grabs the  Config  service, and pulls from the  console  key and  router \n  subkey, configuring a  Zend\\Mvc\\Console\\Router\\SimpleRouteStack  instance.    ConsoleViewManager , mapping to  Zend\\Mvc\\Service\\ConsoleViewManagerFactory .\n  This creates and returns an instance of  Zend\\Mvc\\View\\Console\\ViewManager ,\n  which in turn registers and initializes a number of console-specific view\n  services.    DependencyInjector , mapping to  Zend\\Mvc\\Service\\DiFactory . This pulls\n  the  Config  service, and looks for a \"di\" key; if found, that value is used\n  to configure a new  Zend\\Di\\Di  instance.    DiAbstractServiceFactory , mapping to\n   Zend\\Mvc\\Service\\DiAbstractServiceFactoryFactory . This creates an instance\n  of  Zend\\ServiceManager\\Di\\DiAbstractServiceFactory  injecting the  Di \n  service instance. That instance is attached to the service manager as an\n  abstract factory, effectively enabling DI as a fallback for providing\n  services.    DiServiceInitializer , mapping to  Zend\\Mvc\\Service\\DiServiceInitializerFactory .\n  This creates an instance of  Zend\\ServiceManager\\Di\\DiServiceInitializer \n  injecting the  Di  service and the service manager itself.    DiStrictAbstractServiceFactory , mapping to  Zend\\Mvc\\Service\\DiStrictAbstractServiceFactoryFactory .\n  This creates an instance of  Zend\\Mvc\\Service\\DiStrictAbstractServiceFactoryFactory ,\n  injecting the  Di  service instance.    EventManager , mapping to  Zend\\Mvc\\Service\\EventManagerFactory . This\n  factory returns a  discrete  instance of  Zend\\EventManager\\EventManager  on\n  each request. This service is not shared by default, allowing the ability to\n  have an  EventManager  per service, with a shared  SharedEventManager \n  injected in each.    FilterManager , mapping to  Zend\\Mvc\\Service\\FilterManagerFactory . This\n  instantiates the  Zend\\Filter\\FilterPluginManager  instance, passing it the\n  service manager instance; this is used to manage filters for  filter chains .\n  It also uses the  DiAbstractServiceFactory  service, effectively allowing\n  you to fall back to DI in order to retrieve filters.    FormElementManager , mapping to  Zend\\Mvc\\Service\\FormElementManagerFactory .\n  This instantiates the  Zend\\Form\\FormElementManager  instance, passing it\n  the service manager instance; this is used to manage  form elements .\n  It also uses the  DiAbstractServiceFactory  service, effectively allowing\n  you to fall back to DI in order to retrieve form elements.    HttpRouter , mapping to  Zend\\Router\\Http\\HttpRouterFactory . This grabs\n  the  Config  service, and pulls from the  router  key, configuring a\n   Zend\\Router\\Http\\TreeRouteStack  instance.    HttpViewManager , mapping to  Zend\\Mvc\\Service\\HttpViewManagerFactory .\n  This creates and returns an instance of  Zend\\Mvc\\View\\Http\\ViewManager ,\n  which in turn registers and initializes a number of HTTP-specific view\n  services.    HydratorManager , mapping to  Zend\\Mvc\\Service\\HydratorManagerFactory .\n  This creates and returns an instance of  Zend\\Stdlib\\Hydrator\\HydratorPluginManager ,\n  which can be used to manage and persist hydrator instances.    InputFilterManager , mapping to  Zend\\Mvc\\Service\\InputFilterManagerFactory .\n  This creates and returns an instance of  Zend\\InputFilter\\InputFilterPluginManager ,\n  which can be used to manage and persist input filter instances.    ModuleManager , mapping to  Zend\\Mvc\\Service\\ModuleManagerFactory . This is\n  perhaps the most complex factory in the MVC stack. It expects that an\n   ApplicationConfig  service has been injected, with keys for\n   module_listener_options  and  modules ; see the quick start for samples.\n  It creates an instance of  Zend\\ModuleManager\\Listener\\DefaultListenerAggregate ,\n  using the  module_listener_options  retrieved. It then checks if a service\n  with the name  ServiceListener  exists; if not, it sets a factory with that\n  name mapping to  Zend\\Mvc\\Service\\ServiceListenerFactory . A bunch of\n  service listeners will be added to the  ServiceListener , like listeners for\n  the  getServiceConfig ,  getControllerConfig ,  getControllerPluginConfig ,\n  and  getViewHelperConfig  module methods.  Next, it retrieves the\n   EventManager  service, and attaches the above listeners.  It instantiates a\n   Zend\\ModuleManager\\ModuleEvent  instance, setting the \"ServiceManager\"\n  parameter to the service manager object.  Finally, it instantiates a\n   Zend\\ModuleManager\\ModuleManager  instance, and injects the  EventManager \n  and  ModuleEvent .    MvcTranslator , mapping to  Zend\\Mvc\\Service\\TranslatorServiceFactory , and\n  returning an instance of  Zend\\Mvc\\I18n\\Translator , which extends\n   Zend\\I18n\\Translator\\Translator  and implements  Zend\\Validator\\Translator\\TranslatorInterface ,\n  allowing the instance to be used anywhere a translator may be required in\n  the framework.    PaginatorPluginManager , mapping to  Zend\\Mvc\\Service\\PaginatorPluginManagerFactory .\n  This instantiates the  Zend\\Paginator\\AdapterPluginManager  instance,\n  passing it the service manager instance. This is used to manage\n   paginator adapters .\n  It also uses the  DiAbstractServiceFactory  service, effectively allowing\n  you to fall back to DI in order to retrieve paginator adapters.    Request , mapping to  Zend\\Mvc\\Service\\RequestFactory . The factory is used\n  to create and return a request instance, according to the current\n  environment. If the current environment is a console environment, it will\n  create a  Zend\\Console\\Request ; otherwise, for HTTP environments, it\n  creates a  Zend\\Http\\PhpEnvironment\\Request .    Response , mapping to  Zend\\Mvc\\Service\\ResponseFactory . The factory is\n  used to create and return a response instance, according to the current\n  environment. If the current environment is a console environment, it will\n  create a  Zend\\Console\\Response ; otherwise, for HTTP environments, it\n  creates a  Zend\\Http\\PhpEnvironment\\Response .    Router , mapping to  Zend\\Router\\RouterFactory . If in a console\n  environment, it proxies to the  ConsoleRouter  service; otherwise, it proxies\n  to the  HttpRouter  service.    RoutePluginManager , mapping to  Zend\\Mvc\\Service\\RoutePluginManagerFactory .\n  This instantiates the  Zend\\Router\\RoutePluginManager  instance, passing\n  it the service manager instance; this is used to manage  route types .\n  It also uses the  DiAbstractServiceFactory  service, effectively allowing\n  you to fall back to DI in order to retrieve route types.    SerializerAdapterManager , mapping to  Zend\\Mvc\\Service\\SerializerAdapterPluginManagerFactory ,\n  which returns an instance of  Zend\\Serializer\\AdapterPluginManager . This is\n  a plugin manager for managing serializer adapter instances.    ServiceListener , mapping to  Zend\\Mvc\\Service\\ServiceListenerFactory . The\n  factory is used to instantiate the  ServiceListener , while allowing easy\n  extending. It checks if a service with the name  ServiceListenerInterface \n  exists, which must implement  Zend\\ModuleManager\\Listener\\ServiceListenerInterface ,\n  before instantiating the default  ServiceListener .\n  In addition to this, it retrieves the  ApplicationConfig  and looks for the\n   service_listener_options  key. This allows you to register own listeners\n  for module methods and configuration keys to create an own service manager;\n  see the  application configuration options  for samples.    ValidatorManager , mapping to  Zend\\Mvc\\Service\\ValidatorManagerFactory .\n  This instantiates the  Zend\\Validator\\ValidatorPluginManager  instance,\n  passing it the service manager instance. This is used to manage\n   validators .\n  It also uses the  DiAbstractServiceFactory  service, effectively allowing\n  you to fall back to DI in order to retrieve validators.    ViewFeedRenderer , mapping to  Zend\\Mvc\\Service\\ViewFeedRendererFactory ,\n  which returns an instance of  Zend\\View\\Renderer\\FeedRenderer , used to\n  render feeds.    ViewFeedStrategy , mapping to  Zend\\Mvc\\Service\\ViewFeedStrategyFactory ,\n  which returns an instance of  Zend\\View\\Strategy\\FeedStrategy , used to\n  select the  ViewFeedRenderer  given the appropriate criteria.    ViewHelperManager , mapping to  Zend\\Mvc\\Service\\ViewHelperManagerFactory ,\n  which returns an instance of  Zend\\View\\HelperManager . This is a plugin\n  manager for managing view helper instances.    ViewJsonRenderer , mapping to  Zend\\Mvc\\Service\\ViewJsonRendererFactory ,\n  which returns an instance of  Zend\\View\\Renderer\\JsonRenderer , used to\n  render JSON structures.    ViewJsonStrategy , mapping to  Zend\\Mvc\\Service\\ViewJsonStrategyFactory ,\n  which returns an instance of  Zend\\View\\Strategy\\JsonStrategy , used to\n  select the  ViewJsonRenderer  given the appropriate criteria.    ViewManager , mapping to  Zend\\Mvc\\Service\\ViewManagerFactory . The factory\n  is used to create and return a view manager, according to the current\n  environment. If the current environment is a console environment, it will\n  create a  Zend\\Mvc\\View\\Console\\ViewManager ; otherwise, for HTTP\n  environments, it returns a  Zend\\Mvc\\View\\Http\\ViewManager .    ViewResolver , mapping to  Zend\\Mvc\\Service\\ViewResolverFactory , which\n  creates and returns the aggregate view resolver. It also attaches the\n   ViewTemplateMapResolver  and  ViewTemplatePathStack  services to it.    ViewTemplateMapResolver , mapping to  Zend\\Mvc\\Service\\ViewTemplateMapResolverFactory ,\n  which creates, configures and returns the  Zend\\View\\Resolver\\TemplateMapResolver .    ViewTemplatePathStack , mapping to  Zend\\Mvc\\Service\\ViewTemplatePathStackFactory ,\n  which creates, configures and returns the  Zend\\View\\Resolver\\TemplatePathStack .",
            "title": "Factories"
        },
        {
            "location": "/services/#abstract-factories",
            "text": "Zend\\Cache\\Service\\StorageCacheAbstractServiceFactory  (opt-in; registered\n  by default in the skeleton application).  Zend\\Db\\Adapter\\AdapterAbstractServiceFactory  (opt-in).  Zend\\Form\\FormAbstractServiceFactory  is registered by default.  Zend\\Log\\LoggerAbstractServiceFactory  (opt-in; registered by default in the skeleton application).",
            "title": "Abstract factories"
        },
        {
            "location": "/services/#aliases",
            "text": "Configuration , mapping to the  Config  service.  Console , mapping to the  ConsoleAdapter  service.  Di , mapping to the  DependencyInjector  service.  MiddlewareListener , mapping to the  Zend\\Mvc\\MiddlewareListener  service.  Zend\\Di\\LocatorInterface , mapping to the  DependencyInjector  service.  Zend\\EventManager\\EventManagerInterface , mapping to the  EventManager \n  service. This is mainly to ensure that when falling through to DI, classes\n  are still injected via the  ServiceManager .  Zend\\Mvc\\Controller\\PluginManager , mapping to the\n   ControllerPluginManager  service. This is mainly to ensure that when\n  falling through to DI, classes are still injected via the  ServiceManager .  Zend\\View\\Resolver\\TemplateMapResolver , mapping to the\n   ViewTemplateMapResolver  service.  Zend\\View\\Resolver\\TemplatePathStack , mapping to the\n   ViewTemplatePathStack  service.  Zend\\View\\Resolver\\AggregateResolver , mapping to the  ViewResolver  service.  Zend\\View\\Resolver\\ResolverInterface , mapping to the  ViewResolver  service.",
            "title": "Aliases"
        },
        {
            "location": "/services/#initializers",
            "text": "For objects that implement  Zend\\EventManager\\EventManagerAwareInterface ,\n  the  EventManager  service will be retrieved and injected. This service is\n   not  shared, though each instance it creates is injected with a shared\n  instance of  SharedEventManager .    For objects that implement  Zend\\ServiceManager\\ServiceLocatorAwareInterface \n  (or the methods it defines), the  ServiceManager  will inject itself into\n  the object.    The  ServiceManager  registers itself as the  ServiceManager  service, and\n  aliases itself to the class names  Zend\\ServiceManager\\ServiceLocatorInterface \n  and  Zend\\ServiceManager\\ServiceManager .",
            "title": "Initializers"
        },
        {
            "location": "/services/#abstract-factories_1",
            "text": "As noted in the previous section, Zend Framework provides a number of abstract\nservice factories by default. Each is noted below, along with sample\nconfiguration.  In each instance, the abstract factory looks for a top-level configuration key,\nconsisting of key/value pairs where the key is the service name, and the value\nis the configuration to use to create the given service.",
            "title": "Abstract Factories"
        },
        {
            "location": "/services/#zend92cache92service92storagecacheabstractservicefactory",
            "text": "This abstract factory is opt-in, but registered by default in the skeleton application. It uses the\ntop-level configuration key \"caches\".  return [\n    'caches' => [\n        'Cache\\Transient' => [\n            'adapter' => 'redis',\n            'ttl'     => 60,\n            'plugins' => [\n                'exception_handler' => [\n                    'throw_exceptions' => false,\n                ],\n            ],\n        ],\n        'Cache\\Persistence' => [\n            'adapter' => 'filesystem',\n            'ttl'     => 86400,\n        ],\n    ],\n];  See the  cache documentation \nfor more configuration options.",
            "title": "Zend\\Cache\\Service\\StorageCacheAbstractServiceFactory"
        },
        {
            "location": "/services/#zend92db92adapter92adapterabstractservicefactory",
            "text": "This abstract factory is opt-in. It uses the top-level configuration key \"db\",\nwith a subkey \"adapters\".  return [\n    'db' => ['adapters' => [\n        'Db\\ReadOnly' => [\n            'driver'   => 'Pdo_Sqlite',\n            'database' => 'data/db/users.db',\n        ],\n        'Db\\Writeable' => [\n            'driver'   => 'Mysqli',\n            'database' => 'users',\n            'username' => 'developer',\n            'password' => 'developer_password',\n        ],\n    ]],\n];  See the  DB adapter documentation \nfor more configuration options.",
            "title": "Zend\\Db\\Adapter\\AdapterAbstractServiceFactory"
        },
        {
            "location": "/services/#zend92form92formabstractservicefactory",
            "text": "This abstract factory is registered by default. It uses the top-level\nconfiguration key \"forms\". It makes use of the  FilterManager , FormElementManager ,  HydratorManager ,  InputFilterManager , and ValidatorManager  plugin managers in order to allow instantiation and creation\nof form objects and all related objects in the form hierarchy.  return [\n    'forms' => [\n        'Form\\Foo' => [\n            'hydrator' => 'ObjectProperty',\n            'type'     => 'Zend\\Form\\Form',\n            'elements' => [\n                [\n                    'spec' => [\n                        'type' => 'Zend\\Form\\Element\\Email',\n                        'name' => 'email',\n                        'options' => [\n                            'label' => 'Your email address',\n                        ],\n                    ],\n                ],\n            ],\n        ],\n    ],\n];  Form configuration follows the same configuration you would use with a form\nfactory; the primary difference is that all plugin managers have already been\ninjected for you, allowing you the possibility of custom objects or\nsubstitutions.  See the  form factory documentation \nfor more configuration options.",
            "title": "Zend\\Form\\FormAbstractServiceFactory"
        },
        {
            "location": "/services/#zend92log92loggerabstractservicefactory",
            "text": "This abstract factory is opt-in, but registered by default in the skeleton\napplication. It uses the top-level configuration key \"log\".  return [\n    'log' => [\n        'Log\\App' => [\n            'writers' => [\n                [\n                    'name' => 'stream',\n                    'priority' => 1000,\n                    'options' => [\n                        'stream' => 'data/logs/app.log',\n                    ],\n                ],\n            ],\n        ],\n    ],\n];  See the  log documentation \nfor more configuration options.",
            "title": "Zend\\Log\\LoggerAbstractServiceFactory"
        },
        {
            "location": "/services/#plugin-managers",
            "text": "The following plugin managers are configured by default:   ControllerManager , corresponding to  Zend\\Mvc\\Controller\\ControllerManager ,\n  and used to manage controller instances.  ControllerPluginManager , corresponding to  Zend\\Mvc\\Controller\\PluginManager ,\n  and used to manage controller plugin instances.  FilterManager , corresponding to  Zend\\Filter\\FilterPluginManager , and\n  used to manage filter instances.  FormElementManager , corresponding to  Zend\\Form\\FormElementManager , and\n  used to manage instances of form elements and fieldsets.  HydratorManager , corresponding to  Zend\\Stdlib\\Hydrator\\HydratorPluginManager ,\n  and used to manage hydrator instances.  InputFilterManager , corresponding to  Zend\\InputFilter\\InputFilterPluginManager ,\n  and used to manage input filter instances.  RoutePluginManager , corresponding to  Zend\\Router\\RoutePluginManager ,\n  and used to manage route instances.  SerializerAdapterManager , corresponding to  Zend\\Serializer\\AdapterPluginManager ,\n  and used to manage serializer instances.  ValidatorManager , corresponding to  Zend\\Validator\\ValidatorPluginManager ,\n  and used to manage validator instances.  ViewHelperManager , corresponding to  Zend\\View\\HelperPluginManager , and\n  used to manage view helper instances.   As noted in the previous section, all plugin managers share the same\nconfiguration and service types as the standard service manager; they are simply\nscoped, and only allow instances of certain types to be created or registered.\nDefault types available are listed in the documentation for each component.",
            "title": "Plugin Managers"
        },
        {
            "location": "/services/#viewmanager",
            "text": "The View layer within zend-mvc consists of a large number of collaborators and\nevent listeners. As such,  Zend\\Mvc\\View\\ViewManager  was created to handle\ncreation of the various objects, as well as wiring them together and\nestablishing event listeners.  The  ViewManager  itself is an event listener on the  bootstrap  event. It\nretrieves the  ServiceManager  from the  Application  object, as well as its\ncomposed  EventManager .  Configuration for all members of the  ViewManager  fall under the  view_manager \nconfiguration key, and expect values as noted below. The following services are\ncreated and managed by the  ViewManager :    ViewHelperManager , representing and aliased to  Zend\\View\\HelperPluginManager .\n  It is seeded with the  ServiceManager . Created via the\n   Zend\\Mvc\\Service\\ViewHelperManagerFactory .    The  Router  service is retrieved, and injected into the  Url  helper.    If the  base_path  key is present, it is used to inject the  BasePath  view\n  helper; otherwise, the  Request  service is retrieved, and the value of its\n   getBasePath()  method is used.    If the  base_path_console  key is present, it is used to inject the\n   BasePath  view helper for console requests; otherwise, the  Request \n  service is retrieved, and the value of its  getBasePath()  method is used.\n  This can be useful for sending urls in emails via a cronjob.    If the  doctype  key is present, it will be used to set the value of the\n   Doctype  view helper.      ViewTemplateMapResolver , representing and aliased to\n   Zend\\View\\Resolver\\TemplateMapResolver .  If a  template_map  key is present,\n  it will be used to seed the template map.    ViewTemplatePathStack , representing and aliased to\n   Zend\\View\\Resolver\\TemplatePathStack .    If a  template_path_stack  key is present, it will be used to seed the\n  stack.    If a  default_template_suffix  key is present, it will be used as the\n  default suffix for template scripts resolving.      ViewResolver , representing and aliased to  Zend\\View\\Resolver\\AggregateResolver \n  and  Zend\\View\\Resolver\\ResolverInterface . It is seeded with the\n   ViewTemplateMapResolver  and  ViewTemplatePathStack  services as resolvers.    ViewRenderer , representing and aliased to  Zend\\View\\Renderer\\PhpRenderer \n  and  Zend\\View\\Renderer\\RendererInterface . It is seeded with the\n   ViewResolver  and  ViewHelperManager  services. Additionally, the  ViewModel \n  helper gets seeded with the  ViewModel  as its root (layout) model.    ViewPhpRendererStrategy , representing and aliased to\n   Zend\\View\\Strategy\\PhpRendererStrategy . It gets seeded with the\n   ViewRenderer  service.    View , representing and aliased to  Zend\\View\\View . It gets seeded with the\n   EventManager  service, and attaches the  ViewPhpRendererStrategy  as an\n  aggregate listener.    DefaultRenderingStrategy , representing and aliased to\n   Zend\\Mvc\\View\\DefaultRenderingStrategy .  If the  layout  key is present, it\n  is used to seed the strategy's layout template. It is seeded with the  View \n  service.    ExceptionStrategy , representing and aliased to  Zend\\Mvc\\View\\ExceptionStrategy .\n  If the  display_exceptions  or  exception_template  keys are present, they are\n  used to configure the strategy.    RouteNotFoundStrategy , representing and aliased to  Zend\\Mvc\\View\\RouteNotFoundStrategy \n  and  404Strategy . If the  display_not_found_reason  or  not_found_template \n  keys are present, they are used to configure the strategy.    ViewModel . In this case, no service is registered; the  ViewModel  is\n  retrieved from the  MvcEvent  and injected with the layout template name.    The  ViewManager  also creates several other listeners, but does not expose them\nas services; these include  Zend\\Mvc\\View\\CreateViewModelListener , Zend\\Mvc\\View\\InjectTemplateListener , and  Zend\\Mvc\\View\\InjectViewModelListener .\nThese, along with  RouteNotFoundStrategy ,  ExceptionStrategy , and DefaultRenderingStrategy  are attached as listeners either to the application EventManager  instance or the  SharedEventManager  instance.  Finally, if you have a  strategies  key in your configuration, the  ViewManager \nwill loop over these and attach them in order to the  View  service as\nlisteners, at a priority of 100 (allowing them to execute before the DefaultRenderingStrategy ).",
            "title": "ViewManager"
        },
        {
            "location": "/services/#application-configuration-options",
            "text": "The following options may be used to provide initial configuration for the ServiceManager ,  ModuleManager , and  Application  instances, allowing them to\nthen find and aggregate the configuration used for the  Config  service, which\nis intended for configuring all other objects in the system. These configuration\ndirectives go to the  config/application.config.php  file.  <?php\nreturn [\n    // This should be an array of module namespaces used in the application.\n    'modules' => [\n    ],\n\n    // These are various options for the listeners attached to the ModuleManager\n    'module_listener_options' => [\n        // This should be an array of paths in which modules reside.\n        // If a string key is provided, the listener will consider that a module\n        // namespace, the value of that key the specific path to that module's\n        // Module class.\n        'module_paths' => [\n        ],\n\n        // An array of paths from which to glob configuration files after\n        // modules are loaded. These effectively override configuration\n        // provided by modules themselves. Paths may use GLOB_BRACE notation.\n        'config_glob_paths' => [\n        ],\n\n        // Whether or not to enable a configuration cache.\n        // If enabled, the merged configuration will be cached and used in\n        // subsequent requests.\n        'config_cache_enabled' => $booleanValue,\n\n        // The key used to create the configuration cache file name.\n        'config_cache_key' => $stringKey,\n\n        // Whether or not to enable a module class map cache.\n        // If enabled, creates a module class map cache which will be used\n        // by in future requests, to reduce the autoloading process.\n        'module_map_cache_enabled' => $booleanValue,\n\n        // The key used to create the class map cache file name.\n        'module_map_cache_key' => $stringKey,\n\n        // The path in which to cache merged configuration.\n        'cache_dir' => $stringPath,\n\n        // Whether or not to enable modules dependency checking.\n        // Enabled by default, prevents usage of modules that depend on other modules\n        // that weren't loaded.\n        'check_dependencies' => $booleanValue,\n    ],\n\n    // Used to create an own service manager. May contain one or more child arrays.\n    'service_listener_options' => [\n       [\n         'service_manager' => $stringServiceManagerName,\n         'config_key'      => $stringConfigKey,\n         'interface'       => $stringOptionalInterface,\n         'method'          => $stringRequiredMethodName,\n       ],\n    ]\n\n    // Initial configuration with which to seed the ServiceManager.\n    // Should be compatible with Zend\\ServiceManager\\Config.\n    'service_manager' => [\n    ],\n];  For an example, see the ZendSkeletonApplication configuration file .",
            "title": "Application Configuration Options"
        },
        {
            "location": "/services/#default-configuration-options",
            "text": "The following options are available when using the default services configured\nby the  ServiceManagerConfig  and  ViewManager .  These configuration directives can go to the  config/autoload/{{,*.}global,{,*.}local}.php \nfiles, or in the  module/<module name>/config/module.config.php  configuration\nfiles. The merging of these configuration files is done by the  ModuleManager .\nIt first merges each module's  module.config.php  file, and then the files in config/autoload  (first the  *.global.php  and then the  *.local.php  files).\nThe order of the merge is relevant so you can override a module's configuration\nwith your application configuration. If you have both a  config/autoload/my.global.config.php \nand  config/autoload/my.local.config.php , the local configuration file\noverrides the global configuration.",
            "title": "Default Configuration Options"
        },
        {
            "location": "/services/#do-not-commit-local-configuration",
            "text": "Local configuration files are intended to keep sensitive information, such as\ndatabase credentials, and as such, it is highly recommended to keep these\nlocal configuration files out of your VCS. The  ZendSkeletonApplication 's config/autoload/.gitignore  file ignores  *.local.php  files by default.   <?php\nreturn [\n    // The following are used to configure controller loader\n    // Should be compatible with Zend\\ServiceManager\\Config.\n    'controllers' => [\n        // Map of controller \"name\" to class\n        // This should be used if you do not need to inject any dependencies\n        // in your controller\n        'invokables' => [\n        ],\n\n        // Map of controller \"name\" to factory for creating controller instance\n        // You may provide either the class name of a factory, or a PHP callback.\n        'factories' => [\n        ],\n    ],\n\n    // The following are used to configure controller plugin loader\n    // Should be compatible with Zend\\ServiceManager\\Config.\n    'controller_plugins' => [\n    ],\n\n    // The following are used to configure view helper manager\n    // Should be compatible with Zend\\ServiceManager\\Config.\n    'view_helpers' => [\n    ],\n\n    // The following is used to configure a Zend\\Di\\Di instance.\n    // The array should be in a format that Zend\\Di\\Config can understand.\n    'di' => [\n    ],\n\n    // Configuration for the Router service\n    // Can contain any router configuration, but typically will always define\n    // the routes for the application. See the router documentation for details\n    // on route configuration.\n    'router' => [\n        'routes' => [\n        ],\n    ],\n\n    // ViewManager configuration\n    'view_manager' => [\n        // Base URL path to the application\n        'base_path' => $stringBasePath,\n\n        // Doctype with which to seed the Doctype helper\n        'doctype' => $doctypeHelperConstantString, // e.g. HTML5, XHTML1\n\n        // TemplateMapResolver configuration\n        // template/path pairs\n        'template_map' => [\n        ],\n\n        // TemplatePathStack configuration\n        // module/view script path pairs\n        'template_path_stack' => [\n        ],\n        // Default suffix to use when resolving template scripts, if none, 'phtml' is used\n        'default_template_suffix' => $templateSuffix, // e.g. 'php'\n\n        // Controller namespace to template map\n        'controller_map' => [\n        ],\n\n        // Layout template name\n        'layout' => $layoutTemplateName, // e.g. 'layout/layout'\n\n        // ExceptionStrategy configuration\n        'display_exceptions' => $bool, // display exceptions in template\n        'exception_template' => $stringTemplateName, // e.g. 'error'\n\n        // RouteNotFoundStrategy configuration\n        'display_not_found_reason' => $bool, // display 404 reason in template\n        'not_found_template' => $stringTemplateName, // e.g. '404'\n\n        // Additional strategies to attach\n        // These should be class names or service names of View strategy classes\n        // that act as ListenerAggregates. They will be attached at priority 100,\n        // in the order registered.\n        'strategies' => [\n            'ViewJsonStrategy', // register JSON renderer strategy\n            'ViewFeedStrategy', // register Feed renderer strategy\n        ],\n    ],\n];  For an example, see the Application module configuration file \nin the ZendSkeletonApplication.",
            "title": "Do not commit local configuration"
        },
        {
            "location": "/routing/",
            "text": "Routing\n\n\nRouting is the act of matching a request to a given controller.\n\n\nTypically, routing will examine the request URI, and attempt to match the URI\npath segment against provided constraints. If the constraints match, a set of\n\"matches\" are returned, one of which should be the controller name to execute.\nRouting can utilize other portions of the request URI or environment as well.\nFor example, the host or scheme, query parameters, headers, request method, and\nmore.\n\n\nThe base unit of routing is a \nRoute\n:\n\n\nnamespace Zend\\Router;\n\nuse Zend\\Stdlib\\RequestInterface as Request;\n\ninterface RouteInterface\n{\n    public static function factory(array $options = []);\n    public function match(Request $request);\n    public function assemble(array $params = [], array $options = []);\n}\n\n\n\nA \nRoute\n accepts a \nRequest\n, and determines if it matches. If so, it returns a\n\nRouteMatch\n object:\n\n\nnamespace Zend\\Router;\n\nclass RouteMatch\n{\n    public function __construct(array $params);\n    public function setMatchedRouteName($name);\n    public function getMatchedRouteName();\n    public function setParam($name, $value);\n    public function getParams();\n    public function getParam($name, $default = null);\n}\n\n\n\nTypically, when a \nRoute\n matches, it will define one or more parameters. These\nare passed into the \nRouteMatch\n, and objects may query the \nRouteMatch\n for\ntheir values.\n\n\n$id = $routeMatch->getParam('id', false);\nif (! $id) {\n    throw new Exception('Required identifier is missing!');\n}\n$entity = $resource->get($id);\n\n\n\nUsually you will have multiple routes you wish to test against. In order to\nfacilitate this, you will use a route aggregate, usually implementing\n\nRouteStack\n:\n\n\nnamespace Zend\\Router;\n\ninterface RouteStackInterface extends RouteInterface\n{\n    public function addRoute($name, $route, $priority = null);\n    public function addRoutes(array $routes);\n    public function removeRoute($name);\n    public function setRoutes(array $routes);\n}\n\n\n\nRoutes will be queried in a LIFO order, and hence the reason behind the name\n\nRouteStack\n. zend-mvc provides two implementations of this interface,\n\nSimpleRouteStack\n and \nTreeRouteStack\n. In each, you register routes either one\nat a time using \naddRoute()\n, or in bulk using \naddRoutes()\n.\n\n\n// One at a time:\n$route = Literal::factory([\n    'route' => '/foo',\n    'defaults' => [\n        'controller' => 'foo-index',\n        'action'     => 'index',\n    ],\n]);\n$router->addRoute('foo', $route);\n\n// In bulk:\n$router->addRoutes([\n    // using already instantiated routes:\n    'foo' => $route,\n\n    // providing configuration to allow lazy-loading routes:\n    'bar' => [\n        'type' => 'literal',\n        'options' => [\n            'route' => '/bar',\n            'defaults' => [\n                'controller' => 'bar-index',\n                'action'     => 'index',\n            ],\n        ],\n    ],\n]);\n\n\n\nRouter Types\n\n\nTwo routers are provided, the \nSimpleRouteStack\n and \nTreeRouteStack\n. Each\nworks with the above interface, but utilize slightly different options and\nexecution paths. By default, the zend-mvc uses the \nTreeRouteStack\n as the\nrouter.\n\n\nSimpleRouteStack\n\n\nThis router takes individual routes that provide their full matching logic in\none go, and loops through them in LIFO order until a match is found. As such,\nroutes that will match most often should be registered last, and least common\nroutes first. Additionally, you will need to ensure that routes that potentially\noverlap are registered such that the most specific match will match first (i.e.,\nregister later). Alternatively, you can set priorities by giving the priority as\nthird parameter to the \naddRoute()\n method, specifying the priority in the route\nspecifications or setting the priority property within a route instance before\nadding it to the route stack.\n\n\nTreeRouteStack\n\n\nZend\\Router\\Http\\TreeRouteStack\n provides the ability to register trees of\nroutes, and uses a B-tree algorithm to match routes. As such, you register a\nsingle route with many children.\n\n\nA \nTreeRouteStack\n will consist of the following configuration:\n\n\n\n\nA base \"route\", which describes the base match needed, the root of the tree.\n\n\nAn optional \nroute_plugins\n, which is a configured\n  \nZend\\Router\\RoutePluginManager\n that can lazy-load routes.\n\n\nThe option \nmay_terminate\n, which hints to the router that no other segments\n  will follow it.\n\n\nAn optional \nchild_routes\n array, which contains additional routes that stem\n  from the base \"route\" (i.e., build from it). Each child route can itself be a\n  \nTreeRouteStack\n if desired; in fact, the \nPart\n route works exactly this way.\n\n\n\n\nWhen a route matches against a \nTreeRouteStack\n, the matched parameters from\neach segment of the tree will be returned.\n\n\nA \nTreeRouteStack\n can be your sole route for your application, or describe\nparticular path segments of the application.\n\n\nAn example of a \nTreeRouteStack\n is provided in the documentation of the \nPart\n\nroute.\n\n\nHTTP Route Types\n\n\nzend-mvc ships with the following HTTP route types.\n\n\nZend\\Router\\Http\\Hostname\n\n\nThe \nHostname\n route attempts to match the hostname registered in the request\nagainst specific criteria. Typically, this will be in one of the following\nforms:\n\n\n\n\nsubdomain.domain.tld\n\n\n:subdomain.domain.tld\n\n\n\n\nIn the above, the second route would return a \"subdomain\" key as part of the\nroute match.\n\n\nFor any given hostname segment, you may also provide a constraint. As an\nexample, if the \"subdomain\" segment needed to match only if it started with \"fw\"\nand contained exactly 2 digits following, the following route would be needed:\n\n\n$route = Hostname::factory([\n    'route' => ':subdomain.domain.tld',\n    'constraints' => [\n        'subdomain' => 'fw\\d{2}',\n    ],\n]);\n\n\n\nIn the above example, only a \"subdomain\" key will be returned in the\n\nRouteMatch\n. If you wanted to also provide other information based on matching,\nor a default value to return for the subdomain, you need to also provide\ndefaults.\n\n\n$route = Hostname::factory([\n    'route' => ':subdomain.domain.tld',\n    'constraints' => [\n        'subdomain' => 'fw\\d{2}',\n    ],\n    'defaults' => [\n        'type' => 'json',\n    ],\n]);\n\n\n\nWhen matched, the above will return two keys in the \nRouteMatch\n, \"subdomain\"\nand \"type\".\n\n\nZend\\Router\\Http\\Literal\n\n\nThe \nLiteral\n route is for doing exact matching of the URI path. Configuration\ntherefore is solely the path you want to match, and the \"defaults\", or\nparameters you want returned on a match.\n\n\n$route = Literal::factory([\n    'route' => '/foo',\n    'defaults' => [\n        'controller' => 'Application\\Controller\\IndexController',\n        'action' => 'foo',\n    ],\n]);\n\n\n\nThe above route would match a path \"/foo\", and return the key \"action\" in the\n\nRouteMatch\n, with the value \"foo\".\n\n\nZend\\Router\\Http\\Method\n\n\nThe \nMethod\n route is used to match the HTTP method or 'verb' specified in the\nrequest (See RFC 2616 Sec. 5.1.1). It can optionally be configured to match\nagainst multiple methods by providing a comma-separated list of method tokens.\n\n\n$route = Method::factory([\n    'verb' => 'post,put',\n    'defaults' => [\n        'controller' => 'Application\\Controller\\IndexController',\n        'action' => 'form-submit',\n    ],\n]);\n\n\n\nThe above route would match an http \"POST\" or \"PUT\" request and return a\n\nRouteMatch\n object containing a key \"action\" with a value of \"form-submit\".\n\n\nZend\\Router\\Http\\Part\n\n\nA \nPart\n route allows crafting a tree of possible routes based on segments of\nthe URI path. It actually extends the \nTreeRouteStack\n.\n\n\nPart\n routes are difficult to describe, so we'll simply provide a sample one\nhere.\n\n\n$route = Part::factory([\n    'route' => [\n        'type' => 'literal',\n        'options' => [\n            'route' => '/',\n            'defaults' => [\n                'controller' => 'Application\\Controller\\IndexController',\n                'action' => 'index',\n            ],\n        ],\n    ],\n    'route_plugins' => $routePlugins,\n    'may_terminate' => true,\n    'child_routes' => [\n        'blog' => [\n            'type' => 'literal',\n            'options' => [\n                'route' => '/blog',\n                'defaults' => [\n                    'controller' => 'Application\\Controller\\BlogController',\n                    'action' => 'index',\n                ],\n            ],\n            'may_terminate' => true,\n            'child_routes' => [\n                'rss' => [\n                    'type' => 'literal',\n                    'options' => [\n                        'route' => '/rss',\n                        'defaults' => [\n                            'action' => 'rss',\n                        ]\n                    ],\n                    'may_terminate' => true,\n                    'child_routes' => [\n                        'subrss' => [\n                            'type' => 'literal',\n                            'options' => [\n                                'route' => '/sub',\n                                'defaults' => [\n                                    'action' => 'subrss',\n                                ],\n                            ],\n                        ],\n                    ],\n                ],\n            ],\n        ],\n        'forum' => [\n            'type' => 'literal',\n            'options' => [\n                'route' => 'forum',\n                'defaults' => [\n                    'controller' => 'Application\\Controller\\ForumController',\n                    'action' => 'index',\n                ],\n            ],\n        ],\n    ],\n]);\n\n\n\nThe above would match the following:\n\n\n\n\n/\n would load the \"Index\" controller, \"index\" action.\n\n\n/blog\n would load the \"Blog\" controller, \"index\" action.\n\n\n/blog/rss\n would load the \"Blog\" controller, \"rss\" action.\n\n\n/blog/rss/sub\n would load the \"Blog\" controller, \"subrss\" action.\n\n\n/forum\n would load the \"Forum\" controller, \"index\" action.\n\n\n\n\nYou may use any route type as a child route of a \nPart\n route.\n\n\n\n\nPart routes are an implementation detail\n\n\nPart\n routes are not meant to be used directly. When you add definitions for\n\nchild_routes\n to any route type, that route will become a \nPart\n route. As\nalready said, describing \nPart\n routes with words is difficult, so hopefully\nthe additional \nexamples at the end\n will provide\nfurther insight.\n\n\nRoute plugins\n\n\nIn the above example, the \n$routePlugins\n is an instance of\n\nZend\\Router\\RoutePluginManager\n, containing essentially the following\nconfiguration:\n\n\n$routePlugins = new Zend\\Router\\RoutePluginManager();\n$plugins = [\n    'hostname' => 'Zend\\Router\\Http\\Hostname',\n    'literal'  => 'Zend\\Router\\Http\\Literal',\n    'part'     => 'Zend\\Router\\Http\\Part',\n    'regex'    => 'Zend\\Router\\Http\\Regex',\n    'scheme'   => 'Zend\\Router\\Http\\Scheme',\n    'segment'  => 'Zend\\Router\\Http\\Segment',\n    'wildcard' => 'Zend\\Router\\Http\\Wildcard',\n    'query'    => 'Zend\\Router\\Http\\Query',\n    'method'   => 'Zend\\Router\\Http\\Method',\n];\nforeach ($plugins as $name => $class) {\n    $routePlugins->setInvokableClass($name, $class);\n}\n\n\n\nWhen using \nZend\\Router\\Http\\TreeRouteStack\n, the \nRoutePluginManager\n is\nset up by default, and the developer does not need to worry about autoloading\nof standard HTTP routes.\n\n\n\n\nZend\\Router\\Http\\Regex\n\n\nA \nRegex\n route utilizes a regular expression to match against the URI path. Any\nvalid regular expression is allowed; our recommendation is to use named captures\nfor any values you want to return in the \nRouteMatch\n.\n\n\nSince regular expression routes are often complex, you must specify a \"spec\" or\nspecification to use when assembling URLs from regex routes. The spec is simply\na string; replacements are identified using \n%keyname%\n within the string, with\nthe keys coming from either the captured values or named parameters passed to\nthe \nassemble()\n method.\n\n\nJust like other routes, the \nRegex\n route can accept \"defaults\", parameters to\ninclude in the \nRouteMatch\n when successfully matched.\n\n\n$route = Regex::factory([\n    'regex' => '/blog/(?<id>[a-zA-Z0-9_-]+)(\\.(?<format>(json|html|xml|rss)))?',\n    'defaults' => [\n        'controller' => 'Application\\Controller\\BlogController',\n        'action'     => 'view',\n        'format'     => 'html',\n    ],\n    'spec' => '/blog/%id%.%format%',\n]);\n\n\n\nThe above would match \n/blog/001-some-blog_slug-here.html\n, and return four\nitems in the \nRouteMatch\n, an \"id\", the \"controller\", the \"action\", and the\n\"format\". When assembling a URL from this route, the \"id\" and \"format\" values\nwould be used to fill the specification.\n\n\nZend\\Router\\Http\\Scheme\n\n\nThe \nScheme\n route matches the URI scheme only, and must be an exact match. As\nsuch, this route, like the \nLiteral\n route, simply takes what you want to match\nand the \"defaults\", parameters to return on a match.\n\n\n$route = Scheme::factory([\n    'scheme' => 'https',\n    'defaults' => [\n        'https' => true,\n    ],\n]);\n\n\n\nThe above route would match the \"https\" scheme, and return the key \"https\" in\nthe \nRouteMatch\n with a boolean \ntrue\n value.\n\n\nZend\\Router\\Http\\Segment\n\n\nA \nSegment\n route allows matching any segment of a URI path. Segments are\ndenoted using a colon, followed by alphanumeric characters; if a segment is\noptional, it should be surrounded by brackets.  As an example, \n/:foo[/:bar]\n\nwould match a \n/\n followed by text and assign it to the key \"foo\"; if any\nadditional \n/\n characters are found, any text following the last one will be\nassigned to the key \"bar\".\n\n\nThe separation between literal and named segments can be anything. For example,\nthe above could be done as \n/:foo{-}[-:bar]\n as well. The \n{-}\n after the \n:foo\n\nparameter indicates a set of one or more delimiters, after which matching of the\nparameter itself ends.\n\n\nEach segment may have constraints associated with it. Each constraint should\nsimply be a regular expression expressing the conditions under which that\nsegment should match.\n\n\nAlso, as you can in other routes, you may provide defaults to use; these are\nparticularly useful when using optional segments.\n\n\nAs a complex example:\n\n\n$route = Segment::factory([\n    'route' => '/:controller[/:action]',\n    'constraints' => [\n        'controller' => '[a-zA-Z][a-zA-Z0-9_-]+',\n        'action'     => '[a-zA-Z][a-zA-Z0-9_-]+',\n    ],\n    'defaults' => [\n        'controller' => 'Application\\Controller\\IndexController',\n        'action'     => 'index',\n    ],\n]);\n\n\n\nZend\\Router\\Http\\Query (Deprecated)\n\n\n\n\nPotential security issue\n\n\nMisuse of this route can lead to potential security issues.\n\n\nDeprecated\n\n\nThis route part is deprecated since you can now add query parameters without a\nquery route. It was removed in version 3 of the router.\n\n\n\n\nThe \nQuery\n route part allows you to specify and capture query string parameters\nfor a given route.\n\n\nThe intention of the \nQuery\n part is that you do not instantiate it in its own\nright, but use it as a child of another route part.\n\n\nAn example of its usage would be:\n\n\n$route = Part::factory([\n    'route' => [\n        'type'    => 'literal',\n        'options' => [\n            'route'    => 'page',\n            'defaults' => [],\n        ],\n    ],\n    'may_terminate' => true,\n    'route_plugins' => $routePlugins,\n    'child_routes'  => [\n        'query' => [\n            'type' => 'Query',\n            'options' => [\n                'defaults' => [\n                    'foo' => 'bar',\n                ],\n            ],\n        ],\n    ],\n]);\n\n\n\nThis then allows you to create query strings using the url view helper.\n\n\n$this->url(\n    'page/query',\n    [\n        'name'   => 'my-test-page',\n        'format' => 'rss',\n        'limit'  => 10,\n    ]\n);\n\n\n\nPer the above example, you must add \n/query\n (the name we gave to our query\nroute segment) to your route name in order to append a query string. If you do\nnot specify \n/query\n in the route name, then no query string will be appended.\n\n\nOur example \"page\" route has only one defined parameter of \"name\"\n(\n/page[/:name]\n), meaning that the remaining parameters of \"format\" and \"limit\"\nwill then be appended as a query string.\n\n\nThe output from our example should then be\n\n/page/my-test-page?format=rss&limit=10\n\n\nZend\\Router\\Http\\Wildcard (Deprecated)\n\n\n\n\nPotential security issue\n\n\nMisuse of this route type can lead to potential security issues.\n\n\nDeprecated\n\n\nThis route type is deprecated. Use the \nSegment\n route type.\n\n\n\n\nThe \nWildcard\n route type matches all remaining segments of a URI path.\n\n\nHTTP Routing Examples\n\n\nMost of the routing definitions will be done in module configuration files, so\nthe following examples will show how to set up routes in config files.\n\n\nSimple example with two literal routes\n\n\nreturn [\n    'router' => [\n        'routes' => [\n            // Literal route named \"home\"\n            'home' => [\n                'type' => 'literal',\n                'options' => [\n                    'route' => '/',\n                    'defaults' => [\n                        'controller' => 'Application\\Controller\\IndexController',\n                        'action' => 'index',\n                    ],\n                ],\n            ],\n            // Literal route named \"contact\"\n            'contact' => [\n                'type' => 'literal',\n                'options' => [\n                    'route' => 'contact',\n                    'defaults' => [\n                        'controller' => 'Application\\Controller\\ContactController',\n                        'action' => 'form',\n                    ],\n                ],\n            ],\n        ],\n    ],\n];\n\n\n\nA complex example with child routes\n\n\nreturn [\n    'router' => [\n        'routes' => [\n            // Literal route named \"home\"\n            'home' => [\n                'type' => 'literal',\n                'options' => [\n                    'route' => '/',\n                    'defaults' => [\n                        'controller' => 'Application\\Controller\\IndexController',\n                        'action' => 'index',\n                    ],\n                ],\n            ],\n            // Literal route named \"blog\", with child routes\n            'blog' => [\n                'type' => 'literal',\n                'options' => [\n                    'route' => '/blog',\n                    'defaults' => [\n                        'controller' => 'Application\\Controller\\BlogController',\n                        'action' => 'index',\n                    ],\n                ],\n                'may_terminate' => true,\n                'child_routes' => [\n                    // Segment route for viewing one blog post\n                    'post' => [\n                        'type' => 'segment',\n                        'options' => [\n                            'route' => '/[:slug]',\n                            'constraints' => [\n                                'slug' => '[a-zA-Z0-9_-]+',\n                            ],\n                            'defaults' => [\n                                'action' => 'view',\n                            ],\n                        ],\n                    ],\n                    // Literal route for viewing blog RSS feed\n                    'rss' => [\n                        'type' => 'literal',\n                        'options' => [\n                            'route' => '/rss',\n                            'defaults' => [\n                                'action' => 'rss',\n                            ],\n                        ],\n                    ],\n                ],\n            ],\n        ],\n    ],\n];\n\n\n\nWhen using child routes, naming of the routes follows the \nparent/child\n\npattern, so to use the child routes from the above example:\n\n\necho $this->url('blog'); // gives \"/blog\"\necho $this->url('blog/post', ['slug' => 'my-post']); // gives \"/blog/my-post\"\necho $this->url('blog/rss'); // gives \"/blog/rss\"\n\n\n\nAn example with multiple Hostnames and subdomains within a single application\n\n\nreturn [\n    'router' => [\n        'routes' => [\n            'modules.zendframework.com' => [\n                'type' => 'Zend\\Router\\Http\\Hostname',\n                'options' => [\n                    'route' => ':4th.[:3rd.]:2nd.:1st', // domain levels from right to left\n                    'constraints' => [\n                        '4th' => 'modules',\n                        '3rd' => '.*?', // optional 3rd level domain such as .ci, .dev or .test\n                        '2nd' => 'zendframework',\n                        '1st' => 'com',\n                    ],\n                    // Purposely omit default controller and action\n                    // to let the child routes control the route match\n                ],\n                // child route controllers may span multiple modules as desired\n                'child_routes' => [\n                    'index' => [\n                        'type' => 'Zend\\Router\\Http\\Literal',\n                        'options' => [\n                            'route' => '/',\n                            'defaults' => [\n                                'controller' => 'Module\\Controller\\Index',\n                                'action' = > 'index',\n                            ],\n                        ],\n                        'may_terminate' => true,\n                    ],\n                ],\n            ],\n            'packages.zendframework.com' => [\n                'type' => 'Zend\\Router\\Http\\Hostname',\n                'options' => [\n                    'route' => ':4th.[:3rd.]:2nd.:1st', // domain levels from right to left\n                    'constraints' => [\n                        '4th' => 'packages',\n                        '3rd' => '.*?', // optional 3rd level domain such as .ci, .dev or .test\n                        '2nd' => 'zendframework',\n                        '1st' => 'com',\n                    ],\n                    // Purposely omit default controller and action\n                    // to let the child routes control the route match\n                ],\n                // child route controllers may span multiple modules as desired\n                'child_routes' => [\n                    'index' => [\n                        'type' => 'Zend\\Router\\Http\\Literal',\n                        'options' => [\n                            'route' => '/',\n                            'defaults' => [\n                                'controller' => 'Package\\Controller\\Index',\n                                'action' = > 'index',\n                            ],\n                        ],\n                        'may_terminate' => true,\n                    ],\n                ],\n            ],\n        ],\n    ],\n];\n\n\n\nThe above would match the following:\n\n\n\n\nmodules.zendframework.com\n would dispatch the \nIndex\n controller's \nindex\n\n  action of the \nModule\n module.\n\n\nmodules.ci.zendframework.com\n would dispatch the \nIndex\n controller's \nindex\n\n  action of the \nModule\n module.\n\n\npackages.zendframework.com\n would dispatch the \nIndex\n controller's \nindex\n\n  action of the \nPackage\n module.\n\n\npackages.dev.zendframework.com\n would dispatch the \nIndex\n controller's\n  \nindex\n action of the \nPackage\n module.\n\n\n\n\nThe \nUrl\n controller plugin or view helper may be used to generate URLs\nfollowing the above example:\n\n\n// reuse the route matched parameters to generate URLs\necho $this->url('modules.zendframework.com/index', [], [], true);\necho $this->url('packages.zendframework.com/index', [], [], true);\n\n\n\n\n\nmay_terminate and child_routes placement\n\n\nWhen defining child routes pay attention that the \nmay_terminate\n and\n\nchild_routes\n definitions are in same level as the \noptions\n and \ntype\n\ndefinitions. A common pitfall is to have those two definitions nested in\n\noptions\n, which will not result in the desired routes.\n\n\n\n\nConsole Route Types\n\n\nzend-mvc also allows routing Console based applications; console routes are\nexplained in the \nzend-console routing documentation\n.",
            "title": "Routing"
        },
        {
            "location": "/routing/#routing",
            "text": "Routing is the act of matching a request to a given controller.  Typically, routing will examine the request URI, and attempt to match the URI\npath segment against provided constraints. If the constraints match, a set of\n\"matches\" are returned, one of which should be the controller name to execute.\nRouting can utilize other portions of the request URI or environment as well.\nFor example, the host or scheme, query parameters, headers, request method, and\nmore.  The base unit of routing is a  Route :  namespace Zend\\Router;\n\nuse Zend\\Stdlib\\RequestInterface as Request;\n\ninterface RouteInterface\n{\n    public static function factory(array $options = []);\n    public function match(Request $request);\n    public function assemble(array $params = [], array $options = []);\n}  A  Route  accepts a  Request , and determines if it matches. If so, it returns a RouteMatch  object:  namespace Zend\\Router;\n\nclass RouteMatch\n{\n    public function __construct(array $params);\n    public function setMatchedRouteName($name);\n    public function getMatchedRouteName();\n    public function setParam($name, $value);\n    public function getParams();\n    public function getParam($name, $default = null);\n}  Typically, when a  Route  matches, it will define one or more parameters. These\nare passed into the  RouteMatch , and objects may query the  RouteMatch  for\ntheir values.  $id = $routeMatch->getParam('id', false);\nif (! $id) {\n    throw new Exception('Required identifier is missing!');\n}\n$entity = $resource->get($id);  Usually you will have multiple routes you wish to test against. In order to\nfacilitate this, you will use a route aggregate, usually implementing RouteStack :  namespace Zend\\Router;\n\ninterface RouteStackInterface extends RouteInterface\n{\n    public function addRoute($name, $route, $priority = null);\n    public function addRoutes(array $routes);\n    public function removeRoute($name);\n    public function setRoutes(array $routes);\n}  Routes will be queried in a LIFO order, and hence the reason behind the name RouteStack . zend-mvc provides two implementations of this interface, SimpleRouteStack  and  TreeRouteStack . In each, you register routes either one\nat a time using  addRoute() , or in bulk using  addRoutes() .  // One at a time:\n$route = Literal::factory([\n    'route' => '/foo',\n    'defaults' => [\n        'controller' => 'foo-index',\n        'action'     => 'index',\n    ],\n]);\n$router->addRoute('foo', $route);\n\n// In bulk:\n$router->addRoutes([\n    // using already instantiated routes:\n    'foo' => $route,\n\n    // providing configuration to allow lazy-loading routes:\n    'bar' => [\n        'type' => 'literal',\n        'options' => [\n            'route' => '/bar',\n            'defaults' => [\n                'controller' => 'bar-index',\n                'action'     => 'index',\n            ],\n        ],\n    ],\n]);",
            "title": "Routing"
        },
        {
            "location": "/routing/#router-types",
            "text": "Two routers are provided, the  SimpleRouteStack  and  TreeRouteStack . Each\nworks with the above interface, but utilize slightly different options and\nexecution paths. By default, the zend-mvc uses the  TreeRouteStack  as the\nrouter.",
            "title": "Router Types"
        },
        {
            "location": "/routing/#simpleroutestack",
            "text": "This router takes individual routes that provide their full matching logic in\none go, and loops through them in LIFO order until a match is found. As such,\nroutes that will match most often should be registered last, and least common\nroutes first. Additionally, you will need to ensure that routes that potentially\noverlap are registered such that the most specific match will match first (i.e.,\nregister later). Alternatively, you can set priorities by giving the priority as\nthird parameter to the  addRoute()  method, specifying the priority in the route\nspecifications or setting the priority property within a route instance before\nadding it to the route stack.",
            "title": "SimpleRouteStack"
        },
        {
            "location": "/routing/#treeroutestack",
            "text": "Zend\\Router\\Http\\TreeRouteStack  provides the ability to register trees of\nroutes, and uses a B-tree algorithm to match routes. As such, you register a\nsingle route with many children.  A  TreeRouteStack  will consist of the following configuration:   A base \"route\", which describes the base match needed, the root of the tree.  An optional  route_plugins , which is a configured\n   Zend\\Router\\RoutePluginManager  that can lazy-load routes.  The option  may_terminate , which hints to the router that no other segments\n  will follow it.  An optional  child_routes  array, which contains additional routes that stem\n  from the base \"route\" (i.e., build from it). Each child route can itself be a\n   TreeRouteStack  if desired; in fact, the  Part  route works exactly this way.   When a route matches against a  TreeRouteStack , the matched parameters from\neach segment of the tree will be returned.  A  TreeRouteStack  can be your sole route for your application, or describe\nparticular path segments of the application.  An example of a  TreeRouteStack  is provided in the documentation of the  Part \nroute.",
            "title": "TreeRouteStack"
        },
        {
            "location": "/routing/#http-route-types",
            "text": "zend-mvc ships with the following HTTP route types.",
            "title": "HTTP Route Types"
        },
        {
            "location": "/routing/#zend92router92http92hostname",
            "text": "The  Hostname  route attempts to match the hostname registered in the request\nagainst specific criteria. Typically, this will be in one of the following\nforms:   subdomain.domain.tld  :subdomain.domain.tld   In the above, the second route would return a \"subdomain\" key as part of the\nroute match.  For any given hostname segment, you may also provide a constraint. As an\nexample, if the \"subdomain\" segment needed to match only if it started with \"fw\"\nand contained exactly 2 digits following, the following route would be needed:  $route = Hostname::factory([\n    'route' => ':subdomain.domain.tld',\n    'constraints' => [\n        'subdomain' => 'fw\\d{2}',\n    ],\n]);  In the above example, only a \"subdomain\" key will be returned in the RouteMatch . If you wanted to also provide other information based on matching,\nor a default value to return for the subdomain, you need to also provide\ndefaults.  $route = Hostname::factory([\n    'route' => ':subdomain.domain.tld',\n    'constraints' => [\n        'subdomain' => 'fw\\d{2}',\n    ],\n    'defaults' => [\n        'type' => 'json',\n    ],\n]);  When matched, the above will return two keys in the  RouteMatch , \"subdomain\"\nand \"type\".",
            "title": "Zend\\Router\\Http\\Hostname"
        },
        {
            "location": "/routing/#zend92router92http92literal",
            "text": "The  Literal  route is for doing exact matching of the URI path. Configuration\ntherefore is solely the path you want to match, and the \"defaults\", or\nparameters you want returned on a match.  $route = Literal::factory([\n    'route' => '/foo',\n    'defaults' => [\n        'controller' => 'Application\\Controller\\IndexController',\n        'action' => 'foo',\n    ],\n]);  The above route would match a path \"/foo\", and return the key \"action\" in the RouteMatch , with the value \"foo\".",
            "title": "Zend\\Router\\Http\\Literal"
        },
        {
            "location": "/routing/#zend92router92http92method",
            "text": "The  Method  route is used to match the HTTP method or 'verb' specified in the\nrequest (See RFC 2616 Sec. 5.1.1). It can optionally be configured to match\nagainst multiple methods by providing a comma-separated list of method tokens.  $route = Method::factory([\n    'verb' => 'post,put',\n    'defaults' => [\n        'controller' => 'Application\\Controller\\IndexController',\n        'action' => 'form-submit',\n    ],\n]);  The above route would match an http \"POST\" or \"PUT\" request and return a RouteMatch  object containing a key \"action\" with a value of \"form-submit\".",
            "title": "Zend\\Router\\Http\\Method"
        },
        {
            "location": "/routing/#zend92router92http92part",
            "text": "A  Part  route allows crafting a tree of possible routes based on segments of\nthe URI path. It actually extends the  TreeRouteStack .  Part  routes are difficult to describe, so we'll simply provide a sample one\nhere.  $route = Part::factory([\n    'route' => [\n        'type' => 'literal',\n        'options' => [\n            'route' => '/',\n            'defaults' => [\n                'controller' => 'Application\\Controller\\IndexController',\n                'action' => 'index',\n            ],\n        ],\n    ],\n    'route_plugins' => $routePlugins,\n    'may_terminate' => true,\n    'child_routes' => [\n        'blog' => [\n            'type' => 'literal',\n            'options' => [\n                'route' => '/blog',\n                'defaults' => [\n                    'controller' => 'Application\\Controller\\BlogController',\n                    'action' => 'index',\n                ],\n            ],\n            'may_terminate' => true,\n            'child_routes' => [\n                'rss' => [\n                    'type' => 'literal',\n                    'options' => [\n                        'route' => '/rss',\n                        'defaults' => [\n                            'action' => 'rss',\n                        ]\n                    ],\n                    'may_terminate' => true,\n                    'child_routes' => [\n                        'subrss' => [\n                            'type' => 'literal',\n                            'options' => [\n                                'route' => '/sub',\n                                'defaults' => [\n                                    'action' => 'subrss',\n                                ],\n                            ],\n                        ],\n                    ],\n                ],\n            ],\n        ],\n        'forum' => [\n            'type' => 'literal',\n            'options' => [\n                'route' => 'forum',\n                'defaults' => [\n                    'controller' => 'Application\\Controller\\ForumController',\n                    'action' => 'index',\n                ],\n            ],\n        ],\n    ],\n]);  The above would match the following:   /  would load the \"Index\" controller, \"index\" action.  /blog  would load the \"Blog\" controller, \"index\" action.  /blog/rss  would load the \"Blog\" controller, \"rss\" action.  /blog/rss/sub  would load the \"Blog\" controller, \"subrss\" action.  /forum  would load the \"Forum\" controller, \"index\" action.   You may use any route type as a child route of a  Part  route.",
            "title": "Zend\\Router\\Http\\Part"
        },
        {
            "location": "/routing/#part-routes-are-an-implementation-detail",
            "text": "Part  routes are not meant to be used directly. When you add definitions for child_routes  to any route type, that route will become a  Part  route. As\nalready said, describing  Part  routes with words is difficult, so hopefully\nthe additional  examples at the end  will provide\nfurther insight.",
            "title": "Part routes are an implementation detail"
        },
        {
            "location": "/routing/#route-plugins",
            "text": "In the above example, the  $routePlugins  is an instance of Zend\\Router\\RoutePluginManager , containing essentially the following\nconfiguration:  $routePlugins = new Zend\\Router\\RoutePluginManager();\n$plugins = [\n    'hostname' => 'Zend\\Router\\Http\\Hostname',\n    'literal'  => 'Zend\\Router\\Http\\Literal',\n    'part'     => 'Zend\\Router\\Http\\Part',\n    'regex'    => 'Zend\\Router\\Http\\Regex',\n    'scheme'   => 'Zend\\Router\\Http\\Scheme',\n    'segment'  => 'Zend\\Router\\Http\\Segment',\n    'wildcard' => 'Zend\\Router\\Http\\Wildcard',\n    'query'    => 'Zend\\Router\\Http\\Query',\n    'method'   => 'Zend\\Router\\Http\\Method',\n];\nforeach ($plugins as $name => $class) {\n    $routePlugins->setInvokableClass($name, $class);\n}  When using  Zend\\Router\\Http\\TreeRouteStack , the  RoutePluginManager  is\nset up by default, and the developer does not need to worry about autoloading\nof standard HTTP routes.",
            "title": "Route plugins"
        },
        {
            "location": "/routing/#zend92router92http92regex",
            "text": "A  Regex  route utilizes a regular expression to match against the URI path. Any\nvalid regular expression is allowed; our recommendation is to use named captures\nfor any values you want to return in the  RouteMatch .  Since regular expression routes are often complex, you must specify a \"spec\" or\nspecification to use when assembling URLs from regex routes. The spec is simply\na string; replacements are identified using  %keyname%  within the string, with\nthe keys coming from either the captured values or named parameters passed to\nthe  assemble()  method.  Just like other routes, the  Regex  route can accept \"defaults\", parameters to\ninclude in the  RouteMatch  when successfully matched.  $route = Regex::factory([\n    'regex' => '/blog/(?<id>[a-zA-Z0-9_-]+)(\\.(?<format>(json|html|xml|rss)))?',\n    'defaults' => [\n        'controller' => 'Application\\Controller\\BlogController',\n        'action'     => 'view',\n        'format'     => 'html',\n    ],\n    'spec' => '/blog/%id%.%format%',\n]);  The above would match  /blog/001-some-blog_slug-here.html , and return four\nitems in the  RouteMatch , an \"id\", the \"controller\", the \"action\", and the\n\"format\". When assembling a URL from this route, the \"id\" and \"format\" values\nwould be used to fill the specification.",
            "title": "Zend\\Router\\Http\\Regex"
        },
        {
            "location": "/routing/#zend92router92http92scheme",
            "text": "The  Scheme  route matches the URI scheme only, and must be an exact match. As\nsuch, this route, like the  Literal  route, simply takes what you want to match\nand the \"defaults\", parameters to return on a match.  $route = Scheme::factory([\n    'scheme' => 'https',\n    'defaults' => [\n        'https' => true,\n    ],\n]);  The above route would match the \"https\" scheme, and return the key \"https\" in\nthe  RouteMatch  with a boolean  true  value.",
            "title": "Zend\\Router\\Http\\Scheme"
        },
        {
            "location": "/routing/#zend92router92http92segment",
            "text": "A  Segment  route allows matching any segment of a URI path. Segments are\ndenoted using a colon, followed by alphanumeric characters; if a segment is\noptional, it should be surrounded by brackets.  As an example,  /:foo[/:bar] \nwould match a  /  followed by text and assign it to the key \"foo\"; if any\nadditional  /  characters are found, any text following the last one will be\nassigned to the key \"bar\".  The separation between literal and named segments can be anything. For example,\nthe above could be done as  /:foo{-}[-:bar]  as well. The  {-}  after the  :foo \nparameter indicates a set of one or more delimiters, after which matching of the\nparameter itself ends.  Each segment may have constraints associated with it. Each constraint should\nsimply be a regular expression expressing the conditions under which that\nsegment should match.  Also, as you can in other routes, you may provide defaults to use; these are\nparticularly useful when using optional segments.  As a complex example:  $route = Segment::factory([\n    'route' => '/:controller[/:action]',\n    'constraints' => [\n        'controller' => '[a-zA-Z][a-zA-Z0-9_-]+',\n        'action'     => '[a-zA-Z][a-zA-Z0-9_-]+',\n    ],\n    'defaults' => [\n        'controller' => 'Application\\Controller\\IndexController',\n        'action'     => 'index',\n    ],\n]);",
            "title": "Zend\\Router\\Http\\Segment"
        },
        {
            "location": "/routing/#zend92router92http92query-deprecated",
            "text": "",
            "title": "Zend\\Router\\Http\\Query (Deprecated)"
        },
        {
            "location": "/routing/#potential-security-issue",
            "text": "Misuse of this route can lead to potential security issues.",
            "title": "Potential security issue"
        },
        {
            "location": "/routing/#deprecated",
            "text": "This route part is deprecated since you can now add query parameters without a\nquery route. It was removed in version 3 of the router.   The  Query  route part allows you to specify and capture query string parameters\nfor a given route.  The intention of the  Query  part is that you do not instantiate it in its own\nright, but use it as a child of another route part.  An example of its usage would be:  $route = Part::factory([\n    'route' => [\n        'type'    => 'literal',\n        'options' => [\n            'route'    => 'page',\n            'defaults' => [],\n        ],\n    ],\n    'may_terminate' => true,\n    'route_plugins' => $routePlugins,\n    'child_routes'  => [\n        'query' => [\n            'type' => 'Query',\n            'options' => [\n                'defaults' => [\n                    'foo' => 'bar',\n                ],\n            ],\n        ],\n    ],\n]);  This then allows you to create query strings using the url view helper.  $this->url(\n    'page/query',\n    [\n        'name'   => 'my-test-page',\n        'format' => 'rss',\n        'limit'  => 10,\n    ]\n);  Per the above example, you must add  /query  (the name we gave to our query\nroute segment) to your route name in order to append a query string. If you do\nnot specify  /query  in the route name, then no query string will be appended.  Our example \"page\" route has only one defined parameter of \"name\"\n( /page[/:name] ), meaning that the remaining parameters of \"format\" and \"limit\"\nwill then be appended as a query string.  The output from our example should then be /page/my-test-page?format=rss&limit=10",
            "title": "Deprecated"
        },
        {
            "location": "/routing/#zend92router92http92wildcard-deprecated",
            "text": "",
            "title": "Zend\\Router\\Http\\Wildcard (Deprecated)"
        },
        {
            "location": "/routing/#potential-security-issue_1",
            "text": "Misuse of this route type can lead to potential security issues.",
            "title": "Potential security issue"
        },
        {
            "location": "/routing/#deprecated_1",
            "text": "This route type is deprecated. Use the  Segment  route type.   The  Wildcard  route type matches all remaining segments of a URI path.",
            "title": "Deprecated"
        },
        {
            "location": "/routing/#http-routing-examples",
            "text": "Most of the routing definitions will be done in module configuration files, so\nthe following examples will show how to set up routes in config files.",
            "title": "HTTP Routing Examples"
        },
        {
            "location": "/routing/#simple-example-with-two-literal-routes",
            "text": "return [\n    'router' => [\n        'routes' => [\n            // Literal route named \"home\"\n            'home' => [\n                'type' => 'literal',\n                'options' => [\n                    'route' => '/',\n                    'defaults' => [\n                        'controller' => 'Application\\Controller\\IndexController',\n                        'action' => 'index',\n                    ],\n                ],\n            ],\n            // Literal route named \"contact\"\n            'contact' => [\n                'type' => 'literal',\n                'options' => [\n                    'route' => 'contact',\n                    'defaults' => [\n                        'controller' => 'Application\\Controller\\ContactController',\n                        'action' => 'form',\n                    ],\n                ],\n            ],\n        ],\n    ],\n];",
            "title": "Simple example with two literal routes"
        },
        {
            "location": "/routing/#a-complex-example-with-child-routes",
            "text": "return [\n    'router' => [\n        'routes' => [\n            // Literal route named \"home\"\n            'home' => [\n                'type' => 'literal',\n                'options' => [\n                    'route' => '/',\n                    'defaults' => [\n                        'controller' => 'Application\\Controller\\IndexController',\n                        'action' => 'index',\n                    ],\n                ],\n            ],\n            // Literal route named \"blog\", with child routes\n            'blog' => [\n                'type' => 'literal',\n                'options' => [\n                    'route' => '/blog',\n                    'defaults' => [\n                        'controller' => 'Application\\Controller\\BlogController',\n                        'action' => 'index',\n                    ],\n                ],\n                'may_terminate' => true,\n                'child_routes' => [\n                    // Segment route for viewing one blog post\n                    'post' => [\n                        'type' => 'segment',\n                        'options' => [\n                            'route' => '/[:slug]',\n                            'constraints' => [\n                                'slug' => '[a-zA-Z0-9_-]+',\n                            ],\n                            'defaults' => [\n                                'action' => 'view',\n                            ],\n                        ],\n                    ],\n                    // Literal route for viewing blog RSS feed\n                    'rss' => [\n                        'type' => 'literal',\n                        'options' => [\n                            'route' => '/rss',\n                            'defaults' => [\n                                'action' => 'rss',\n                            ],\n                        ],\n                    ],\n                ],\n            ],\n        ],\n    ],\n];  When using child routes, naming of the routes follows the  parent/child \npattern, so to use the child routes from the above example:  echo $this->url('blog'); // gives \"/blog\"\necho $this->url('blog/post', ['slug' => 'my-post']); // gives \"/blog/my-post\"\necho $this->url('blog/rss'); // gives \"/blog/rss\"",
            "title": "A complex example with child routes"
        },
        {
            "location": "/routing/#an-example-with-multiple-hostnames-and-subdomains-within-a-single-application",
            "text": "return [\n    'router' => [\n        'routes' => [\n            'modules.zendframework.com' => [\n                'type' => 'Zend\\Router\\Http\\Hostname',\n                'options' => [\n                    'route' => ':4th.[:3rd.]:2nd.:1st', // domain levels from right to left\n                    'constraints' => [\n                        '4th' => 'modules',\n                        '3rd' => '.*?', // optional 3rd level domain such as .ci, .dev or .test\n                        '2nd' => 'zendframework',\n                        '1st' => 'com',\n                    ],\n                    // Purposely omit default controller and action\n                    // to let the child routes control the route match\n                ],\n                // child route controllers may span multiple modules as desired\n                'child_routes' => [\n                    'index' => [\n                        'type' => 'Zend\\Router\\Http\\Literal',\n                        'options' => [\n                            'route' => '/',\n                            'defaults' => [\n                                'controller' => 'Module\\Controller\\Index',\n                                'action' = > 'index',\n                            ],\n                        ],\n                        'may_terminate' => true,\n                    ],\n                ],\n            ],\n            'packages.zendframework.com' => [\n                'type' => 'Zend\\Router\\Http\\Hostname',\n                'options' => [\n                    'route' => ':4th.[:3rd.]:2nd.:1st', // domain levels from right to left\n                    'constraints' => [\n                        '4th' => 'packages',\n                        '3rd' => '.*?', // optional 3rd level domain such as .ci, .dev or .test\n                        '2nd' => 'zendframework',\n                        '1st' => 'com',\n                    ],\n                    // Purposely omit default controller and action\n                    // to let the child routes control the route match\n                ],\n                // child route controllers may span multiple modules as desired\n                'child_routes' => [\n                    'index' => [\n                        'type' => 'Zend\\Router\\Http\\Literal',\n                        'options' => [\n                            'route' => '/',\n                            'defaults' => [\n                                'controller' => 'Package\\Controller\\Index',\n                                'action' = > 'index',\n                            ],\n                        ],\n                        'may_terminate' => true,\n                    ],\n                ],\n            ],\n        ],\n    ],\n];  The above would match the following:   modules.zendframework.com  would dispatch the  Index  controller's  index \n  action of the  Module  module.  modules.ci.zendframework.com  would dispatch the  Index  controller's  index \n  action of the  Module  module.  packages.zendframework.com  would dispatch the  Index  controller's  index \n  action of the  Package  module.  packages.dev.zendframework.com  would dispatch the  Index  controller's\n   index  action of the  Package  module.   The  Url  controller plugin or view helper may be used to generate URLs\nfollowing the above example:  // reuse the route matched parameters to generate URLs\necho $this->url('modules.zendframework.com/index', [], [], true);\necho $this->url('packages.zendframework.com/index', [], [], true);",
            "title": "An example with multiple Hostnames and subdomains within a single application"
        },
        {
            "location": "/routing/#may_terminate-and-child_routes-placement",
            "text": "When defining child routes pay attention that the  may_terminate  and child_routes  definitions are in same level as the  options  and  type \ndefinitions. A common pitfall is to have those two definitions nested in options , which will not result in the desired routes.",
            "title": "may_terminate and child_routes placement"
        },
        {
            "location": "/routing/#console-route-types",
            "text": "zend-mvc also allows routing Console based applications; console routes are\nexplained in the  zend-console routing documentation .",
            "title": "Console Route Types"
        },
        {
            "location": "/mvc-event/",
            "text": "The MvcEvent\n\n\nzend-mvc defines and utilizes a custom \nZend\\EventManager\\Event\n implementation,\n\nZend\\Mvc\\MvcEvent\n. This event is created during \nZend\\Mvc\\Application::bootstrap()\n\nand is passed when triggering all application events.  Additionally, if your\ncontrollers implement the \nZend\\Mvc\\InjectApplicationEventInterface\n, \nMvcEvent\n\nwill be injected into those controllers.\n\n\nThe \nMvcEvent\n adds accessors and mutators for the following:\n\n\n\n\nApplication\n object.\n\n\nRequest\n object.\n\n\nResponse\n object.\n\n\nRouter\n object.\n\n\nRouteMatch\n object.\n\n\nResult - usually the result of dispatching a controller.\n\n\nViewModel\n object, typically representing the layout view model.\n\n\n\n\nThe methods it defines are:\n\n\n\n\nsetApplication($application)\n\n\ngetApplication()\n\n\nsetRequest($request)\n\n\ngetRequest()\n\n\nsetResponse($response)\n\n\ngetResponse()\n\n\nsetRouter($router)\n\n\ngetRouter()\n\n\nsetRouteMatch($routeMatch)\n\n\ngetRouteMatch()\n\n\nsetResult($result)\n\n\ngetResult()\n\n\nsetViewModel($viewModel)\n\n\ngetViewModel()\n\n\nisError()\n\n\nsetError()\n\n\ngetError()\n\n\ngetController()\n\n\nsetController($name)\n\n\ngetControllerClass()\n\n\nsetControllerClass($class)\n\n\n\n\nThe \nApplication\n, \nRequest\n, \nResponse\n, \nRouter\n, and \nViewModel\n are all\ninjected during the \nbootstrap\n event. Following the \nroute\n event, it will be\ninjected also with the \nRouteMatch\n object encapsulating the results of routing.\n\n\nSince this object is passed around throughout the MVC, it is a common location\nfor retrieving the results of routing, the router, and the request and response\nobjects. Additionally, we encourage setting the results of execution in the\nevent, to allow event listeners to introspect them and utilize them within their\nexecution. As an example, the results could be passed into a view renderer.\n\n\nOrder of events\n\n\nThe following events are triggered, in the following order:\n\n\n\n\n\n\n\n\nName\n\n\nConstant\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nbootstrap\n\n\nMvcEvent::EVENT_BOOTSTRAP\n\n\nBootstrap the application by creating the ViewManager.\n\n\n\n\n\n\nroute\n\n\nMvcEvent::EVENT_ROUTE\n\n\nPerform routing (or route-related actions).\n\n\n\n\n\n\ndispatch\n\n\nMvcEvent::EVENT_DISPATCH\n\n\nDispatch the matched route to a controller/action.\n\n\n\n\n\n\ndispatch.error\n\n\nMvcEvent::EVENT_DISPATCH_ERROR\n\n\nEvent triggered in case of a problem during dispatch process (e.g., unknown controller).\n\n\n\n\n\n\nrender\n\n\nMvcEvent::EVENT_RENDER\n\n\nPrepare the data and delegate the rendering to the view layer.\n\n\n\n\n\n\nrender.error\n\n\nMvcEvent::EVENT_RENDER_ERROR\n\n\nEvent triggered in case of a problem during the render process (e.g., no renderer found).\n\n\n\n\n\n\nfinish\n\n\nMvcEvent::EVENT_FINISH\n\n\nPerform tasks once everything else is done.\n\n\n\n\n\n\n\n\nThe following sections provide more detail on each event.\n\n\nMvcEvent::EVENT_BOOTSTRAP\n (\"bootstrap\")\n\n\nListeners\n\n\nThe following classes listen to this event (sorted from higher priority to lower\npriority):\n\n\n\n\n\n\n\n\nClass\n\n\nPriority\n\n\nMethod Called\n\n\nTriggers\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nZend\\Mvc\\View\\Http\\ViewManager\n\n\n10000\n\n\nonBootstrap\n\n\nnone\n\n\nPrepares the view layer (instantiate a \nZend\\Mvc\\View\\Http\\ViewManager\n).\n\n\n\n\n\n\n\n\nTriggered By\n\n\nThis event is triggered by the following classes:\n\n\n\n\n\n\n\n\nClass\n\n\nIn Method\n\n\n\n\n\n\n\n\n\n\nZend\\Mvc\\Application\n\n\nbootstrap\n\n\n\n\n\n\n\n\nMvcEvent::EVENT_ROUTE\n (\"route\")\n\n\nListeners\n\n\nThe following classes listen to this event (sorted from higher priority to lower\npriority):\n\n\n\n\n\n\n\n\nClass\n\n\nPriority\n\n\nMethod Called\n\n\nTriggers\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nZend\\Mvc\\ModuleRouteListener\n\n\n1\n\n\nonRoute\n\n\nnone\n\n\nDetermines if the module namespace should be prepended to the controller name. This is the case if the route match contains a parameter key matching the \nMODULE_NAMESPACE\n constant.\n\n\n\n\n\n\nZend\\Mvc\\RouteListener\n\n\n1\n\n\nonRoute\n\n\nMvcEvent::EVENT_DISPATCH_ERROR\n (if no route is matched)\n\n\nTries to match the request to the router and return a \nRouteMatch\n object.\n\n\n\n\n\n\n\n\nTriggered By\n\n\nThis event is triggered by the following classes:\n\n\n\n\n\n\n\n\nClass\n\n\nIn Method\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nZend\\Mvc\\Application\n\n\nrun\n\n\nUses a short circuit callback that allows halting propagation of the event if an error is raised during routing.\n\n\n\n\n\n\n\n\nMvcEvent::EVENT_DISPATCH\n (\"dispatch\")\n\n\nListeners\n\n\nThe following classes listen to this event (sorted from higher priority to lower\npriority):\n\n\nConsole context only\n\n\nThe following listeners are only attached in a console context:\n\n\n\n\n\n\n\n\nClass\n\n\nPriority\n\n\nMethod Called\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nZend\\Mvc\\View\\Console\\InjectNamedConsoleParamsListener\n\n\n1000\n\n\ninjectNamedParams\n\n\nMerge all params (route match params and params in the command), and add them to the \nRequest\n object.\n\n\n\n\n\n\nZend\\Mvc\\View\\Console\\CreateViewModelListener\n\n\n-80\n\n\ncreateViewModelFromArray\n\n\nIf the controller action returns an associative array, this listener casts it to a \nConsoleModel\n object.\n\n\n\n\n\n\nZend\\Mvc\\View\\Console\\CreateViewModelListener\n\n\n-80\n\n\ncreateViewModelFromString\n\n\nIf the controller action returns a string, this listener casts it to a \nConsoleModel\n object.\n\n\n\n\n\n\nZend\\Mvc\\View\\Console\\CreateViewModelListener\n\n\n-80\n\n\ncreateViewModelFromNull\n\n\nIf the controller action returns null, this listener casts it to a \nConsoleModel\n object.\n\n\n\n\n\n\nZend\\Mvc\\View\\Console\\InjectViewModelListener\n\n\n-100\n\n\ninjectViewModel\n\n\nInserts the \nViewModel\n (in this case, a \nConsoleModel\n) and adds it to the MvcEvent object. It either (a) adds it as a child to the default, composed view model, or (b) replaces it if the result is marked as terminal.\n\n\n\n\n\n\n\n\nHTTP context only\n\n\nThe following listeners are only attached in an HTTP context:\n\n\n\n\n\n\n\n\nClass\n\n\nPriority\n\n\nMethod Called\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nZend\\Mvc\\View\\Http\\CreateViewModelListener\n\n\n-80\n\n\ncreateViewModelFromArray\n\n\nIf the controller action returns an associative array, this listener casts it to a \nViewModel\n object.\n\n\n\n\n\n\nZend\\Mvc\\View\\Http\\CreateViewModelListener\n\n\n-80\n\n\ncreateViewModelFromNull\n\n\nIf the controller action returns null, this listener casts it to a \nViewModel\n object.\n\n\n\n\n\n\nZend\\Mvc\\View\\Http\\RouteNotFoundStrategy\n\n\n-90\n\n\nprepareNotFoundViewModel\n\n\nCreates and return a 404 \nViewModel\n.\n\n\n\n\n\n\nZend\\Mvc\\View\\Http\\InjectTemplateListener\n\n\n-90\n\n\ninjectTemplate\n\n\nInjects a template into the view model, if none present. Template name is derived from the controller found in the route match, and, optionally, the action, if present.\n\n\n\n\n\n\nZend\\Mvc\\View\\Http\\InjectViewModelListener\n\n\n-100\n\n\ninjectViewModel\n\n\nInserts the \nViewModel\n (in this case, a \nViewModel\n) and adds it to the \nMvcEvent\n object. It either (a) adds it as a child to the default, composed view model, or (b) replaces it if the result is marked as terminable.\n\n\n\n\n\n\n\n\nAll contexts\n\n\nThe following listeners are attached for all contexts (sorted from higher\npriority to lower priority):\n\n\n\n\n\n\n\n\nClass\n\n\nPriority\n\n\nMethod Called\n\n\nTriggers\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nZend\\Mvc\\MiddlewareListener\n\n\n1\n\n\nonDispatch\n\n\nMvcEvent::EVENT_DISPATCH_ERROR\n (if an exception is raised during dispatch processes)\n\n\nLoad and dispatch the matched PSR-7 middleware from the service manager (and throws various exceptions if it does not).\n\n\n\n\n\n\nZend\\Mvc\\DispatchListener\n\n\n1\n\n\nonDispatch\n\n\nMvcEvent::EVENT_DISPATCH_ERROR\n (if an exception is raised during dispatch processes)\n\n\nLoad and dispatch the matched controller from the service manager (and throws various exceptions if it does not).\n\n\n\n\n\n\nZend\\Mvc\\AbstractController\n\n\n1\n\n\nonDispatch\n\n\nnone\n\n\nThe \nonDispatch\n method of the \nAbstractController\n is an abstract method. In \nAbstractActionController\n, for instance, it calls the action method.\n\n\n\n\n\n\n\n\nTriggered By\n\n\nThis event is triggered by the following classes:\n\n\n\n\n\n\n\n\nClass\n\n\nIn Method\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nZend\\Mvc\\Application\n\n\nrun\n\n\nUses a short circuit callback to halt propagation of the event if an error is raised during routing.\n\n\n\n\n\n\nZend\\Mvc\\Controller\\AbstractController\n\n\ndispatch\n\n\nIf a listener returns a \nResponse\n object, it halts propagation. Note: every \nAbstractController\n listens to this event and executes the \nonDispatch\n method when it is triggered.\n\n\n\n\n\n\n\n\nMvcEvent::EVENT_DISPATCH_ERROR\n (\"dispatch.error\")\n\n\nListeners\n\n\nThe following classes listen to this event (sorted from higher priority to lower\npriority):\n\n\nConsole context only\n\n\nThe following listeners are only attached in a console context:\n\n\n\n\n\n\n\n\nClass\n\n\nPriority\n\n\nMethod Called\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nZend\\Mvc\\View\\Console\\RouteNotFoundStrategy\n\n\n1\n\n\nhandleRouteNotFoundError\n\n\nDetect if an error is a \"route not found\" condition. If a \u201ccontroller not found\u201d or \u201cinvalid controller\u201d error type is encountered, sets the response status code to 404.\n\n\n\n\n\n\nZend\\Mvc\\View\\Console\\ExceptionStrategy\n\n\n1\n\n\nprepareExceptionViewModel\n\n\nCreate an exception view model, and sets the status code to 404.\n\n\n\n\n\n\nZend\\Mvc\\View\\Console\\InjectViewModelListener\n\n\n-100\n\n\ninjectViewModel\n\n\nInserts the \nViewModel\n (in this case, a \nConsoleModel\n) and adds it to the \nMvcEvent\n object. It either (a) adds it as a child to the default, composed view model, or (b) replaces it if the result is marked as terminable.\n\n\n\n\n\n\n\n\nHTTP context only\n\n\nThe following listeners are only attached in an HTTP context:\n\n\n\n\n\n\n\n\nClass\n\n\nPriority\n\n\nMethod Called\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nZend\\Mvc\\View\\Http\\RouteNotFoundStrategy\n\n\n1\n\n\ndetectNotFoundError\n\n\nDetect if an error is a 404 condition. If a \u201ccontroller not found\u201d or \u201cinvalid controller\u201d error type is encountered, sets the response status code to 404.\n\n\n\n\n\n\nZend\\Mvc\\View\\Http\\RouteNotFoundStrategy\n\n\n1\n\n\nprepareNotFoundViewModel\n\n\nCreate and return a 404 view model.\n\n\n\n\n\n\nZend\\Mvc\\View\\Http\\ExceptionStrategy\n\n\n1\n\n\nprepareExceptionViewModel\n\n\nCreate an exception view model and set the status code to 404.\n\n\n\n\n\n\nZend\\Mvc\\View\\Http\\InjectViewModelListener\n\n\n-100\n\n\ninjectViewModel\n\n\nInserts the \nViewModel\n (in this case, a \nViewModel\n) and adds it to the MvcEvent object. It either (a) adds it as a child to the default, composed view model, or (b) replaces it if the result is marked as terminable.\n\n\n\n\n\n\n\n\nAll contexts\n\n\nThe following listeners are attached for all contexts:\n\n\n\n\n\n\n\n\nClass\n\n\nPriority\n\n\nMethod Called\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nZend\\Mvc\\DispatchListener\n\n\n1\n\n\nreportMonitorEvent\n\n\nUsed for monitoring when Zend Server is used.\n\n\n\n\n\n\n\n\nTriggered By\n\n\n\n\n\n\n\n\nClass\n\n\nIn Method\n\n\n\n\n\n\n\n\n\n\nZend\\Mvc\\MiddlewareListener\n\n\nonDispatch\n\n\n\n\n\n\nZend\\Mvc\\DispatchListener\n\n\nonDispatch\n\n\n\n\n\n\nZend\\Mvc\\DispatchListener\n\n\nmarshallControllerNotFoundEvent\n\n\n\n\n\n\nZend\\Mvc\\DispatchListener\n\n\nmarshallBadControllerEvent\n\n\n\n\n\n\n\n\nMvcEvent::EVENT_RENDER\n (\"render\")\n\n\nListeners\n\n\nThe following classes listen to this event (sorted from higher priority to lower\npriority):\n\n\nConsole context only\n\n\nThe following listeners are only attached in a console context:\n\n\n\n\n\n\n\n\nClass\n\n\nPriority\n\n\nMethod Called\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nZend\\Mvc\\View\\Console\\DefaultRenderingStrategy\n\n\n-10000\n\n\nrender\n\n\nRender the view.\n\n\n\n\n\n\n\n\nHTTP context only\n\n\nThe following listeners are only attached in an HTTP context:\n\n\n\n\n\n\n\n\nClass\n\n\nPriority\n\n\nMethod Called\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nZend\\Mvc\\View\\Http\\DefaultRenderingStrategy\n\n\n-10000\n\n\nrender\n\n\nRender the view.\n\n\n\n\n\n\n\n\nTriggered By\n\n\nThis event is triggered by the following classes:\n\n\n\n\n\n\n\n\nClass\n\n\nIn Method\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nZend\\Mvc\\Application\n\n\ncompleteRequest\n\n\nThis event is triggered just before the \nMvcEvent::FINISH\n event.\n\n\n\n\n\n\n\n\nMvcEvent::EVENT_RENDER_ERROR\n (\"render.error\")\n\n\nListeners\n\n\nThe following classes listen to this event (sorted from higher priority to lower\npriority):\n\n\nConsole context only\n\n\nThe following listeners are only attached in a console context:\n\n\n\n\n\n\n\n\nClass\n\n\nPriority\n\n\nMethod Called\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nZend\\Mvc\\View\\Console\\ExceptionStrategy\n\n\n1\n\n\nprepareExceptionViewModel\n\n\nCreate an exception view model and set the status code to 404.\n\n\n\n\n\n\nZend\\Mvc\\View\\Console\\InjectViewModelListener\n\n\n-100\n\n\ninjectViewModel\n\n\nInserts the \nViewModel\n (in this case, a \nConsoleModel\n) and adds it to the \nMvcEvent\n object. It either (a) adds it as a child to the default, composed view model, or (b) replaces it if the result is marked as terminable.\n\n\n\n\n\n\n\n\nHTTP context only\n\n\nThe following listeners are only attached in an HTTP context:\n\n\n\n\n\n\n\n\nClass\n\n\nPriority\n\n\nMethod Called\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nZend\\Mvc\\View\\Http\\ExceptionStrategy\n\n\n1\n\n\nprepareExceptionViewModel\n\n\nCreate an exception view model and set the status code to 404.\n\n\n\n\n\n\nZend\\Mvc\\View\\Http\\InjectViewModelListener\n\n\n-100\n\n\ninjectViewModel\n\n\nInserts the \nViewModel\n (in this case, a \nViewModel\n) and adds it to the MvcEvent object. It either (a) adds it as a child to the default, composed view model, or (b) replaces it if the result is marked as terminable.\n\n\n\n\n\n\nZend\\Mvc\\View\\Http\\DefaultRenderingStrategy\n\n\n-10000\n\n\nrender\n\n\nRender the view\n\n\n\n\n\n\n\n\nTriggered By\n\n\nThis event is triggered by the following classes:\n\n\n\n\n\n\n\n\nClass\n\n\nIn Method\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nZend\\Mvc\\View\\Http\\DefaultRenderingStrategy\n\n\nrender\n\n\nThis event is triggered if an exception is raised during rendering.\n\n\n\n\n\n\n\n\nMvcEvent::EVENT_FINISH\n (\"finish\")\n\n\nListeners\n\n\nThe following classes listen to this event (sorted from higher priority to lower\npriority):\n\n\n\n\n\n\n\n\nClass\n\n\nPriority\n\n\nMethod Called\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nZend\\Mvc\\SendResponseListener\n\n\n-10000\n\n\nsendResponse\n\n\nTriggers the \nSendResponseEvent\n in order to prepare the response (see the next chapter for more information about \nSendResponseEvent\n).\n\n\n\n\n\n\n\n\nTriggered By\n\n\nThis event is triggered by the following classes:\n\n\n\n\n\n\n\n\nClass\n\n\nIn Method\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nZend\\Mvc\\Application\n\n\nrun\n\n\nThis event is triggered once the \nMvcEvent::ROUTE\n event returns a correct \nResponseInterface\n.\n\n\n\n\n\n\nZend\\Mvc\\Application\n\n\nrun\n\n\nThis event is triggered once the \nMvcEvent::DISPATCH\n event returns a correct \nResponseInterface\n.\n\n\n\n\n\n\nZend\\Mvc\\Application\n\n\ncompleteRequest\n\n\nThis event is triggered after \nMvcEvent::RENDER\n (at this point, the view is already rendered).",
            "title": "The MVC Event"
        },
        {
            "location": "/mvc-event/#the-mvcevent",
            "text": "zend-mvc defines and utilizes a custom  Zend\\EventManager\\Event  implementation, Zend\\Mvc\\MvcEvent . This event is created during  Zend\\Mvc\\Application::bootstrap() \nand is passed when triggering all application events.  Additionally, if your\ncontrollers implement the  Zend\\Mvc\\InjectApplicationEventInterface ,  MvcEvent \nwill be injected into those controllers.  The  MvcEvent  adds accessors and mutators for the following:   Application  object.  Request  object.  Response  object.  Router  object.  RouteMatch  object.  Result - usually the result of dispatching a controller.  ViewModel  object, typically representing the layout view model.   The methods it defines are:   setApplication($application)  getApplication()  setRequest($request)  getRequest()  setResponse($response)  getResponse()  setRouter($router)  getRouter()  setRouteMatch($routeMatch)  getRouteMatch()  setResult($result)  getResult()  setViewModel($viewModel)  getViewModel()  isError()  setError()  getError()  getController()  setController($name)  getControllerClass()  setControllerClass($class)   The  Application ,  Request ,  Response ,  Router , and  ViewModel  are all\ninjected during the  bootstrap  event. Following the  route  event, it will be\ninjected also with the  RouteMatch  object encapsulating the results of routing.  Since this object is passed around throughout the MVC, it is a common location\nfor retrieving the results of routing, the router, and the request and response\nobjects. Additionally, we encourage setting the results of execution in the\nevent, to allow event listeners to introspect them and utilize them within their\nexecution. As an example, the results could be passed into a view renderer.",
            "title": "The MvcEvent"
        },
        {
            "location": "/mvc-event/#order-of-events",
            "text": "The following events are triggered, in the following order:     Name  Constant  Description      bootstrap  MvcEvent::EVENT_BOOTSTRAP  Bootstrap the application by creating the ViewManager.    route  MvcEvent::EVENT_ROUTE  Perform routing (or route-related actions).    dispatch  MvcEvent::EVENT_DISPATCH  Dispatch the matched route to a controller/action.    dispatch.error  MvcEvent::EVENT_DISPATCH_ERROR  Event triggered in case of a problem during dispatch process (e.g., unknown controller).    render  MvcEvent::EVENT_RENDER  Prepare the data and delegate the rendering to the view layer.    render.error  MvcEvent::EVENT_RENDER_ERROR  Event triggered in case of a problem during the render process (e.g., no renderer found).    finish  MvcEvent::EVENT_FINISH  Perform tasks once everything else is done.     The following sections provide more detail on each event.",
            "title": "Order of events"
        },
        {
            "location": "/mvc-event/#mvceventevent_bootstrap-bootstrap",
            "text": "",
            "title": "MvcEvent::EVENT_BOOTSTRAP (\"bootstrap\")"
        },
        {
            "location": "/mvc-event/#listeners",
            "text": "The following classes listen to this event (sorted from higher priority to lower\npriority):     Class  Priority  Method Called  Triggers  Description      Zend\\Mvc\\View\\Http\\ViewManager  10000  onBootstrap  none  Prepares the view layer (instantiate a  Zend\\Mvc\\View\\Http\\ViewManager ).",
            "title": "Listeners"
        },
        {
            "location": "/mvc-event/#triggered-by",
            "text": "This event is triggered by the following classes:     Class  In Method      Zend\\Mvc\\Application  bootstrap",
            "title": "Triggered By"
        },
        {
            "location": "/mvc-event/#mvceventevent_route-route",
            "text": "",
            "title": "MvcEvent::EVENT_ROUTE (\"route\")"
        },
        {
            "location": "/mvc-event/#listeners_1",
            "text": "The following classes listen to this event (sorted from higher priority to lower\npriority):     Class  Priority  Method Called  Triggers  Description      Zend\\Mvc\\ModuleRouteListener  1  onRoute  none  Determines if the module namespace should be prepended to the controller name. This is the case if the route match contains a parameter key matching the  MODULE_NAMESPACE  constant.    Zend\\Mvc\\RouteListener  1  onRoute  MvcEvent::EVENT_DISPATCH_ERROR  (if no route is matched)  Tries to match the request to the router and return a  RouteMatch  object.",
            "title": "Listeners"
        },
        {
            "location": "/mvc-event/#triggered-by_1",
            "text": "This event is triggered by the following classes:     Class  In Method  Description      Zend\\Mvc\\Application  run  Uses a short circuit callback that allows halting propagation of the event if an error is raised during routing.",
            "title": "Triggered By"
        },
        {
            "location": "/mvc-event/#mvceventevent_dispatch-dispatch",
            "text": "",
            "title": "MvcEvent::EVENT_DISPATCH (\"dispatch\")"
        },
        {
            "location": "/mvc-event/#listeners_2",
            "text": "The following classes listen to this event (sorted from higher priority to lower\npriority):",
            "title": "Listeners"
        },
        {
            "location": "/mvc-event/#console-context-only",
            "text": "The following listeners are only attached in a console context:     Class  Priority  Method Called  Description      Zend\\Mvc\\View\\Console\\InjectNamedConsoleParamsListener  1000  injectNamedParams  Merge all params (route match params and params in the command), and add them to the  Request  object.    Zend\\Mvc\\View\\Console\\CreateViewModelListener  -80  createViewModelFromArray  If the controller action returns an associative array, this listener casts it to a  ConsoleModel  object.    Zend\\Mvc\\View\\Console\\CreateViewModelListener  -80  createViewModelFromString  If the controller action returns a string, this listener casts it to a  ConsoleModel  object.    Zend\\Mvc\\View\\Console\\CreateViewModelListener  -80  createViewModelFromNull  If the controller action returns null, this listener casts it to a  ConsoleModel  object.    Zend\\Mvc\\View\\Console\\InjectViewModelListener  -100  injectViewModel  Inserts the  ViewModel  (in this case, a  ConsoleModel ) and adds it to the MvcEvent object. It either (a) adds it as a child to the default, composed view model, or (b) replaces it if the result is marked as terminal.",
            "title": "Console context only"
        },
        {
            "location": "/mvc-event/#http-context-only",
            "text": "The following listeners are only attached in an HTTP context:     Class  Priority  Method Called  Description      Zend\\Mvc\\View\\Http\\CreateViewModelListener  -80  createViewModelFromArray  If the controller action returns an associative array, this listener casts it to a  ViewModel  object.    Zend\\Mvc\\View\\Http\\CreateViewModelListener  -80  createViewModelFromNull  If the controller action returns null, this listener casts it to a  ViewModel  object.    Zend\\Mvc\\View\\Http\\RouteNotFoundStrategy  -90  prepareNotFoundViewModel  Creates and return a 404  ViewModel .    Zend\\Mvc\\View\\Http\\InjectTemplateListener  -90  injectTemplate  Injects a template into the view model, if none present. Template name is derived from the controller found in the route match, and, optionally, the action, if present.    Zend\\Mvc\\View\\Http\\InjectViewModelListener  -100  injectViewModel  Inserts the  ViewModel  (in this case, a  ViewModel ) and adds it to the  MvcEvent  object. It either (a) adds it as a child to the default, composed view model, or (b) replaces it if the result is marked as terminable.",
            "title": "HTTP context only"
        },
        {
            "location": "/mvc-event/#all-contexts",
            "text": "The following listeners are attached for all contexts (sorted from higher\npriority to lower priority):     Class  Priority  Method Called  Triggers  Description      Zend\\Mvc\\MiddlewareListener  1  onDispatch  MvcEvent::EVENT_DISPATCH_ERROR  (if an exception is raised during dispatch processes)  Load and dispatch the matched PSR-7 middleware from the service manager (and throws various exceptions if it does not).    Zend\\Mvc\\DispatchListener  1  onDispatch  MvcEvent::EVENT_DISPATCH_ERROR  (if an exception is raised during dispatch processes)  Load and dispatch the matched controller from the service manager (and throws various exceptions if it does not).    Zend\\Mvc\\AbstractController  1  onDispatch  none  The  onDispatch  method of the  AbstractController  is an abstract method. In  AbstractActionController , for instance, it calls the action method.",
            "title": "All contexts"
        },
        {
            "location": "/mvc-event/#triggered-by_2",
            "text": "This event is triggered by the following classes:     Class  In Method  Description      Zend\\Mvc\\Application  run  Uses a short circuit callback to halt propagation of the event if an error is raised during routing.    Zend\\Mvc\\Controller\\AbstractController  dispatch  If a listener returns a  Response  object, it halts propagation. Note: every  AbstractController  listens to this event and executes the  onDispatch  method when it is triggered.",
            "title": "Triggered By"
        },
        {
            "location": "/mvc-event/#mvceventevent_dispatch_error-dispatcherror",
            "text": "",
            "title": "MvcEvent::EVENT_DISPATCH_ERROR (\"dispatch.error\")"
        },
        {
            "location": "/mvc-event/#listeners_3",
            "text": "The following classes listen to this event (sorted from higher priority to lower\npriority):",
            "title": "Listeners"
        },
        {
            "location": "/mvc-event/#console-context-only_1",
            "text": "The following listeners are only attached in a console context:     Class  Priority  Method Called  Description      Zend\\Mvc\\View\\Console\\RouteNotFoundStrategy  1  handleRouteNotFoundError  Detect if an error is a \"route not found\" condition. If a \u201ccontroller not found\u201d or \u201cinvalid controller\u201d error type is encountered, sets the response status code to 404.    Zend\\Mvc\\View\\Console\\ExceptionStrategy  1  prepareExceptionViewModel  Create an exception view model, and sets the status code to 404.    Zend\\Mvc\\View\\Console\\InjectViewModelListener  -100  injectViewModel  Inserts the  ViewModel  (in this case, a  ConsoleModel ) and adds it to the  MvcEvent  object. It either (a) adds it as a child to the default, composed view model, or (b) replaces it if the result is marked as terminable.",
            "title": "Console context only"
        },
        {
            "location": "/mvc-event/#http-context-only_1",
            "text": "The following listeners are only attached in an HTTP context:     Class  Priority  Method Called  Description      Zend\\Mvc\\View\\Http\\RouteNotFoundStrategy  1  detectNotFoundError  Detect if an error is a 404 condition. If a \u201ccontroller not found\u201d or \u201cinvalid controller\u201d error type is encountered, sets the response status code to 404.    Zend\\Mvc\\View\\Http\\RouteNotFoundStrategy  1  prepareNotFoundViewModel  Create and return a 404 view model.    Zend\\Mvc\\View\\Http\\ExceptionStrategy  1  prepareExceptionViewModel  Create an exception view model and set the status code to 404.    Zend\\Mvc\\View\\Http\\InjectViewModelListener  -100  injectViewModel  Inserts the  ViewModel  (in this case, a  ViewModel ) and adds it to the MvcEvent object. It either (a) adds it as a child to the default, composed view model, or (b) replaces it if the result is marked as terminable.",
            "title": "HTTP context only"
        },
        {
            "location": "/mvc-event/#all-contexts_1",
            "text": "The following listeners are attached for all contexts:     Class  Priority  Method Called  Description      Zend\\Mvc\\DispatchListener  1  reportMonitorEvent  Used for monitoring when Zend Server is used.",
            "title": "All contexts"
        },
        {
            "location": "/mvc-event/#triggered-by_3",
            "text": "Class  In Method      Zend\\Mvc\\MiddlewareListener  onDispatch    Zend\\Mvc\\DispatchListener  onDispatch    Zend\\Mvc\\DispatchListener  marshallControllerNotFoundEvent    Zend\\Mvc\\DispatchListener  marshallBadControllerEvent",
            "title": "Triggered By"
        },
        {
            "location": "/mvc-event/#mvceventevent_render-render",
            "text": "",
            "title": "MvcEvent::EVENT_RENDER (\"render\")"
        },
        {
            "location": "/mvc-event/#listeners_4",
            "text": "The following classes listen to this event (sorted from higher priority to lower\npriority):",
            "title": "Listeners"
        },
        {
            "location": "/mvc-event/#console-context-only_2",
            "text": "The following listeners are only attached in a console context:     Class  Priority  Method Called  Description      Zend\\Mvc\\View\\Console\\DefaultRenderingStrategy  -10000  render  Render the view.",
            "title": "Console context only"
        },
        {
            "location": "/mvc-event/#http-context-only_2",
            "text": "The following listeners are only attached in an HTTP context:     Class  Priority  Method Called  Description      Zend\\Mvc\\View\\Http\\DefaultRenderingStrategy  -10000  render  Render the view.",
            "title": "HTTP context only"
        },
        {
            "location": "/mvc-event/#triggered-by_4",
            "text": "This event is triggered by the following classes:     Class  In Method  Description      Zend\\Mvc\\Application  completeRequest  This event is triggered just before the  MvcEvent::FINISH  event.",
            "title": "Triggered By"
        },
        {
            "location": "/mvc-event/#mvceventevent_render_error-rendererror",
            "text": "",
            "title": "MvcEvent::EVENT_RENDER_ERROR (\"render.error\")"
        },
        {
            "location": "/mvc-event/#listeners_5",
            "text": "The following classes listen to this event (sorted from higher priority to lower\npriority):",
            "title": "Listeners"
        },
        {
            "location": "/mvc-event/#console-context-only_3",
            "text": "The following listeners are only attached in a console context:     Class  Priority  Method Called  Description      Zend\\Mvc\\View\\Console\\ExceptionStrategy  1  prepareExceptionViewModel  Create an exception view model and set the status code to 404.    Zend\\Mvc\\View\\Console\\InjectViewModelListener  -100  injectViewModel  Inserts the  ViewModel  (in this case, a  ConsoleModel ) and adds it to the  MvcEvent  object. It either (a) adds it as a child to the default, composed view model, or (b) replaces it if the result is marked as terminable.",
            "title": "Console context only"
        },
        {
            "location": "/mvc-event/#http-context-only_3",
            "text": "The following listeners are only attached in an HTTP context:     Class  Priority  Method Called  Description      Zend\\Mvc\\View\\Http\\ExceptionStrategy  1  prepareExceptionViewModel  Create an exception view model and set the status code to 404.    Zend\\Mvc\\View\\Http\\InjectViewModelListener  -100  injectViewModel  Inserts the  ViewModel  (in this case, a  ViewModel ) and adds it to the MvcEvent object. It either (a) adds it as a child to the default, composed view model, or (b) replaces it if the result is marked as terminable.    Zend\\Mvc\\View\\Http\\DefaultRenderingStrategy  -10000  render  Render the view",
            "title": "HTTP context only"
        },
        {
            "location": "/mvc-event/#triggered-by_5",
            "text": "This event is triggered by the following classes:     Class  In Method  Description      Zend\\Mvc\\View\\Http\\DefaultRenderingStrategy  render  This event is triggered if an exception is raised during rendering.",
            "title": "Triggered By"
        },
        {
            "location": "/mvc-event/#mvceventevent_finish-finish",
            "text": "",
            "title": "MvcEvent::EVENT_FINISH (\"finish\")"
        },
        {
            "location": "/mvc-event/#listeners_6",
            "text": "The following classes listen to this event (sorted from higher priority to lower\npriority):     Class  Priority  Method Called  Description      Zend\\Mvc\\SendResponseListener  -10000  sendResponse  Triggers the  SendResponseEvent  in order to prepare the response (see the next chapter for more information about  SendResponseEvent ).",
            "title": "Listeners"
        },
        {
            "location": "/mvc-event/#triggered-by_6",
            "text": "This event is triggered by the following classes:     Class  In Method  Description      Zend\\Mvc\\Application  run  This event is triggered once the  MvcEvent::ROUTE  event returns a correct  ResponseInterface .    Zend\\Mvc\\Application  run  This event is triggered once the  MvcEvent::DISPATCH  event returns a correct  ResponseInterface .    Zend\\Mvc\\Application  completeRequest  This event is triggered after  MvcEvent::RENDER  (at this point, the view is already rendered).",
            "title": "Triggered By"
        },
        {
            "location": "/send-response-event/",
            "text": "The SendResponse Event\n\n\nzend-mvc defines and utilizes a custom \nZend\\EventManager\\Event\n for updating\nthe response object prior to emitting it, \nZend\\Mvc\\ResponseSender\\SendResponseEvent\n.\nThe event allows listeners to set response headers and content.\n\n\nThe methods it defines are:\n\n\n\n\nsetResponse($response)\n\n\ngetResponse()\n\n\nsetContentSent()\n\n\ncontentSent()\n\n\nsetHeadersSent()\n\n\nheadersSent()\n\n\n\n\nListeners\n\n\nCurrently, three listeners are listening to this event at different priorities based on which\nlistener is used most.\n\n\n\n\n\n\n\n\nClass\n\n\nPriority\n\n\nMethod Called\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nZend\\Mvc\\SendResponseListener\\PhpEnvironmentResponseSender\n\n\n-1000\n\n\n__invoke\n\n\nThis is used in HTTP contexts (this is the most often used).\n\n\n\n\n\n\nZend\\Mvc\\SendResponseListener\\ConsoleResponseSender\n\n\n-2000\n\n\n__invoke\n\n\nThis is used in console contexts.\n\n\n\n\n\n\nZend\\Mvc\\SendResponseListener\\SimpleStreamResponseSender\n\n\n-3000\n\n\n__invoke\n\n\n\n\n\n\n\n\n\n\nBecause each listener has negative priority, adding your own logic to modify the\n\nResponse\n involves adding a new listener without priority (as priority defaults\nto 1); thus, your own listener will execute before any of the defaults.\n\n\nTriggered By\n\n\nThis event is executed when the \nMvcEvent::FINISH\n event is triggered, with a priority of -10000.",
            "title": "The SendResponse Event"
        },
        {
            "location": "/send-response-event/#the-sendresponse-event",
            "text": "zend-mvc defines and utilizes a custom  Zend\\EventManager\\Event  for updating\nthe response object prior to emitting it,  Zend\\Mvc\\ResponseSender\\SendResponseEvent .\nThe event allows listeners to set response headers and content.  The methods it defines are:   setResponse($response)  getResponse()  setContentSent()  contentSent()  setHeadersSent()  headersSent()",
            "title": "The SendResponse Event"
        },
        {
            "location": "/send-response-event/#listeners",
            "text": "Currently, three listeners are listening to this event at different priorities based on which\nlistener is used most.     Class  Priority  Method Called  Description      Zend\\Mvc\\SendResponseListener\\PhpEnvironmentResponseSender  -1000  __invoke  This is used in HTTP contexts (this is the most often used).    Zend\\Mvc\\SendResponseListener\\ConsoleResponseSender  -2000  __invoke  This is used in console contexts.    Zend\\Mvc\\SendResponseListener\\SimpleStreamResponseSender  -3000  __invoke      Because each listener has negative priority, adding your own logic to modify the Response  involves adding a new listener without priority (as priority defaults\nto 1); thus, your own listener will execute before any of the defaults.",
            "title": "Listeners"
        },
        {
            "location": "/send-response-event/#triggered-by",
            "text": "This event is executed when the  MvcEvent::FINISH  event is triggered, with a priority of -10000.",
            "title": "Triggered By"
        },
        {
            "location": "/controllers/",
            "text": "Available Controllers\n\n\nControllers in zend-mvc are objects implementing \nZend\\Stdlib\\DispatchableInterface\n.\nThat interface describes a single method:\n\n\nuse Zend\\Stdlib\\DispatchableInterface;\nuse Zend\\Stdlib\\RequestInterface as Request;\nuse Zend\\Stdlib\\ResponseInterface as Response;\n\nclass Foo implements DispatchableInterface\n{\n    public function dispatch(Request $request, Response $response = null)\n    {\n        // ... do something, and preferably return a Response ...\n    }\n}\n\n\n\nWhile the pattern is straight-forward, chances are you don't want to implement\ncustom dispatch logic for every controller, particularly as it's not unusual or\nuncommon for a single controller to handle several related types of requests.\n\n\nTo provide convenience, zend-mvc also defines several interfaces that, when\nimplemented, can provide controllers with additional capabilities.\n\n\nCommon Interfaces Used With Controllers\n\n\nInjectApplicationEvent\n\n\nThe \nZend\\Mvc\\InjectApplicationEventInterface\n hints to the \nApplication\n\ninstance that it should inject its \nMvcEvent\n into the controller itself. Why\nwould this be useful?\n\n\nRecall that the \nMvcEvent\n composes a number of objects: the \nRequest\n and\n\nResponse\n, naturally, but also the router, the route matches (a \nRouteMatch\n\ninstance), and potentially the \"result\" of dispatching.\n\n\nA controller that has the \nMvcEvent\n injected, then, can retrieve or inject\nthese. As an example:\n\n\n$matches = $this->getEvent()->getRouteMatch();\n$id      = $matches->getParam('id', false);\nif (! $id) {\n    $response = $this->getResponse();\n    $response->setStatusCode(500);\n    $this->getEvent()->setResult('Invalid identifier; cannot complete request');\n    return;\n}\n\n\n\nThe \nInjectApplicationEventInterface\n defines two methods:\n\n\npublic function setEvent(Zend\\EventManager\\EventInterface $event);\npublic function getEvent();\n\n\n\nServiceLocatorAware\n\n\nIn most cases, you should define your controllers such that dependencies are\ninjected by the application's \nServiceManager\n, via either constructor arguments\nor setter methods.\n\n\nHowever, occasionally you may have objects you wish to use in your controller\nthat are only valid for certain code paths. Examples include forms, paginators,\nnavigation, etc. In these cases, you may decide that it doesn't make sense to\ninject those objects every time the controller is used.\n\n\nThe \nServiceLocatorAwareInterface\n interface hints to the \nServiceManager\n that it should inject\nitself into the controller. It defines two simple methods:\n\n\nuse Zend\\ServiceManager\\ServiceLocatorInterface;\nuse Zend\\ServiceManager\\ServiceLocatorAwareInterface;\n\npublic function setServiceLocator(ServiceLocatorInterface $serviceLocator);\npublic function getServiceLocator();\n\n\n\n\n\nServiceLocatorInterface is deprecated\n\n\nServiceLocatorAwareInterface\n \nwas removed from zend-servicemanager v3.0\n,\nand, as such, starting in zend-mvc 2.7.0, the \nAbstractController\n\nimplementation no longer implements the interface, though it implements the\nmethods the interface defines; this allows forwards compatibility with\nzend-servicemanager v3.\n\n\nHowever, also starting with the zend-mvc 2.7.0 release, \nServiceLocatorAwareInterface\n\nusage is deprecated. We recommend injecting dependencies explicitly instead of\npulling them from a composed \nServiceManager\n instance.\n\n\nIn cases where an object will not be used in all code paths, we recommend\nsplitting into discrete controllers, or using \nlazy services\n.\n\n\n\n\nEventManagerAware\n\n\nTypically, it's nice to be able to tie into a controller's workflow without\nneeding to extend it or hardcode behavior into it. The solution for this is to\nuse the \nEventManager\n.\n\n\nYou can hint to the \nServiceManager\n that you want an \nEventManager\n injected by\nimplementing the interface \nEventManagerAwareInterface\n, which tells the\n\nServiceManager\n to inject an \nEventManager\n.\n\n\nTo do this, you define two methods. The first, a setter, should also set any\n\nSharedEventManager\n identifiers you want to listen on, and the second, a getter,\nshould return the composed \nEventManager\n instance.\n\n\nuse Zend\\EventManager\\EventManagerAwareInterface;\nuse Zend\\EventManager\\EventManagerInterface;\n\npublic function setEventManager(EventManagerInterface $events);\npublic function getEventManager();\n\n\n\nController Plugins\n\n\nCode re-use is a common goal for developers. Another common goal is convenience.\nHowever, this is often difficult to achieve cleanly in abstract, general\nsystems.\n\n\nWithin your controllers, you'll often find yourself repeating tasks from one\ncontroller to another.  Some common examples:\n\n\n\n\nGenerating URLs.\n\n\nRedirecting.\n\n\nSetting and retrieving flash messages (self-expiring session messages).\n\n\nInvoking and dispatching additional controllers.\n\n\n\n\nTo facilitate these actions while also making them available to alternate\ncontroller implementations, we've created a \nPluginManager\n implementation for\nthe controller layer, \nZend\\Mvc\\Controller\\PluginManager\n, building on the\n\nZend\\ServiceManager\\AbstractPluginManager\n functionality. To utilize it,\nimplement the \nsetPluginManager(PluginManager $plugins)\n method, and set up your\ncode to use the controller-specific implementation by default:\n\n\nuse Zend\\Mvc\\Controller\\PluginManager;\n\npublic function setPluginManager(PluginManager $plugins)\n{\n    $this->plugins = $plugins;\n    $this->plugins->setController($this);\n\n    return $this;\n}\n\npublic function getPluginManager()\n{\n    if (!$this->plugins) {\n        $this->setPluginManager(new PluginManager());\n    }\n\n    return $this->plugins;\n}\n\npublic function plugin($name, array $options = null)\n{\n    return $this->getPluginManager()->get($name, $options);\n}\n\n\n\nAbstractActionController\n\n\nImplementing each of the above interfaces is a lesson in redundancy; you won't\noften want to do it.  As such, we've developed abstract, base controllers you\ncan extend to get started.\n\n\nThe first is \nZend\\Mvc\\Controller\\AbstractActionController\n. This controller\nimplements each of the above interfaces, and uses the following assumptions:\n\n\n\n\nAn \"action\" parameter is expected in the \nRouteMatch\n object composed in the\n  attached \nMvcEvent\n.  If none is found, a \nnotFoundAction()\n is invoked.\n\n\nThe \"action\" parameter is converted to a camelCased format and appended with\n  the word \"Action\" to create a method name. As examples: \"foo\" maps to\n  \nfooAction\n, \"foo-bar\" or \"foo.bar\" or \"foo_bar\" to \nfooBarAction\n. The\n  controller then checks to see if that method exists. If not, the\n  \nnotFoundAction()\n method is invoked; otherwise, the discovered method is\n  called.\n\n\nThe results of executing the given action method are injected into the\n  \nMvcEvent\n's \"result\" property (via \nsetResult()\n, and accessible via\n  \ngetResult()\n).\n\n\n\n\nEssentially, a route mapping to an \nAbstractActionController\n needs to return\nboth the \"controller\" and \"action\" keys in its matches.\n\n\nCreation of action controllers looks like the following example:\n\n\nnamespace Foo\\Controller;\n\nuse Zend\\Mvc\\Controller\\AbstractActionController;\n\nclass BarController extends AbstractActionController\n{\n    public function bazAction()\n    {\n        return ['title' => __METHOD__];\n    }\n\n    public function batAction()\n    {\n        return ['title' => __METHOD__];\n    }\n}\n\n\n\nInterfaces and Collaborators\n\n\nAbstractActionController\n implements each of the following interfaces:\n\n\n\n\nZend\\Stdlib\\DispatchableInterface\n\n\nZend\\Mvc\\InjectApplicationEventInterface\n\n\nZend\\ServiceManager\\ServiceLocatorAwareInterface\n (starting with zend-mvc\n  2.7.0, only the methods defined by the interface, not the interface itself)\n\n\nZend\\EventManager\\EventManagerAwareInterface\n\n\n\n\nThe composed \nEventManager\n will be configured to listen on the following contexts:\n\n\n\n\nZend\\Stdlib\\DispatchableInterface\n\n\nZend\\Mvc\\Controller\\AbstractActionController\n\n\nZend\\Mvc\\Controller\\AbstractController\n\n\n\n\nAdditionally, if you extend the class, it will listen on the name of the\nextending class.\n\n\nAbstractRestfulController\n\n\nZend\\Mvc\\Controller\\AbstractRestfulController\n provides a native RESTful\nimplementation that maps HTTP request methods to controller methods, using the\nfollowing matrix:\n\n\n\n\nGET\n maps to either \nget()\n or \ngetList()\n, depending on whether or not an\n  \"id\" parameter is found in the route matches. If one is, it is passed as an\n  argument to \nget()\n; if not, \ngetList()\n is invoked. In the former case, you\n  should provide a representation of the given entity with that identification;\n  in the latter, you should provide a list of entities.\n\n\nPOST\n maps to \ncreate()\n. That method expects a \n$data\n argument, usually\n  the \n$_POST\n superglobal array. The data should be used to create a new\n  entity, and the response should typically be an HTTP 201 response with the\n  Location header indicating the URI of the newly created entity and the\n  response body providing the representation.\n\n\nPUT\n maps to \nupdate()\n, and requires that an \"id\" parameter exists in the\n  route matches; that value is passed as an argument to the method. It should\n  attempt to update the given entity, and, if successful, return either a 200 or\n  202 response status, as well as the representation of the entity.\n\n\nDELETE\n maps to \ndelete()\n, and requires that an \"id\" parameter exists in\n  the route matches; that value is passed as an argument to the method. It\n  should attempt to delete the given entity, and, if successful, return either a\n  200 or 204 response status.\n\n\n\n\nAdditionally, you can map \"action\" methods to the \nAbstractRestfulController\n,\njust as you would in the \nAbstractActionController\n; these methods will be\nsuffixed with \"Action\", differentiating them from the RESTful methods listed\nabove. This allows you to perform such actions as providing forms used to submit\nto the various RESTful methods, or to add RPC methods to your RESTful API.\n\n\nInterfaces and Collaborators\n\n\nAbstractRestfulController\n implements each of the following interfaces:\n\n\n\n\nZend\\Stdlib\\DispatchableInterface\n\n\nZend\\Mvc\\InjectApplicationEventInterface\n\n\nZend\\ServiceManager\\ServiceLocatorAwareInterface\n (starting with zend-mvc\n  2.7.0, only the methods defined by the interface, not the interface itself)\n\n\nZend\\EventManager\\EventManagerAwareInterface\n\n\n\n\nThe composed \nEventManager\n will be configured to listen on the following contexts:\n\n\n\n\nZend\\Stdlib\\DispatchableInterface\n\n\nZend\\Mvc\\Controller\\AbstractRestfulController\n\n\nZend\\Mvc\\Controller\\AbstractController\n\n\n\n\nAdditionally, if you extend the class, it will listen on the name of the\nextending class.\n\n\nAbstractConsoleController\n\n\n\n\nFor version 3, the integration component \nzend-mvc-console\n must be installed. It can be done via Composer:\n\n`bash\ncomposer require zendframework/zend-mvc-console\n\nIf you are not using the component installer, you will need to \nadd this component as a module\n.\n\n\n\n\nZend\\Mvc\\Console\\Controller\\AbstractConsoleController\n extends from \nAbstractActionController\n\nand provides the following functionality:\n\n\n\n\nThe method \nsetConsole(Zend\\Console\\Adapter\\AdapterInterface $console)\n allows\n  injecting a console adapter representing the current console environment. By\n  default, the \nControllerManager\n will inject this for you as part of\n  controller instantiation.\n\n\nThe method \ngetConsole()\n allows you to retrieve the current console adapter\n  instance, allowing you to retrieve console capabilities and generate console\n  output.\n\n\nThe \ndispatch()\n method will throw an exception if invoked in a non-console\n  environment, ensuring that you do not need to do any checks within your action\n  methods for the environment.\n\n\n\n\nInterfaces and Collaborators\n\n\nAbstractRestfulController\n implements each of the following interfaces:\n\n\n\n\nZend\\Stdlib\\DispatchableInterface\n\n\nZend\\Mvc\\InjectApplicationEventInterface\n\n\nZend\\ServiceManager\\ServiceLocatorAwareInterface\n (starting with zend-mvc\n  2.7.0, only the methods defined by the interface, not the interface itself)\n\n\nZend\\EventManager\\EventManagerAwareInterface\n\n\n\n\nThe composed \nEventManager\n will be configured to listen on the following contexts:\n\n\n\n\nZend\\Stdlib\\DispatchableInterface\n\n\nZend\\Mvc\\Console\\Controller\\AbstractConsoleController\n\n\nZend\\Mvc\\Controller\\AbstractActionController\n\n\nZend\\Mvc\\Controller\\AbstractController\n\n\n\n\nAdditionally, if you extend the class, it will listen on the name of the\nextending class.",
            "title": "Available Controllers"
        },
        {
            "location": "/controllers/#available-controllers",
            "text": "Controllers in zend-mvc are objects implementing  Zend\\Stdlib\\DispatchableInterface .\nThat interface describes a single method:  use Zend\\Stdlib\\DispatchableInterface;\nuse Zend\\Stdlib\\RequestInterface as Request;\nuse Zend\\Stdlib\\ResponseInterface as Response;\n\nclass Foo implements DispatchableInterface\n{\n    public function dispatch(Request $request, Response $response = null)\n    {\n        // ... do something, and preferably return a Response ...\n    }\n}  While the pattern is straight-forward, chances are you don't want to implement\ncustom dispatch logic for every controller, particularly as it's not unusual or\nuncommon for a single controller to handle several related types of requests.  To provide convenience, zend-mvc also defines several interfaces that, when\nimplemented, can provide controllers with additional capabilities.",
            "title": "Available Controllers"
        },
        {
            "location": "/controllers/#common-interfaces-used-with-controllers",
            "text": "",
            "title": "Common Interfaces Used With Controllers"
        },
        {
            "location": "/controllers/#injectapplicationevent",
            "text": "The  Zend\\Mvc\\InjectApplicationEventInterface  hints to the  Application \ninstance that it should inject its  MvcEvent  into the controller itself. Why\nwould this be useful?  Recall that the  MvcEvent  composes a number of objects: the  Request  and Response , naturally, but also the router, the route matches (a  RouteMatch \ninstance), and potentially the \"result\" of dispatching.  A controller that has the  MvcEvent  injected, then, can retrieve or inject\nthese. As an example:  $matches = $this->getEvent()->getRouteMatch();\n$id      = $matches->getParam('id', false);\nif (! $id) {\n    $response = $this->getResponse();\n    $response->setStatusCode(500);\n    $this->getEvent()->setResult('Invalid identifier; cannot complete request');\n    return;\n}  The  InjectApplicationEventInterface  defines two methods:  public function setEvent(Zend\\EventManager\\EventInterface $event);\npublic function getEvent();",
            "title": "InjectApplicationEvent"
        },
        {
            "location": "/controllers/#servicelocatoraware",
            "text": "In most cases, you should define your controllers such that dependencies are\ninjected by the application's  ServiceManager , via either constructor arguments\nor setter methods.  However, occasionally you may have objects you wish to use in your controller\nthat are only valid for certain code paths. Examples include forms, paginators,\nnavigation, etc. In these cases, you may decide that it doesn't make sense to\ninject those objects every time the controller is used.  The  ServiceLocatorAwareInterface  interface hints to the  ServiceManager  that it should inject\nitself into the controller. It defines two simple methods:  use Zend\\ServiceManager\\ServiceLocatorInterface;\nuse Zend\\ServiceManager\\ServiceLocatorAwareInterface;\n\npublic function setServiceLocator(ServiceLocatorInterface $serviceLocator);\npublic function getServiceLocator();",
            "title": "ServiceLocatorAware"
        },
        {
            "location": "/controllers/#servicelocatorinterface-is-deprecated",
            "text": "ServiceLocatorAwareInterface   was removed from zend-servicemanager v3.0 ,\nand, as such, starting in zend-mvc 2.7.0, the  AbstractController \nimplementation no longer implements the interface, though it implements the\nmethods the interface defines; this allows forwards compatibility with\nzend-servicemanager v3.  However, also starting with the zend-mvc 2.7.0 release,  ServiceLocatorAwareInterface \nusage is deprecated. We recommend injecting dependencies explicitly instead of\npulling them from a composed  ServiceManager  instance.  In cases where an object will not be used in all code paths, we recommend\nsplitting into discrete controllers, or using  lazy services .",
            "title": "ServiceLocatorInterface is deprecated"
        },
        {
            "location": "/controllers/#eventmanageraware",
            "text": "Typically, it's nice to be able to tie into a controller's workflow without\nneeding to extend it or hardcode behavior into it. The solution for this is to\nuse the  EventManager .  You can hint to the  ServiceManager  that you want an  EventManager  injected by\nimplementing the interface  EventManagerAwareInterface , which tells the ServiceManager  to inject an  EventManager .  To do this, you define two methods. The first, a setter, should also set any SharedEventManager  identifiers you want to listen on, and the second, a getter,\nshould return the composed  EventManager  instance.  use Zend\\EventManager\\EventManagerAwareInterface;\nuse Zend\\EventManager\\EventManagerInterface;\n\npublic function setEventManager(EventManagerInterface $events);\npublic function getEventManager();",
            "title": "EventManagerAware"
        },
        {
            "location": "/controllers/#controller-plugins",
            "text": "Code re-use is a common goal for developers. Another common goal is convenience.\nHowever, this is often difficult to achieve cleanly in abstract, general\nsystems.  Within your controllers, you'll often find yourself repeating tasks from one\ncontroller to another.  Some common examples:   Generating URLs.  Redirecting.  Setting and retrieving flash messages (self-expiring session messages).  Invoking and dispatching additional controllers.   To facilitate these actions while also making them available to alternate\ncontroller implementations, we've created a  PluginManager  implementation for\nthe controller layer,  Zend\\Mvc\\Controller\\PluginManager , building on the Zend\\ServiceManager\\AbstractPluginManager  functionality. To utilize it,\nimplement the  setPluginManager(PluginManager $plugins)  method, and set up your\ncode to use the controller-specific implementation by default:  use Zend\\Mvc\\Controller\\PluginManager;\n\npublic function setPluginManager(PluginManager $plugins)\n{\n    $this->plugins = $plugins;\n    $this->plugins->setController($this);\n\n    return $this;\n}\n\npublic function getPluginManager()\n{\n    if (!$this->plugins) {\n        $this->setPluginManager(new PluginManager());\n    }\n\n    return $this->plugins;\n}\n\npublic function plugin($name, array $options = null)\n{\n    return $this->getPluginManager()->get($name, $options);\n}",
            "title": "Controller Plugins"
        },
        {
            "location": "/controllers/#abstractactioncontroller",
            "text": "Implementing each of the above interfaces is a lesson in redundancy; you won't\noften want to do it.  As such, we've developed abstract, base controllers you\ncan extend to get started.  The first is  Zend\\Mvc\\Controller\\AbstractActionController . This controller\nimplements each of the above interfaces, and uses the following assumptions:   An \"action\" parameter is expected in the  RouteMatch  object composed in the\n  attached  MvcEvent .  If none is found, a  notFoundAction()  is invoked.  The \"action\" parameter is converted to a camelCased format and appended with\n  the word \"Action\" to create a method name. As examples: \"foo\" maps to\n   fooAction , \"foo-bar\" or \"foo.bar\" or \"foo_bar\" to  fooBarAction . The\n  controller then checks to see if that method exists. If not, the\n   notFoundAction()  method is invoked; otherwise, the discovered method is\n  called.  The results of executing the given action method are injected into the\n   MvcEvent 's \"result\" property (via  setResult() , and accessible via\n   getResult() ).   Essentially, a route mapping to an  AbstractActionController  needs to return\nboth the \"controller\" and \"action\" keys in its matches.  Creation of action controllers looks like the following example:  namespace Foo\\Controller;\n\nuse Zend\\Mvc\\Controller\\AbstractActionController;\n\nclass BarController extends AbstractActionController\n{\n    public function bazAction()\n    {\n        return ['title' => __METHOD__];\n    }\n\n    public function batAction()\n    {\n        return ['title' => __METHOD__];\n    }\n}",
            "title": "AbstractActionController"
        },
        {
            "location": "/controllers/#interfaces-and-collaborators",
            "text": "AbstractActionController  implements each of the following interfaces:   Zend\\Stdlib\\DispatchableInterface  Zend\\Mvc\\InjectApplicationEventInterface  Zend\\ServiceManager\\ServiceLocatorAwareInterface  (starting with zend-mvc\n  2.7.0, only the methods defined by the interface, not the interface itself)  Zend\\EventManager\\EventManagerAwareInterface   The composed  EventManager  will be configured to listen on the following contexts:   Zend\\Stdlib\\DispatchableInterface  Zend\\Mvc\\Controller\\AbstractActionController  Zend\\Mvc\\Controller\\AbstractController   Additionally, if you extend the class, it will listen on the name of the\nextending class.",
            "title": "Interfaces and Collaborators"
        },
        {
            "location": "/controllers/#abstractrestfulcontroller",
            "text": "Zend\\Mvc\\Controller\\AbstractRestfulController  provides a native RESTful\nimplementation that maps HTTP request methods to controller methods, using the\nfollowing matrix:   GET  maps to either  get()  or  getList() , depending on whether or not an\n  \"id\" parameter is found in the route matches. If one is, it is passed as an\n  argument to  get() ; if not,  getList()  is invoked. In the former case, you\n  should provide a representation of the given entity with that identification;\n  in the latter, you should provide a list of entities.  POST  maps to  create() . That method expects a  $data  argument, usually\n  the  $_POST  superglobal array. The data should be used to create a new\n  entity, and the response should typically be an HTTP 201 response with the\n  Location header indicating the URI of the newly created entity and the\n  response body providing the representation.  PUT  maps to  update() , and requires that an \"id\" parameter exists in the\n  route matches; that value is passed as an argument to the method. It should\n  attempt to update the given entity, and, if successful, return either a 200 or\n  202 response status, as well as the representation of the entity.  DELETE  maps to  delete() , and requires that an \"id\" parameter exists in\n  the route matches; that value is passed as an argument to the method. It\n  should attempt to delete the given entity, and, if successful, return either a\n  200 or 204 response status.   Additionally, you can map \"action\" methods to the  AbstractRestfulController ,\njust as you would in the  AbstractActionController ; these methods will be\nsuffixed with \"Action\", differentiating them from the RESTful methods listed\nabove. This allows you to perform such actions as providing forms used to submit\nto the various RESTful methods, or to add RPC methods to your RESTful API.",
            "title": "AbstractRestfulController"
        },
        {
            "location": "/controllers/#interfaces-and-collaborators_1",
            "text": "AbstractRestfulController  implements each of the following interfaces:   Zend\\Stdlib\\DispatchableInterface  Zend\\Mvc\\InjectApplicationEventInterface  Zend\\ServiceManager\\ServiceLocatorAwareInterface  (starting with zend-mvc\n  2.7.0, only the methods defined by the interface, not the interface itself)  Zend\\EventManager\\EventManagerAwareInterface   The composed  EventManager  will be configured to listen on the following contexts:   Zend\\Stdlib\\DispatchableInterface  Zend\\Mvc\\Controller\\AbstractRestfulController  Zend\\Mvc\\Controller\\AbstractController   Additionally, if you extend the class, it will listen on the name of the\nextending class.",
            "title": "Interfaces and Collaborators"
        },
        {
            "location": "/controllers/#abstractconsolecontroller",
            "text": "For version 3, the integration component  zend-mvc-console  must be installed. It can be done via Composer: `bash\ncomposer require zendframework/zend-mvc-console \nIf you are not using the component installer, you will need to  add this component as a module .   Zend\\Mvc\\Console\\Controller\\AbstractConsoleController  extends from  AbstractActionController \nand provides the following functionality:   The method  setConsole(Zend\\Console\\Adapter\\AdapterInterface $console)  allows\n  injecting a console adapter representing the current console environment. By\n  default, the  ControllerManager  will inject this for you as part of\n  controller instantiation.  The method  getConsole()  allows you to retrieve the current console adapter\n  instance, allowing you to retrieve console capabilities and generate console\n  output.  The  dispatch()  method will throw an exception if invoked in a non-console\n  environment, ensuring that you do not need to do any checks within your action\n  methods for the environment.",
            "title": "AbstractConsoleController"
        },
        {
            "location": "/controllers/#interfaces-and-collaborators_2",
            "text": "AbstractRestfulController  implements each of the following interfaces:   Zend\\Stdlib\\DispatchableInterface  Zend\\Mvc\\InjectApplicationEventInterface  Zend\\ServiceManager\\ServiceLocatorAwareInterface  (starting with zend-mvc\n  2.7.0, only the methods defined by the interface, not the interface itself)  Zend\\EventManager\\EventManagerAwareInterface   The composed  EventManager  will be configured to listen on the following contexts:   Zend\\Stdlib\\DispatchableInterface  Zend\\Mvc\\Console\\Controller\\AbstractConsoleController  Zend\\Mvc\\Controller\\AbstractActionController  Zend\\Mvc\\Controller\\AbstractController   Additionally, if you extend the class, it will listen on the name of the\nextending class.",
            "title": "Interfaces and Collaborators"
        },
        {
            "location": "/plugins/",
            "text": "Controller Plugins\n\n\nWhen using any of the abstract controller implementations shipped with zend-mvc,\nor if you implement the \nsetPluginManager\n method in your custom controllers,\nyou have access to a number of pre-built plugins. Additionally, you can register\nyour own custom plugins with the manager.\n\n\nThe built-in plugins are:\n\n\n\n\nZend\\Mvc\\Controller\\Plugin\\AcceptableViewModelSelector\n\n\nZend\\Mvc\\Controller\\Plugin\\Forward\n\n\nZend\\Mvc\\Controller\\Plugin\\Layout\n\n\nZend\\Mvc\\Controller\\Plugin\\Params\n\n\nZend\\Mvc\\Controller\\Plugin\\Redirect\n\n\nZend\\Mvc\\Controller\\Plugin\\Url\n\n\n\n\nIf your controller implements the \nsetPluginManager()\n, \ngetPluginManager()\n and\n\nplugin()\n methods, you can access these using their shortname via the \nplugin()\n\nmethod:\n\n\n$plugin = $this->plugin('url');\n\n\n\nFor an extra layer of convenience, this shipped abstract controller\nimplementations have \n__call()\n methods defined that allow you to retrieve\nplugins via method calls:\n\n\n$plugin = $this->url();\n\n\n\nAcceptableViewModelSelector Plugin\n\n\nThe \nAcceptableViewModelSelector\n is a helper that can be used to select an\nappropriate view model based on user defined criteria will be tested against the\nAccept header in the request.\n\n\nAs an example:\n\n\nuse Zend\\Mvc\\Controller\\AbstractActionController;\n\nclass SomeController extends AbstractActionController\n{\n    protected $acceptCriteria = [\n        \\Zend\\View\\Model\\ViewModel::class => [\n            'text/html',\n            'application/xhtml+xml',\n        ],\n        \\Zend\\View\\Model\\JsonModel::class => [\n            'application/json',\n            'application/javascript',\n        ],\n        \\Zend\\View\\Model\\FeedModel::class => [\n            'application/rss+xml',\n            'application/atom+xml',\n        ],\n    ];\n\n    public function apiAction()\n    {\n        $viewModel = $this->acceptableViewModelSelector($this->acceptCriteria);\n\n        // Potentially vary execution based on model returned\n        if ($viewModel instanceof \\Zend\\View\\Model\\JsonModel) {\n            // ...\n        }\n    }\n}\n\n\n\nThe above would return a standard \nZend\\View\\Model\\ViewModel\n instance if no\ncriterias are met, and the specified view model types if a specific criteria\nis met. Rules are matched in order, with the first match \"winning\".\nMake sure to put your fallback view model \nfirst\n as a fallback for unknown\ncontent types or \n*/*\n.\n\n\n\n\nBrowsers are sending \n*/*\n as last content type of the Accept header so you have to define every\nacceptable view model and their content type.\n\n\n\n\nForward Plugin\n\n\nOccasionally, you may want to dispatch additional controllers from within the\nmatched controller. For example, you might use this approach to build up\n\"widgetized\" content. The \nForward\n plugin helps enable this.\n\n\nFor the \nForward\n plugin to work, the controller calling it must be\n\nServiceLocatorAware\n; otherwise, the plugin will be unable to retrieve a\nconfigured and injected instance of the requested controller.\n\n\nThe plugin exposes a single method, \ndispatch()\n, which takes two arguments:\n\n\n\n\n$name\n, the name of the controller to invoke. This may be either the fully\n  qualified class name, or an alias defined and recognized by the\n  \nServiceManager\n instance attached to the invoking controller.\n\n\n$params\n is an optional array of parameters with which to seed a \nRouteMatch\n\n  object for purposes of this specific request. Meaning the parameters will be\n  matched by their key to the routing identifiers in the config (otherwise\n  non-matching keys are ignored)\n\n\n\n\nForward\n returns the results of dispatching the requested controller; it is up\nto the developer to determine what, if anything, to do with those results. One\nrecommendation is to aggregate them in any return value from the invoking\ncontroller.\n\n\nAs an example:\n\n\n$foo = $this->forward()->dispatch('foo', ['action' => 'process']);\nreturn [\n    'somekey' => $somevalue,\n    'foo'     => $foo,\n];\n\n\n\nLayout Plugin\n\n\nThe \nLayout\n plugin allows changing layout templates from within controller actions.\n\n\nIt exposes a single method, \nsetTemplate()\n, which takes one argument,\n\n$template\n, the name of the template to set.\n\n\nAs an example:\n\n\n$this->layout()->setTemplate('layout/newlayout');\n\n\n\nIt also implements the \n__invoke\n magic method, which allows calling the plugin\nas a method call:\n\n\n$this->layout('layout/newlayout');\n\n\n\nParams Plugin\n\n\nThe \nParams\n plugin allows accessing parameters in actions from different sources.\n\n\nIt exposes several methods, one for each parameter source:\n\n\n\n\n\n\nfromFiles(string $name = null, mixed $default = null): array|ArrayAccess|null\n:\n  For retrieving all or one single \nfile\n. If \n$name\n is null, all files will\n  be returned.\n\n\n\n\n\n\nfromHeader(string $header = null, mixed $default = null) : null|Zend\\Http\\Header\\HeaderInterface\n:\n  For retrieving all or one single \nheader\n parameter. If \n$header\n is null,\n  all header parameters will be returned.\n\n\n\n\n\n\nfromPost(string $param = null, mixed $default = null) : mixed\n: For\n  retrieving all or one single \npost\n parameter. If \n$param\n is null, all post\n  parameters will be returned.\n\n\n\n\n\n\nfromQuery(string $param = null, mixed $default = null) : mixed\n: For\n  retrieving all or one single \nquery\n parameter. If \n$param\n is null, all\n  query parameters will be returned.\n\n\n\n\n\n\nfromRoute(string $param = null, mixed $default = null) : mixed\n: For\n  retrieving all or one single \nroute\n parameter. If \n$param\n is null, all\n  route parameters will be returned.\n\n\n\n\n\n\nThe plugin also implements the \n__invoke\n magic method, providing a shortcut\nfor invoking the \nfromRoute\n method:\n\n\n$this->params()->fromRoute('param', $default);\n// or\n$this->params('param', $default);\n\n\n\nRedirect Plugin\n\n\nRedirections are quite common operations within applications. If done manually,\nyou will need to do the following steps:\n\n\n\n\nAssemble a url using the router.\n\n\nCreate and inject a \"Location\" header into the \nResponse\n object, pointing to\n  the assembled URL.\n\n\nSet the status code of the \nResponse\n object to one of the 3xx HTTP statuses.\n\n\n\n\nThe \nRedirect\n plugin does this work for you. It offers three methods:\n\n\n\n\n\n\ntoRoute(string $route = null, array $params = array(), array $options = array(), boolean $reuseMatchedParams = false) : Zend\\Http\\Response\n:\n  Redirects to a named route, using the provided \n$params\n and \n$options\n to\n  assembled the URL.\n\n\n\n\n\n\ntoUrl(string $url) : Zend\\Http\\Response\n: Simply redirects to the given URL.\n\n\n\n\n\n\nrefresh() : Zend\\Http\\Response\n: Refresh to current route.\n\n\n\n\n\n\nIn each case, the \nResponse\n object is returned. If you return this immediately,\nyou can effectively short-circuit execution of the request.\n\n\n\n\nRequires MvcEvent\n\n\nThis plugin requires that the controller invoking it implements\n\nInjectApplicationEventInterface\n, and thus has an \nMvcEvent\n composed, as it\nretrieves the router from the event object.\n\n\n\n\nAs an example:\n\n\nreturn $this->redirect()->toRoute('login-success');\n\n\n\nUrl Plugin\n\n\nYou may need to generate URLs from route definitions within your controllers;\nfor example, to seed the view, generate headers, etc. While the \nMvcEvent\n\nobject composes the router, doing so manually would require this workflow:\n\n\n$router = $this->getEvent()->getRouter();\n$url    = $router->assemble($params, ['name' => 'route-name']);\n\n\n\nThe \nUrl\n helper makes this slightly more convenient:\n\n\n$url = $this->url()->fromRoute('route-name', $params);\n\n\n\nThe \nfromRoute()\n method is the only public method defined, and is used to\ngenerate a URL string from the provided parameters. It has the following\nsignature:\n\n\n\n\nfromRoute(string $route = null, array $params = [], array $options = [], bool $reuseMatchedParams = false): string\n, where:\n\n\n$name\n: the name of the route to use for URL generation.\n\n\n$params\n: Any parameter substitutions to use with the named route.\n\n\n$options\n: Options used by the router when generating the URL (e.g., \nforce_canonical\n, \nquery\n, etc.).\n\n\n$reuseMatchedParams\n: Whether or not to use route match parameters from the\n    current URL when generating the new URL. This will only affect cases where\n    the specified \n$name\n matches the currently matched route; the default is\n    \ntrue\n.\n\n\n\n\n\n\nRequires MvcEvent\n\n\nThis plugin requires that the controller invoking it implements\n\nInjectApplicationEventInterface\n, and thus has an \nMvcEvent\n composed, as it\nretrieves the router from the event object.",
            "title": "Controller Plugins"
        },
        {
            "location": "/plugins/#controller-plugins",
            "text": "When using any of the abstract controller implementations shipped with zend-mvc,\nor if you implement the  setPluginManager  method in your custom controllers,\nyou have access to a number of pre-built plugins. Additionally, you can register\nyour own custom plugins with the manager.  The built-in plugins are:   Zend\\Mvc\\Controller\\Plugin\\AcceptableViewModelSelector  Zend\\Mvc\\Controller\\Plugin\\Forward  Zend\\Mvc\\Controller\\Plugin\\Layout  Zend\\Mvc\\Controller\\Plugin\\Params  Zend\\Mvc\\Controller\\Plugin\\Redirect  Zend\\Mvc\\Controller\\Plugin\\Url   If your controller implements the  setPluginManager() ,  getPluginManager()  and plugin()  methods, you can access these using their shortname via the  plugin() \nmethod:  $plugin = $this->plugin('url');  For an extra layer of convenience, this shipped abstract controller\nimplementations have  __call()  methods defined that allow you to retrieve\nplugins via method calls:  $plugin = $this->url();",
            "title": "Controller Plugins"
        },
        {
            "location": "/plugins/#acceptableviewmodelselector-plugin",
            "text": "The  AcceptableViewModelSelector  is a helper that can be used to select an\nappropriate view model based on user defined criteria will be tested against the\nAccept header in the request.  As an example:  use Zend\\Mvc\\Controller\\AbstractActionController;\n\nclass SomeController extends AbstractActionController\n{\n    protected $acceptCriteria = [\n        \\Zend\\View\\Model\\ViewModel::class => [\n            'text/html',\n            'application/xhtml+xml',\n        ],\n        \\Zend\\View\\Model\\JsonModel::class => [\n            'application/json',\n            'application/javascript',\n        ],\n        \\Zend\\View\\Model\\FeedModel::class => [\n            'application/rss+xml',\n            'application/atom+xml',\n        ],\n    ];\n\n    public function apiAction()\n    {\n        $viewModel = $this->acceptableViewModelSelector($this->acceptCriteria);\n\n        // Potentially vary execution based on model returned\n        if ($viewModel instanceof \\Zend\\View\\Model\\JsonModel) {\n            // ...\n        }\n    }\n}  The above would return a standard  Zend\\View\\Model\\ViewModel  instance if no\ncriterias are met, and the specified view model types if a specific criteria\nis met. Rules are matched in order, with the first match \"winning\".\nMake sure to put your fallback view model  first  as a fallback for unknown\ncontent types or  */* .   Browsers are sending  */*  as last content type of the Accept header so you have to define every\nacceptable view model and their content type.",
            "title": "AcceptableViewModelSelector Plugin"
        },
        {
            "location": "/plugins/#forward-plugin",
            "text": "Occasionally, you may want to dispatch additional controllers from within the\nmatched controller. For example, you might use this approach to build up\n\"widgetized\" content. The  Forward  plugin helps enable this.  For the  Forward  plugin to work, the controller calling it must be ServiceLocatorAware ; otherwise, the plugin will be unable to retrieve a\nconfigured and injected instance of the requested controller.  The plugin exposes a single method,  dispatch() , which takes two arguments:   $name , the name of the controller to invoke. This may be either the fully\n  qualified class name, or an alias defined and recognized by the\n   ServiceManager  instance attached to the invoking controller.  $params  is an optional array of parameters with which to seed a  RouteMatch \n  object for purposes of this specific request. Meaning the parameters will be\n  matched by their key to the routing identifiers in the config (otherwise\n  non-matching keys are ignored)   Forward  returns the results of dispatching the requested controller; it is up\nto the developer to determine what, if anything, to do with those results. One\nrecommendation is to aggregate them in any return value from the invoking\ncontroller.  As an example:  $foo = $this->forward()->dispatch('foo', ['action' => 'process']);\nreturn [\n    'somekey' => $somevalue,\n    'foo'     => $foo,\n];",
            "title": "Forward Plugin"
        },
        {
            "location": "/plugins/#layout-plugin",
            "text": "The  Layout  plugin allows changing layout templates from within controller actions.  It exposes a single method,  setTemplate() , which takes one argument, $template , the name of the template to set.  As an example:  $this->layout()->setTemplate('layout/newlayout');  It also implements the  __invoke  magic method, which allows calling the plugin\nas a method call:  $this->layout('layout/newlayout');",
            "title": "Layout Plugin"
        },
        {
            "location": "/plugins/#params-plugin",
            "text": "The  Params  plugin allows accessing parameters in actions from different sources.  It exposes several methods, one for each parameter source:    fromFiles(string $name = null, mixed $default = null): array|ArrayAccess|null :\n  For retrieving all or one single  file . If  $name  is null, all files will\n  be returned.    fromHeader(string $header = null, mixed $default = null) : null|Zend\\Http\\Header\\HeaderInterface :\n  For retrieving all or one single  header  parameter. If  $header  is null,\n  all header parameters will be returned.    fromPost(string $param = null, mixed $default = null) : mixed : For\n  retrieving all or one single  post  parameter. If  $param  is null, all post\n  parameters will be returned.    fromQuery(string $param = null, mixed $default = null) : mixed : For\n  retrieving all or one single  query  parameter. If  $param  is null, all\n  query parameters will be returned.    fromRoute(string $param = null, mixed $default = null) : mixed : For\n  retrieving all or one single  route  parameter. If  $param  is null, all\n  route parameters will be returned.    The plugin also implements the  __invoke  magic method, providing a shortcut\nfor invoking the  fromRoute  method:  $this->params()->fromRoute('param', $default);\n// or\n$this->params('param', $default);",
            "title": "Params Plugin"
        },
        {
            "location": "/plugins/#redirect-plugin",
            "text": "Redirections are quite common operations within applications. If done manually,\nyou will need to do the following steps:   Assemble a url using the router.  Create and inject a \"Location\" header into the  Response  object, pointing to\n  the assembled URL.  Set the status code of the  Response  object to one of the 3xx HTTP statuses.   The  Redirect  plugin does this work for you. It offers three methods:    toRoute(string $route = null, array $params = array(), array $options = array(), boolean $reuseMatchedParams = false) : Zend\\Http\\Response :\n  Redirects to a named route, using the provided  $params  and  $options  to\n  assembled the URL.    toUrl(string $url) : Zend\\Http\\Response : Simply redirects to the given URL.    refresh() : Zend\\Http\\Response : Refresh to current route.    In each case, the  Response  object is returned. If you return this immediately,\nyou can effectively short-circuit execution of the request.",
            "title": "Redirect Plugin"
        },
        {
            "location": "/plugins/#requires-mvcevent",
            "text": "This plugin requires that the controller invoking it implements InjectApplicationEventInterface , and thus has an  MvcEvent  composed, as it\nretrieves the router from the event object.   As an example:  return $this->redirect()->toRoute('login-success');",
            "title": "Requires MvcEvent"
        },
        {
            "location": "/plugins/#url-plugin",
            "text": "You may need to generate URLs from route definitions within your controllers;\nfor example, to seed the view, generate headers, etc. While the  MvcEvent \nobject composes the router, doing so manually would require this workflow:  $router = $this->getEvent()->getRouter();\n$url    = $router->assemble($params, ['name' => 'route-name']);  The  Url  helper makes this slightly more convenient:  $url = $this->url()->fromRoute('route-name', $params);  The  fromRoute()  method is the only public method defined, and is used to\ngenerate a URL string from the provided parameters. It has the following\nsignature:   fromRoute(string $route = null, array $params = [], array $options = [], bool $reuseMatchedParams = false): string , where:  $name : the name of the route to use for URL generation.  $params : Any parameter substitutions to use with the named route.  $options : Options used by the router when generating the URL (e.g.,  force_canonical ,  query , etc.).  $reuseMatchedParams : Whether or not to use route match parameters from the\n    current URL when generating the new URL. This will only affect cases where\n    the specified  $name  matches the currently matched route; the default is\n     true .",
            "title": "Url Plugin"
        },
        {
            "location": "/plugins/#requires-mvcevent_1",
            "text": "This plugin requires that the controller invoking it implements InjectApplicationEventInterface , and thus has an  MvcEvent  composed, as it\nretrieves the router from the event object.",
            "title": "Requires MvcEvent"
        },
        {
            "location": "/examples/",
            "text": "Examples\n\n\nControllers\n\n\nAccessing the Request and Response\n\n\nWhen using one of the abstract controller implementations, the request and\nresponse object are composed directly into the controller as soon as\n\ndispatch()\n is called. You may access them as follows:\n\n\n// Using explicit accessor methods\n$request  = $this->getRequest();\n$response = $this->getResponse();\n\n// Using direct property access\n$request  = $this->request;\n$response = $this->response;\n\n\n\nAdditionally, if your controller implements \nInjectApplicationEventInterface\n\n(as all shipped abstract controllers do), you can access these objects from the\nattached \nMvcEvent\n:\n\n\n$event    = $this->getEvent();\n$request  = $event->getRequest();\n$response = $event->getResponse();\n\n\n\nThe above can be useful when composing event listeners into your controller.\n\n\nAccessing routing parameters\n\n\nThe parameters returned when routing completes are wrapped in a\n\nZend\\Router\\RouteMatch\n object.  This object is detailed in the section on\n\nRouting\n.\n\n\nWithin your controller, if you implement \nInjectApplicationEventInterface\n (as\nall shipped abstract controllers do), you can access this object from the\nattached \nMvcEvent\n:\n\n\n$event   = $this->getEvent();\n$matches = $event->getRouteMatch();\n\n\n\nOnce you have the \nRouteMatch\n object, you can pull parameters from it.\n\n\nThe same can be done using the \nParams plugin\n.\n\n\nReturning early\n\n\nYou can short-circuit execution of the application at any point by returning a\n\nResponse\n from your controller or any event. When such a value is discovered,\nit halts further execution of the event manager, bubbling up to the\n\nApplication\n instance, where it is immediately returned.\n\n\nAs an example, the \nRedirect\n plugin returns a \nResponse\n, which can be returned\nimmediately so as to complete the request as quickly as possible. Other use\ncases might be for returning JSON or XML results from web service endpoints,\nreturning \"401 Unauthorized\" results, etc.\n\n\nBootstrapping\n\n\nRegistering module-specific listeners\n\n\nYou may want module-specific listeners; these allow you to introduce\nauthorization, logging, caching, or other concerns into your application.\n\n\nEach \nModule\n class can have an optional \nonBootstrap()\n method. This method is\nused for module-specific configuration, and is the ideal location to setup event\nlisteners for you module. The \nonBootstrap()\n method is called for \nevery\n\nmodule on \nevery\n page request and should \nonly\n be used for performing\n\nlightweight\n tasks such as registering event listeners.\n\n\nThe base \nApplication\n class shipped with the framework has an \nEventManager\n\nassociated with it, and once the modules are initialized, it triggers the\n\nbootstrap\n event, which\nprovides a \ngetApplication()\n method on the event.\n\n\nOne way to accomplish module-specific listeners is to listen to that event, and\nregister listeners at that time. As an example:\n\n\nnamespace SomeCustomModule;\n\nclass Module\n{\n    /**\n     * @param  \\Zend\\Mvc\\MvcEvent $e The MvcEvent instance\n     * @return void\n     */\n    public function onBootstrap($e)\n    {\n        $application = $e->getApplication();\n        $config      = $application->getConfig();\n        $view        = $application->getServiceManager()->get('ViewHelperManager');\n        // You must have these keys in you application config\n        $view->headTitle($config['view']['base_title']);\n\n        // This is your custom listener\n        $listener   = new Listeners\\ViewListener();\n        $listener->setView($view);\n        $listener->attach($application->getEventManager());\n    }\n}\n\n\n\nThe above demonstrates several things. First, it demonstrates a listener on the\napplication's \nbootstrap\n event\n(the \nonBootstrap()\n method). Second, it demonstrates that listener, and how it\ncan be used to register listeners with the application. It grabs the\n\nApplication\n instance; from the \nApplication\n, it is able to grab the attached\nservice manager and configuration. These are then used to retrieve the view,\nconfigure some helpers, and then register a listener aggregate with the\napplication event manager.",
            "title": "Examples"
        },
        {
            "location": "/examples/#examples",
            "text": "",
            "title": "Examples"
        },
        {
            "location": "/examples/#controllers",
            "text": "",
            "title": "Controllers"
        },
        {
            "location": "/examples/#accessing-the-request-and-response",
            "text": "When using one of the abstract controller implementations, the request and\nresponse object are composed directly into the controller as soon as dispatch()  is called. You may access them as follows:  // Using explicit accessor methods\n$request  = $this->getRequest();\n$response = $this->getResponse();\n\n// Using direct property access\n$request  = $this->request;\n$response = $this->response;  Additionally, if your controller implements  InjectApplicationEventInterface \n(as all shipped abstract controllers do), you can access these objects from the\nattached  MvcEvent :  $event    = $this->getEvent();\n$request  = $event->getRequest();\n$response = $event->getResponse();  The above can be useful when composing event listeners into your controller.",
            "title": "Accessing the Request and Response"
        },
        {
            "location": "/examples/#accessing-routing-parameters",
            "text": "The parameters returned when routing completes are wrapped in a Zend\\Router\\RouteMatch  object.  This object is detailed in the section on Routing .  Within your controller, if you implement  InjectApplicationEventInterface  (as\nall shipped abstract controllers do), you can access this object from the\nattached  MvcEvent :  $event   = $this->getEvent();\n$matches = $event->getRouteMatch();  Once you have the  RouteMatch  object, you can pull parameters from it.  The same can be done using the  Params plugin .",
            "title": "Accessing routing parameters"
        },
        {
            "location": "/examples/#returning-early",
            "text": "You can short-circuit execution of the application at any point by returning a Response  from your controller or any event. When such a value is discovered,\nit halts further execution of the event manager, bubbling up to the Application  instance, where it is immediately returned.  As an example, the  Redirect  plugin returns a  Response , which can be returned\nimmediately so as to complete the request as quickly as possible. Other use\ncases might be for returning JSON or XML results from web service endpoints,\nreturning \"401 Unauthorized\" results, etc.",
            "title": "Returning early"
        },
        {
            "location": "/examples/#bootstrapping",
            "text": "",
            "title": "Bootstrapping"
        },
        {
            "location": "/examples/#registering-module-specific-listeners",
            "text": "You may want module-specific listeners; these allow you to introduce\nauthorization, logging, caching, or other concerns into your application.  Each  Module  class can have an optional  onBootstrap()  method. This method is\nused for module-specific configuration, and is the ideal location to setup event\nlisteners for you module. The  onBootstrap()  method is called for  every \nmodule on  every  page request and should  only  be used for performing lightweight  tasks such as registering event listeners.  The base  Application  class shipped with the framework has an  EventManager \nassociated with it, and once the modules are initialized, it triggers the bootstrap  event, which\nprovides a  getApplication()  method on the event.  One way to accomplish module-specific listeners is to listen to that event, and\nregister listeners at that time. As an example:  namespace SomeCustomModule;\n\nclass Module\n{\n    /**\n     * @param  \\Zend\\Mvc\\MvcEvent $e The MvcEvent instance\n     * @return void\n     */\n    public function onBootstrap($e)\n    {\n        $application = $e->getApplication();\n        $config      = $application->getConfig();\n        $view        = $application->getServiceManager()->get('ViewHelperManager');\n        // You must have these keys in you application config\n        $view->headTitle($config['view']['base_title']);\n\n        // This is your custom listener\n        $listener   = new Listeners\\ViewListener();\n        $listener->setView($view);\n        $listener->attach($application->getEventManager());\n    }\n}  The above demonstrates several things. First, it demonstrates a listener on the\napplication's  bootstrap  event\n(the  onBootstrap()  method). Second, it demonstrates that listener, and how it\ncan be used to register listeners with the application. It grabs the Application  instance; from the  Application , it is able to grab the attached\nservice manager and configuration. These are then used to retrieve the view,\nconfigure some helpers, and then register a listener aggregate with the\napplication event manager.",
            "title": "Registering module-specific listeners"
        },
        {
            "location": "/middleware/",
            "text": "Dispatching PSR-7 Middleware\n\n\nPSR-7\n defines interfaces for HTTP messages,\nand is now being adopted by many frameworks; Zend Framework itself offers a\nparallel microframework targeting PSR-7 with \nExpressive\n.\nWhat if you want to dispatch PSR-7 middleware from zend-mvc?\n\n\nzend-mvc currently uses \nzend-http\n\nfor its HTTP transport layer, and the objects it defines are not compatible with\nPSR-7, meaning the basic MVC layer does not and cannot make use of PSR-7\ncurrently.\n\n\nHowever, starting with version 2.7.0, zend-mvc offers\n\nZend\\Mvc\\MiddlewareListener\n. This \ndispatch\n\nlistener listens prior to the default \nDispatchListener\n, and executes if the\nroute matches contain a \"middleware\" parameter, and the service that resolves to\nis callable. When those conditions are met, it uses the \nPSR-7 bridge\n\nto convert the zend-http request and response objects into PSR-7 instances, and\nthen invokes the middleware.\n\n\nMapping routes to middleware\n\n\nThe first step is to map a route to PSR-7 middleware. This looks like any other\n\nrouting\n configuration, with one small change: instead of providing\na \"controller\" in the routing defaults, you provide \"middleware\":\n\n\n// Via configuration:\nreturn [\n    'router' =>\n        'routes' => [\n            'home' => [\n                'type' => 'literal',\n                'options' => [\n                    'route' => '/',\n                    'defaults' => [\n                        'middleware' => 'Application\\Middleware\\IndexMiddleware',\n                    ],\n                ],\n            ],\n        ],\n    ],\n];\n\n// Manually:\n$route = Literal::factory([\n    'route' => '/',\n    'defaults' => [\n        'middleware' => 'Application\\Middleware\\IndexMiddleware',\n    ],\n]);\n\n\n\nMiddleware may be provided as PHP callables, or as service names.\n\n\nAs of 3.1.0\n you may also specify an \narray\n of middleware, and middleware\nmay be \nhttp-interop/http-middleware\n\ncompatible. Each item in the array must be a PHP callable, service name, or\nhttp-middleware instance. These will then be piped into a\n\nZend\\Stratigility\\MiddlewarePipe\n instance in the order in which they are\npresent in the array.\n\n\n\n\nNo action required\n\n\nUnlike action controllers, middleware typically is single purpose, and, as\nsuch, does not require a default \naction\n parameter.\n\n\n\n\nMiddleware services\n\n\nIn a normal zend-mvc dispatch cycle, controllers are pulled from a dedicated\n\nControllerManager\n. Middleware, however, are pulled from the application\nservice manager.\n\n\nMiddleware retrieved \nmust\n be PHP callables. The \nMiddlewareListener\n will\ncreate an error response if non-callable middleware is indicated.\n\n\nWriting middleware\n\n\nPrior to 3.1.0, when dispatching middleware, the \nMiddlewareListener\n calls it\nwith two arguments, the PSR-7 request and response, respectively. As such, your\nmiddleware signature should look like the following:\n\n\nnamespace Application\\Middleware;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass IndexMiddleware\n{\n    public function __invoke(ServerRequestInterface $request, ResponseInterface $response)\n    {\n        // do some work\n    }\n}\n\n\n\nStarting in 3.1.0, the \nMiddlewareListener\n always adds middleware to a\n\nZend\\Stratigility\\MiddlewarePipe\n instance, and invokes it as\n\nhttp-interop/http-middleware\n,\npassing it a PSR-7 \nServerRequestInterface\n and an http-interop\n\nDelegateInterface\n.\n\n\nAs such, ideally your middleware should implement the \nMiddlewareInterface\n from\n\nhttp-interop/http-middleware\n:\n\n\nnamespace Application\\Middleware;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass IndexMiddleware implements MiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // do some work\n    }\n}\n\n\n\nAlternately, you may still write \ncallable\n middleware using the following\nsignature:\n\n\nfunction (ServerREquestInterface $request, ResponseInterface $response, callable $next)\n{\n    // do some work\n}\n\n\n\nIn the above case, the \nDelegateInterface\n is decorated as a callable.\n\n\nIn all versions, within your middleware, you can pull information from the\ncomposed request, and return a response.\n\n\n\n\nRouting parameters\n\n\nAt the time of the 2.7.0 release, route match parameters were not yet injected\ninto the PSR-7 \nServerRequest\n instance, and thus not available as request\nattributes.\n\n\nWith the 3.0 release, they are pushed into the PSR-7 \nServerRequest\n as\nattributes, and may thus be fetched using\n\n$request->getAttribute($attributeName)\n.\n\n\n\n\nMiddleware return values\n\n\nIdeally, your middleware should return a PSR-7 response. When it does, it is\nconverted back to a zend-http response and returned by the \nMiddlewareListener\n,\ncausing the application to short-circuit and return the response immediately.\n\n\nYou can, however, return arbitrary values. If you do, the result is pushed into\nthe \nMvcEvent\n as the event result, allowing later dispatch listeners to\nmanipulate the results.",
            "title": "Dispatching PSR-7 Middleware"
        },
        {
            "location": "/middleware/#dispatching-psr-7-middleware",
            "text": "PSR-7  defines interfaces for HTTP messages,\nand is now being adopted by many frameworks; Zend Framework itself offers a\nparallel microframework targeting PSR-7 with  Expressive .\nWhat if you want to dispatch PSR-7 middleware from zend-mvc?  zend-mvc currently uses  zend-http \nfor its HTTP transport layer, and the objects it defines are not compatible with\nPSR-7, meaning the basic MVC layer does not and cannot make use of PSR-7\ncurrently.  However, starting with version 2.7.0, zend-mvc offers Zend\\Mvc\\MiddlewareListener . This  dispatch \nlistener listens prior to the default  DispatchListener , and executes if the\nroute matches contain a \"middleware\" parameter, and the service that resolves to\nis callable. When those conditions are met, it uses the  PSR-7 bridge \nto convert the zend-http request and response objects into PSR-7 instances, and\nthen invokes the middleware.",
            "title": "Dispatching PSR-7 Middleware"
        },
        {
            "location": "/middleware/#mapping-routes-to-middleware",
            "text": "The first step is to map a route to PSR-7 middleware. This looks like any other routing  configuration, with one small change: instead of providing\na \"controller\" in the routing defaults, you provide \"middleware\":  // Via configuration:\nreturn [\n    'router' =>\n        'routes' => [\n            'home' => [\n                'type' => 'literal',\n                'options' => [\n                    'route' => '/',\n                    'defaults' => [\n                        'middleware' => 'Application\\Middleware\\IndexMiddleware',\n                    ],\n                ],\n            ],\n        ],\n    ],\n];\n\n// Manually:\n$route = Literal::factory([\n    'route' => '/',\n    'defaults' => [\n        'middleware' => 'Application\\Middleware\\IndexMiddleware',\n    ],\n]);  Middleware may be provided as PHP callables, or as service names.  As of 3.1.0  you may also specify an  array  of middleware, and middleware\nmay be  http-interop/http-middleware \ncompatible. Each item in the array must be a PHP callable, service name, or\nhttp-middleware instance. These will then be piped into a Zend\\Stratigility\\MiddlewarePipe  instance in the order in which they are\npresent in the array.",
            "title": "Mapping routes to middleware"
        },
        {
            "location": "/middleware/#no-action-required",
            "text": "Unlike action controllers, middleware typically is single purpose, and, as\nsuch, does not require a default  action  parameter.",
            "title": "No action required"
        },
        {
            "location": "/middleware/#middleware-services",
            "text": "In a normal zend-mvc dispatch cycle, controllers are pulled from a dedicated ControllerManager . Middleware, however, are pulled from the application\nservice manager.  Middleware retrieved  must  be PHP callables. The  MiddlewareListener  will\ncreate an error response if non-callable middleware is indicated.",
            "title": "Middleware services"
        },
        {
            "location": "/middleware/#writing-middleware",
            "text": "Prior to 3.1.0, when dispatching middleware, the  MiddlewareListener  calls it\nwith two arguments, the PSR-7 request and response, respectively. As such, your\nmiddleware signature should look like the following:  namespace Application\\Middleware;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass IndexMiddleware\n{\n    public function __invoke(ServerRequestInterface $request, ResponseInterface $response)\n    {\n        // do some work\n    }\n}  Starting in 3.1.0, the  MiddlewareListener  always adds middleware to a Zend\\Stratigility\\MiddlewarePipe  instance, and invokes it as http-interop/http-middleware ,\npassing it a PSR-7  ServerRequestInterface  and an http-interop DelegateInterface .  As such, ideally your middleware should implement the  MiddlewareInterface  from http-interop/http-middleware :  namespace Application\\Middleware;\n\nuse Interop\\Http\\ServerMiddleware\\DelegateInterface;\nuse Interop\\Http\\ServerMiddleware\\MiddlewareInterface;\nuse Psr\\Http\\Message\\ServerRequestInterface;\n\nclass IndexMiddleware implements MiddlewareInterface\n{\n    public function process(ServerRequestInterface $request, DelegateInterface $delegate)\n    {\n        // do some work\n    }\n}  Alternately, you may still write  callable  middleware using the following\nsignature:  function (ServerREquestInterface $request, ResponseInterface $response, callable $next)\n{\n    // do some work\n}  In the above case, the  DelegateInterface  is decorated as a callable.  In all versions, within your middleware, you can pull information from the\ncomposed request, and return a response.",
            "title": "Writing middleware"
        },
        {
            "location": "/middleware/#routing-parameters",
            "text": "At the time of the 2.7.0 release, route match parameters were not yet injected\ninto the PSR-7  ServerRequest  instance, and thus not available as request\nattributes.  With the 3.0 release, they are pushed into the PSR-7  ServerRequest  as\nattributes, and may thus be fetched using $request->getAttribute($attributeName) .",
            "title": "Routing parameters"
        },
        {
            "location": "/middleware/#middleware-return-values",
            "text": "Ideally, your middleware should return a PSR-7 response. When it does, it is\nconverted back to a zend-http response and returned by the  MiddlewareListener ,\ncausing the application to short-circuit and return the response immediately.  You can, however, return arbitrary values. If you do, the result is pushed into\nthe  MvcEvent  as the event result, allowing later dispatch listeners to\nmanipulate the results.",
            "title": "Middleware return values"
        },
        {
            "location": "/migration/",
            "text": "Migration\n\n\nWhile we strive to keep functionality backwards compatible between releases,\noccasionally we need to break features in order to fix critical or security\nissues. Additionally, in order to signal upcoming changes, we will introduce\ndeprecation notices or add forwards-compatibility features to assist you in\nmigration.\n\n\nThe chapters in this section document these changes.\n\n\n\n\nMigrating from v2.X to v2.7\n\n\nMigrating to v3.0",
            "title": "Migration Overview"
        },
        {
            "location": "/migration/#migration",
            "text": "While we strive to keep functionality backwards compatible between releases,\noccasionally we need to break features in order to fix critical or security\nissues. Additionally, in order to signal upcoming changes, we will introduce\ndeprecation notices or add forwards-compatibility features to assist you in\nmigration.  The chapters in this section document these changes.   Migrating from v2.X to v2.7  Migrating to v3.0",
            "title": "Migration"
        },
        {
            "location": "/migration/to-v2-7/",
            "text": "Upgrading to 2.7\n\n\nMiddleware\n\n\nzend-mvc now registers \nZend\\Mvc\\MiddlewareListener\n as a dispatch listener at\na priority higher than \nZend\\Mvc\\DispatchListener\n, allowing dispatch of\n\nPSR-7\n middleware. Read the\n\nmiddleware chapter\n for details on how to use this new feature.\n\n\nApplication\n\n\nThe constructor signature of \nZend\\Mvc\\Application\n has changed. Previously, it\nwas:\n\n\n__construct($configuration, ServiceManager $serviceManager)\n\n\n\nand internally, it pulled the services \nEventManager\n, \nRequest\n, and \nResponse\n\nfrom the provided \n$serviceManager\n during initialization.\n\n\nThe new constructor signature provides optional arguments for injecting the\nevent manager, request, and response:\n\n\n__construct(\n    $configuration,\n    ServiceManager $serviceManager,\n    EventManager $events = null,\n    RequestInterface $request = null,\n    ResponseInterface $response = null\n)\n\n\n\nThis change makes all dependencies explicit. Starting in v3.0, the new arguments\nwill be \nrequired\n.\n\n\nThe factory \nZend\\Mvc\\Service\\ApplicationFactory\n was updated to follow the new\nsignature.\n\n\nThis change should only affect users who are manually instantiating the\n\nApplication\n instance.\n\n\nEventManagerAware initializers\n\n\nzend-mvc provides two mechanisms for injecting event managers into\n\nEventManagerAware\n objects. One is the \"EventManagerAwareInitializer\"\nregistered in \nZend\\Mvc\\Service\\ServiceManagerConfig\n, and the other is the\n\nZend\\Mvc\\Controller\\ControllerManager::injectEventManager()\n initializer. In\nboth cases, the logic was updated to be forwards compatible with\nzend-eventmanager v3.\n\n\nPreviously each would check if the instance's \ngetEventManager()\n method\nreturned an event manager instance, and, if so, inject the shared event manager:\n\n\n$events = $instance->getEventManager();\nif ($events instanceof EventManagerInterface) {\n    $events->setSharedManager($container->get('SharedEventManager'));\n}\n\n\n\nIn zend-eventmanager v3, event managers are now injected with the shared\nmanager at instantiation, and no setter exists for providing the shared manager.\nAs such, the above logic changed to:\n\n\n$events = $instance->getEventManager();\nif (! $events || ! $events->getSharedManager()) {\n    $instance->setEventManager($container->get('EventManager'));\n}\n\n\n\nIn other words, it re-injects with a new event manager instance if the instance\npulled does not have a shared manager composed.\n\n\nThis likely will not cause regressions in existing code, but may be something to\nbe aware of if you were previously depending on lazy-loaded event manager\nstate.\n\n\nServiceLocatorAware initializers\n\n\nzend-servicemanager v3.0 removes \nZend\\ServiceManager\\ServiceLocatorAwareInterface\n.\nSince zend-mvc provides initializers around that interface, they needed updates\nto allow both forwards compatibility with zend-servicemanager v3 as well as\nbackwards compatibility with existing applications.\n\n\nThis was accomplished in two ways:\n\n\n\n\nThe abstract controller implementations no longer implement\n  \nServiceLocatorAwareInterface\n, but continue to define the methods that the\n  interface defines (namely \nsetServiceLocator()\n and \ngetServiceLocator()\n.\n\n\nThe initializers registered by \nZend\\Mvc\\Service\\ServiceManagerConfig\n and\n  \nZend\\Mvc\\Controller\\ControllerManager\n now use duck-typing to determine if\n  an instance requires container injection; if so it will do so.\n\n\n\n\nHowever, we also maintain that service locator injection is an anti-pattern;\ndependencies should be injected directly into instances instead. As such,\nstarting in 2.7.0, we now emit a deprecation notice any time an instance is\ninjected by one of these initializers, and we plan to remove the initializers\nfor version 3.0. The deprecation notice includes the name of the class, to help\nyou identify what instances you will need to update before the zend-mvc v3\nrelease.\n\n\nTo prepare your code, you will need to do the following within your controller:\n\n\n\n\nFind all cases where you call \ngetServiceLocator()\n, and identify the services\n  they retrieve.\n\n\nUpdate your controller to accept these services via the constructor.\n\n\nIf you have not already, create a factory class for your controller.\n\n\nIn the factory, pull the appropriate services and pass them to the\n  controller's constructor.\n\n\n\n\nAs an example, consider the following code from a controller:\n\n\n$db = $this->getServiceLcoator()->get('Db\\ApplicationAdapter');\n\n\n\nTo update your controller, you will:\n\n\n\n\nAdd a \n$db\n property to your class.\n\n\nUpdate the constructor to accept the database adapter and assign it to the\n  \n$db\n property.\n\n\nChange the above line to either read \n$db = $this->db;\n \nor just use the\n  property directly\n.\n\n\nAdd a factory that pulls the service and pushes it into the controller.\n\n\n\n\nThe controller then might look like the following:\n\n\nuse Zend\\Db\\Adapter\\AdapterInterface;\nuse Zend\\Mvc\\Controller\\AbstractActionController;\n\nclass YourController extends AbstractActionController\n{\n    private $db;\n\n    public function __construct(AdapterInterface $db)\n    {\n        $this->db = $db;\n    }\n\n    public function someAction()\n    {\n        $results = $this->db->query(/* ... */);\n        /* ... */\n    }\n}\n\n\n\nA factory would look like the following:\n\n\nuse Interop\\Container\\ContainerInterface;\n\nclass YourControllerFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        return new YourController($container->get('Db\\ApplicationAdapter'));\n    }\n}\n\n\n\nYou then also need to ensure the controller manager knows about the factory. It\nlikely already does, as an invokable; you will redefine it as a factory in\nyour \nmodule.config.php\n:\n\n\nreturn [\n    'controllers' => [\n        'factories' => [\n            YourController::class => YourControllerFactory::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n    /* ... */\n];\n\n\n\nWhile this may seem like more steps, doing so ensures your code has no hidden\ndependencies, improves the testability of your code, and allows you to substitute\nalternatives for either the dependencies or the controller itself.\n\n\nOptional dependencies\n\n\nIn some cases, you may have dependencies that are only required for some\nexecution paths, such as forms, database adapters, etc. In these cases, you have\ntwo approaches you can use:\n\n\n\n\nSplit your controller into separate responsibilities, and use the more\n  specific controllers. This way you don't need to inject dependencies that are\n  only used in some actions. (We recommend doing this regardless, as it helps\n  keep your code more maintainable.)\n\n\nUse \nlazy services\n.\n  When you configure these, zend-servicemanager gives you a proxy instance that,\n  on first access, loads the full service. This allows you to delay the most\n  expensive operations until absolutely needed.",
            "title": "v2.X to v2.7"
        },
        {
            "location": "/migration/to-v2-7/#upgrading-to-27",
            "text": "",
            "title": "Upgrading to 2.7"
        },
        {
            "location": "/migration/to-v2-7/#middleware",
            "text": "zend-mvc now registers  Zend\\Mvc\\MiddlewareListener  as a dispatch listener at\na priority higher than  Zend\\Mvc\\DispatchListener , allowing dispatch of PSR-7  middleware. Read the middleware chapter  for details on how to use this new feature.",
            "title": "Middleware"
        },
        {
            "location": "/migration/to-v2-7/#application",
            "text": "The constructor signature of  Zend\\Mvc\\Application  has changed. Previously, it\nwas:  __construct($configuration, ServiceManager $serviceManager)  and internally, it pulled the services  EventManager ,  Request , and  Response \nfrom the provided  $serviceManager  during initialization.  The new constructor signature provides optional arguments for injecting the\nevent manager, request, and response:  __construct(\n    $configuration,\n    ServiceManager $serviceManager,\n    EventManager $events = null,\n    RequestInterface $request = null,\n    ResponseInterface $response = null\n)  This change makes all dependencies explicit. Starting in v3.0, the new arguments\nwill be  required .  The factory  Zend\\Mvc\\Service\\ApplicationFactory  was updated to follow the new\nsignature.  This change should only affect users who are manually instantiating the Application  instance.",
            "title": "Application"
        },
        {
            "location": "/migration/to-v2-7/#eventmanageraware-initializers",
            "text": "zend-mvc provides two mechanisms for injecting event managers into EventManagerAware  objects. One is the \"EventManagerAwareInitializer\"\nregistered in  Zend\\Mvc\\Service\\ServiceManagerConfig , and the other is the Zend\\Mvc\\Controller\\ControllerManager::injectEventManager()  initializer. In\nboth cases, the logic was updated to be forwards compatible with\nzend-eventmanager v3.  Previously each would check if the instance's  getEventManager()  method\nreturned an event manager instance, and, if so, inject the shared event manager:  $events = $instance->getEventManager();\nif ($events instanceof EventManagerInterface) {\n    $events->setSharedManager($container->get('SharedEventManager'));\n}  In zend-eventmanager v3, event managers are now injected with the shared\nmanager at instantiation, and no setter exists for providing the shared manager.\nAs such, the above logic changed to:  $events = $instance->getEventManager();\nif (! $events || ! $events->getSharedManager()) {\n    $instance->setEventManager($container->get('EventManager'));\n}  In other words, it re-injects with a new event manager instance if the instance\npulled does not have a shared manager composed.  This likely will not cause regressions in existing code, but may be something to\nbe aware of if you were previously depending on lazy-loaded event manager\nstate.",
            "title": "EventManagerAware initializers"
        },
        {
            "location": "/migration/to-v2-7/#servicelocatoraware-initializers",
            "text": "zend-servicemanager v3.0 removes  Zend\\ServiceManager\\ServiceLocatorAwareInterface .\nSince zend-mvc provides initializers around that interface, they needed updates\nto allow both forwards compatibility with zend-servicemanager v3 as well as\nbackwards compatibility with existing applications.  This was accomplished in two ways:   The abstract controller implementations no longer implement\n   ServiceLocatorAwareInterface , but continue to define the methods that the\n  interface defines (namely  setServiceLocator()  and  getServiceLocator() .  The initializers registered by  Zend\\Mvc\\Service\\ServiceManagerConfig  and\n   Zend\\Mvc\\Controller\\ControllerManager  now use duck-typing to determine if\n  an instance requires container injection; if so it will do so.   However, we also maintain that service locator injection is an anti-pattern;\ndependencies should be injected directly into instances instead. As such,\nstarting in 2.7.0, we now emit a deprecation notice any time an instance is\ninjected by one of these initializers, and we plan to remove the initializers\nfor version 3.0. The deprecation notice includes the name of the class, to help\nyou identify what instances you will need to update before the zend-mvc v3\nrelease.  To prepare your code, you will need to do the following within your controller:   Find all cases where you call  getServiceLocator() , and identify the services\n  they retrieve.  Update your controller to accept these services via the constructor.  If you have not already, create a factory class for your controller.  In the factory, pull the appropriate services and pass them to the\n  controller's constructor.   As an example, consider the following code from a controller:  $db = $this->getServiceLcoator()->get('Db\\ApplicationAdapter');  To update your controller, you will:   Add a  $db  property to your class.  Update the constructor to accept the database adapter and assign it to the\n   $db  property.  Change the above line to either read  $db = $this->db;   or just use the\n  property directly .  Add a factory that pulls the service and pushes it into the controller.   The controller then might look like the following:  use Zend\\Db\\Adapter\\AdapterInterface;\nuse Zend\\Mvc\\Controller\\AbstractActionController;\n\nclass YourController extends AbstractActionController\n{\n    private $db;\n\n    public function __construct(AdapterInterface $db)\n    {\n        $this->db = $db;\n    }\n\n    public function someAction()\n    {\n        $results = $this->db->query(/* ... */);\n        /* ... */\n    }\n}  A factory would look like the following:  use Interop\\Container\\ContainerInterface;\n\nclass YourControllerFactory\n{\n    public function __invoke(ContainerInterface $container)\n    {\n        return new YourController($container->get('Db\\ApplicationAdapter'));\n    }\n}  You then also need to ensure the controller manager knows about the factory. It\nlikely already does, as an invokable; you will redefine it as a factory in\nyour  module.config.php :  return [\n    'controllers' => [\n        'factories' => [\n            YourController::class => YourControllerFactory::class,\n            /* ... */\n        ],\n        /* ... */\n    ],\n    /* ... */\n];  While this may seem like more steps, doing so ensures your code has no hidden\ndependencies, improves the testability of your code, and allows you to substitute\nalternatives for either the dependencies or the controller itself.",
            "title": "ServiceLocatorAware initializers"
        },
        {
            "location": "/migration/to-v2-7/#optional-dependencies",
            "text": "In some cases, you may have dependencies that are only required for some\nexecution paths, such as forms, database adapters, etc. In these cases, you have\ntwo approaches you can use:   Split your controller into separate responsibilities, and use the more\n  specific controllers. This way you don't need to inject dependencies that are\n  only used in some actions. (We recommend doing this regardless, as it helps\n  keep your code more maintainable.)  Use  lazy services .\n  When you configure these, zend-servicemanager gives you a proxy instance that,\n  on first access, loads the full service. This allows you to delay the most\n  expensive operations until absolutely needed.",
            "title": "Optional dependencies"
        },
        {
            "location": "/migration/to-v3-0/",
            "text": "Upgrading to 3.0\n\n\nWith the release of Zend Framework 2, all components current at that time,\nregardless of history, were tagged as v2 releases; in reality, it was the first\nversion of a new framework, as it was a completely new architecture from Zend\nFramework 1. As such, zend-mvc 3.0 marks the second major release of the\ncomponent.\n\n\nThe primary goal for version 3 was to reduce the number of dependencies, and to\nsplit out unrelated, tangential, or extension functionality. As such, there are\na number of changes that will impact users.\n\n\nDependency reduction\n\n\nIn order to remove dependencies, we needed to provide alternate ways to ensure\nthat default functionality, such as service registration and event listener\nattachment, could still occur.\n\n\nThe solution to this problem was to expose each component as a module. This\nhowever, raised another problem: you now have to register components as modules\nin your application.\n\n\nTo solve this new problem, we created a new component,\n\nzend-component-installer\n.\nInstall this in your application now:\n\n\n$ composer require --dev zendframework/zend-component-installer\n\n\n\nOnce installed, the component acts as a Composer plugin, and will intercept\npackages marked as components or Zend Framework modules, and register them with\nyour application configuration. Components are pushed to the top of the module\nlist, while modules are pushed to the end. As a development component, it will\nnot be installed in your production distributions.\n\n\nUpdated dependencies\n\n\nThe v3 release now \nrequires\n:\n\n\n\n\nzend-http\n\n\nzend-modulemanager\n\n\nzend-router\n\n\nzend-view\n\n\n\n\nAdditionally, the following components require their v3 releases:\n\n\n\n\nzend-eventmanager\n\n\nzend-servicemanager\n\n\nzend-stdlib\n\n\n\n\nThe minimum supported PHP version was bumped to 5.6.\n\n\nApplication class\n\n\nThe following changes were made to the \nZend\\Mvc\\Application\n constructor:\n\n\n\n\nThe first \n$configuration\n argument was removed, as it was not used.\n\n\nThree additional, optional arguments were added:\n\n\nZend\\EventManager\\EventManagerInterface $events = null\n\n\nZend\\Stdlib\\RequestInterface $request = null\n\n\nZend\\Stdlib\\ResponseInterface $response = null\n\n\n\n\nEnd-users using the skeleton application and the default \nApplication\n factory\nwill not notice a change. Those who are directly instantiating the \nApplication\n\ninstance (in production or test code) or who have created their own factory for\nthe class will need to update their code.\n\n\nsend method\n\n\nThe \nsend()\n method has been deprecated since the 2.2 release, and a no-op since\nthen as well. It is removed starting with the v3 release.\n\n\nControllerLoader\n\n\nThe \nControllerLoader\n service was deprecated early in the v2 lifecycle, and\naliased to \nControllerManager\n. The \nControllerLoader\n factory was kept to\nprevent BC breaks due to extending the class.\n\n\nv3 removes the \nControllerLoaderFactory\n, as well as the \nControllerLoader\n\nservice alias.\n\n\nDI-ServiceManager integration\n\n\nThe integration between \nzend-servicemanager\n and\n\nzend-di\n has been moved to a new\nstandalone component, \nzend-servicemanager-di\n.\nIn most cases, installing the component will restore the original behavior:\n\n\n$ composer require zendframework/zend-servicemanager-di\n\n\n\n\n\nManual installation\n\n\nThe above assumes you're using the new component installer detailed in the\n\ndependency reduction\n section, above. If you are not,\nyou will need to inject the zend-servicemanager-di module into your\napplication manually; follow the \ninstructions in the zend-servicemanager-di documentation\n\nto do so.\n\n\n\n\nThe new component also contains a \nmigration document\n\ndetailing potential issues for users migrating to version 3.\n\n\nDispatchListener\n\n\nThe \nmarshallControllerNotFoundEvent()\n method was deprecated early in the ZF2\nlifecycle, and has proxied to \nmarshalControllerNotFoundEvent()\n. It is removed\nwith the v3 release.\n\n\nRouting\n\n\nRouting was removed from zend-mvc, and moved to a new component,\n\nzend-router\n, which is now a\ndependency of zend-mvc.\n\n\nThe changes that will impact users are:\n\n\n\n\nQuery route removal\n;\n  this route had been deprecated since 2.3.0, and removed for the 3.0 release.\n\n\nNamespace changes\n;\n  with the separation to the zend-router component, all routes changed\n  namespaces from \nZend\\Mvc\\Router\n to \nZend\\Router\n.\n\n\n\n\nFollow the links above for more details on these changes, and how to migrate\nyour code.\n\n\nConsole tooling\n\n\nConsole tooling, including console routes, were split off to a new component,\n\nzend-mvc-console\n. If you\nwere using the console tooling, install zend-mvc-console:\n\n\n$ composer require zendframework/zend-mvc-console\n\n\n\n(Make sure you've already installed zend-component-installer before you do, to\nensure the component is registered with your application!)\n\n\nzend-mvc-console exposes all of the same functionality as was in the v2 series\nof zend-mvc, but most components are in different namespaces. Please read the\n\nzend-mvc-console migration guide\n\nfor full details of what changes you may need to make to your application to\nensure console tooling continues to work.\n\n\n\n\nMigrate your console tooling\n\n\nDue to the amount of integration required to support console tooling via the\nMVC, we do not plan on supporting zend-mvc-console long-term. As such, we\nrecommend migrating your code to use standalone tools such as\n\nzf-console\n or\n\nAura.Cli\n.\n\n\n\n\nFilter integration\n\n\nIn version 2, zend-mvc exposed a \nFilterManager\n service by default, and\nprovided specifications to zend-modulemanager's \nServiceListener\n\nto allow modules to provide filter configuration.\n\n\nThis functionality is now removed from zend-mvc. It is now exposed directly by\nthe \nzend-filter\n component\nitself. To add it, install zend-filter:\n\n\n$ composer require zendframework/zend-filter\n\n\n\nNote: the above assumes you have already installed zend-component-installer, per\nthe section above on \ndependency reduction\n.\n\n\nForm integration\n\n\nIn version 2, zend-mvc exposed several facilities related to zend-form:\n\n\n\n\nFormElementManager\n mapped to a factory in zend-mvc, but created a\n  \nZend\\Form\\FormElementManager\n instance.\n\n\nFormAnnotationBuilder\n mapped to a factory in zend-mvc, but created a\n  \nZend\\Form\\Annotation\\AnnotationBuilder\n instance.\n\n\nThe \nServiceListenerFactory\n registered \nZend\\Form\\FormAbstractServiceFactory\n\n  as an abstract factory.\n\n\nThe \nModuleManagerFactory\n registered specifications with the\n  zend-modulemanager \nServiceListener\n to allow modules to provide form element\n  configuration.\n\n\n\n\nThe above functionality is now removed from zend-mvc, and exposed directly by\nthe \nzend-form\n component. To\nadd/enable it, install zend-form:\n\n\n$ composer require zendframework/zend-form\n\n\n\nNote: the above assumes you have already installed zend-component-installer, per\nthe section above on \ndependency reduction\n.\n\n\nHydrator integration\n\n\nIn version 2, zend-mvc exposed a \nHydratorManager\n service by default, and\nprovided specifications to zend-modulemanager's \nServiceListener\n\nto allow modules to provide hydrator configuration.\n\n\nThis functionality is now removed from zend-mvc. It is now exposed directly by\nthe \nzend-hydrator\n component\nitself. To add it, install zend-hydrator:\n\n\n$ composer require zendframework/zend-hydrator\n\n\n\nNote: the above assumes you have already installed zend-component-installer, per\nthe section above on \ndependency reduction\n.\n\n\nInputFilter integration\n\n\nIn version 2, zend-mvc exposed a \nInputFilterManager\n service by default, and\nprovided specifications to zend-modulemanager's \nServiceListener\n\nto allow modules to provide validator configuration.\n\n\nThis functionality is now removed from zend-mvc. It is now exposed directly by\nthe \nzend-inputfilter\n component\nitself. To add it, install zend-inputfilter:\n\n\n$ composer require zendframework/zend-inputfilter\n\n\n\nNote: the above assumes you have already installed zend-component-installer, per\nthe section above on \ndependency reduction\n.\n\n\nzend-inputfilter now also exposes the \nInputFilterAbstractServiceFactory\n as an\nabstract factory by default.\n\n\ni18n integration\n\n\nInternationalization tooling, including:\n\n\n\n\nthe integration translator (\nMvcTranslator\n service)\n\n\nthe \"dummy\" translator\n\n\nthe \nTranslatorAwareTreeRouteStack\n implementation\n\n\nfactories for the translator and translator loader managers\n\n\n\n\nwere removed, and re-assigned to the \nzend-i18n\n\nand \nzend-mvc-i18n\n packages.\nIn most cases, you can install \nzendframework/zend-mvc-i18n\n to restore i18n\nfunctionality to your application:\n\n\n$ composer require zendframework/zend-mvc-i18n\n\n\n\nThere are two categories of changes that could affect you on upgrading.\n\n\nFirst, if you were using the \nTranslatorAwareTreeRouteStack\n, the class name has\nchanged from \nZend\\Mvc\\Router\\Http\\TranslatorAwareTreeRouteStack\n to\n\nZend\\Mvc\\I18n\\Router\\TranslatorAwareTreeRouteStack\n; updating your code to\nreflect that will allow it to work again.\n\n\nSecond, if you were extending one of the service factories for either the\n\nMvcTranslator\n or the \nTranslatorPluginManager\n, the namespaces for the\nfactories have changed. In such situations, you have two options:\n\n\n\n\nUpdate your extensions to extend the new classes. See the \nzend-mvc-i18n\n  migration guide\n\n  to determine what names have changed.\n\n\nInstead of extending, consider using \ndelegator factories\n,\n  as these decorate the service factory, regardless of what factory is used.\n\n\n\n\nLog integration\n\n\nIn version 2, zend-mvc exposed \nLogProcessorManager\n and \nLogWriterManager\n\nservices by default, and provided specifications to zend-modulemanager's\n\nServiceListener\n to allow modules to provide configuration for each.\n\n\nThis functionality is now removed from zend-mvc. It is now exposed directly by\nthe \nzend-log\n component\nitself. To add it, install zend-log:\n\n\n$ composer require zendframework/zend-log\n\n\n\nNote: the above assumes you have already installed zend-component-installer, per\nthe section above on \ndependency reduction\n.\n\n\nzend-log now also exposes \nLogFilterManager\n and \nLogFormatterManager\n,\ncorresponding to the following:\n\n\n\n\n\n\n\n\nService\n\n\nConfig Key\n\n\nProvider Interface\n\n\nProvider Method\n\n\n\n\n\n\n\n\n\n\nLogFilterManager\n\n\nlog_filters\n\n\nZend\\Log\\Filter\\LogFilterProviderInterface\n\n\ngetLogFilterConfig()\n\n\n\n\n\n\nLogFormatterManager\n\n\nlog_formatters\n\n\nZend\\Log\\Formatter\\LogFormatterProviderInterface\n\n\ngetLogFormatterConfig()\n\n\n\n\n\n\n\n\nThis additions allow you to provide additional plugins for every aspect zend-log\nexposes.\n\n\nPlugins\n\n\nThe following plugins have been removed from the main zend-mvc repository, and\ninto their own standalone repositories. In all cases, please be sure to install\nthe \ncomponent installer as detailed above\n before\ninstalling the plugins, to automate injection into your application\nconfiguration.\n\n\nfileprg()\n\n\nThe \nfileprg()\n plugin is now provided via the\n\nzend-mvc-plugin-fileprg\n\ncomponent.\n\n\n$ composer require zendframework/zend-mvc-plugin-fileprg\n\n\n\nZend\\Mvc\\Controller\\Plugin\\FilePostRedirectGet\n becomes\n\nZend\\Mvc\\Plugin\\FilePrg\\FilePostRedirectGet\n. However, it is still mapped as\n\nfileprg()\n.\n\n\nflashMessenger()\n\n\nThe \nflashMessenger()\n plugin is now provided via the\n\nzend-mvc-plugin-flashmessenger\n\ncomponent.\n\n\n$ composer require zendframework/zend-mvc-plugin-flashmessenger\n\n\n\nZend\\Mvc\\Controller\\Plugin\\FlashMessenger\n becomes\n\nZend\\Mvc\\Plugin\\FlashMessenger\\FlashMessenger\n. However, it is still mapped as\n\nflashMessenger()\n and \nflashmessenger()\n.\n\n\nidentity()\n\n\nThe \nidentity()\n plugin is now provided via the\n\nzend-mvc-plugin-identity\n\ncomponent.\n\n\n$ composer require zendframework/zend-mvc-plugin-identity\n\n\n\nZend\\Mvc\\Controller\\Plugin\\Identity\n becomes\n\nZend\\Mvc\\Plugin\\Identity\\Identity\n. However, it is still mapped as\n\nidentity()\n.\n\n\nAdditionally, \nZend\\Mvc\\Controller\\Plugin\\Service\\IdentityFactory\n now becomes\n\nZend\\Mvc\\Plugin\\Identity\\IdentityFactory\n.\n\n\nprg()\n\n\nThe \nprg()\n plugin is now provided via the\n\nzend-mvc-plugin-prg\n\ncomponent.\n\n\n$ composer require zendframework/zend-mvc-plugin-prg\n\n\n\nZend\\Mvc\\Controller\\Plugin\\PostRedirectGet\n becomes\n\nZend\\Mvc\\Plugin\\Prg\\PostRedirectGet\n. However, it is still mapped as \nprg()\n.\n\n\nSerializer integration\n\n\nIn version 2, zend-mvc exposed a \nSerializerAdapterManager\n service by default, and\nprovided specifications to zend-modulemanager's \nServiceListener\n\nto allow modules to provide serializer configuration.\n\n\nThis functionality is now removed from zend-mvc. It is now exposed directly by\nthe \nzend-serializer\n component\nitself. To add it, install zend-serializer\n\n\n$ composer require zendframework/zend-serializer\n\n\n\nNote: the above assumes you have already installed zend-component-installer, per\nthe section above on \ndependency reduction\n.\n\n\nServiceLocatorAware initializers\n\n\nStarting with zend-servicemanager v3, that component no longer defines the\n\nServiceLocatorAwareInterface\n. Since zend-mvc pins against zend-servicemanager\nv3 with its own v3 release, the initializers that injected the application\ncontainer into implementations of that interface are no longer relevant. As\nsuch, they have now been removed from each of the\n\nZend\\Mvc\\Service\\ServiceManagerConfig\n and\n\nZend\\Mvc\\Controller\\ControllerManager\n classes.\n\n\nAdditionally, the duck-typed \nServiceLocatorAwareInterface\n implementation in\n\nAbstractController\n was removed, as messaged in the 2.7 release.\n\n\nIf you relied on this functionality, you are encouraged to update your code to\nuse factories to inject your \nactual\n dependencies.\n\n\nValidator integration\n\n\nIn version 2, zend-mvc exposed a \nValidatorManager\n service by default, and\nprovided specifications to zend-modulemanager's \nServiceListener\n\nto allow modules to provide validator configuration.\n\n\nThis functionality is now removed from zend-mvc. It is now exposed directly by\nthe \nzend-validator\n component\nitself. To add it, install zend-validator:\n\n\n$ composer require zendframework/zend-validator\n\n\n\nNote: the above assumes you have already installed zend-component-installer, per\nthe section above on \ndependency reduction\n.\n\n\nZend\\Mvc\\View\\InjectTemplateListener\n\n\nThe \nInjectTemplateListener\n attempts to map a controller name to a\ntemplate using a variety of heuristics, including an explicit map provided\nduring configuration, or auto-detection based on the controller class name.\n\n\nIn version 2, the autodetection took into consideration the \n__NAMESPACE__\n\nroute match parameter to derive subnamespaces, or would omit them completely if\n\n__NAMESPACE__\n was not present. This caused issues when multiple modules shared\na top-level namespace (e.g., \nZF\\Apigility\n and \nZF\\Apigility\\Admin\n) and each\nhad a controller with the same name.\n\n\nTo avoid naming conflicts, version 3 removes this aspect of autodetection, and\ninstead provides exactly one workflow for mapping:\n\n\n\n\nStrip the \nController\n subnamespace, if present (e.g., the namespace\n  \nApplication\\Controller\\\\\n is normalized to \nApplication\\\\\n).\n\n\nStrip the \nController\n suffix in the class name, if present (e.g.,\n  \nIndexController\n is normalized to \nIndex\n).\n\n\nInflect CamelCasing to dash-separated (e.g., \nShowUsers\n becomes\n  \nshow-users\n).\n\n\nReplace the namespace separator with a slash.\n\n\n\n\nAs a full example, the controller service name\n\nTestSomething\\With\\Controller\\CamelCaseController\n will always map to\n\ntest-something/with/camel-case\n, regardless of the \n__NAMESPACE__\n value\nprovided in routing configuration.\n\n\nIf needed, you can emulate the version 2 behavior in version 3 via namespace\nwhitelisting in the controller <=> template map.\n\n\nZend\\Mvc\\View\\SendResponseListener\n\n\nZend\\Mvc\\View\\SendResponseListener\n was deprecated with the 2.2 release, and\nhas been an extension of \nZend\\Mvc\\SendResponseListener\n ever since. It is\nremoved with the v3 release.",
            "title": "v2.X to v3.0"
        },
        {
            "location": "/migration/to-v3-0/#upgrading-to-30",
            "text": "With the release of Zend Framework 2, all components current at that time,\nregardless of history, were tagged as v2 releases; in reality, it was the first\nversion of a new framework, as it was a completely new architecture from Zend\nFramework 1. As such, zend-mvc 3.0 marks the second major release of the\ncomponent.  The primary goal for version 3 was to reduce the number of dependencies, and to\nsplit out unrelated, tangential, or extension functionality. As such, there are\na number of changes that will impact users.",
            "title": "Upgrading to 3.0"
        },
        {
            "location": "/migration/to-v3-0/#dependency-reduction",
            "text": "In order to remove dependencies, we needed to provide alternate ways to ensure\nthat default functionality, such as service registration and event listener\nattachment, could still occur.  The solution to this problem was to expose each component as a module. This\nhowever, raised another problem: you now have to register components as modules\nin your application.  To solve this new problem, we created a new component, zend-component-installer .\nInstall this in your application now:  $ composer require --dev zendframework/zend-component-installer  Once installed, the component acts as a Composer plugin, and will intercept\npackages marked as components or Zend Framework modules, and register them with\nyour application configuration. Components are pushed to the top of the module\nlist, while modules are pushed to the end. As a development component, it will\nnot be installed in your production distributions.",
            "title": "Dependency reduction"
        },
        {
            "location": "/migration/to-v3-0/#updated-dependencies",
            "text": "The v3 release now  requires :   zend-http  zend-modulemanager  zend-router  zend-view   Additionally, the following components require their v3 releases:   zend-eventmanager  zend-servicemanager  zend-stdlib   The minimum supported PHP version was bumped to 5.6.",
            "title": "Updated dependencies"
        },
        {
            "location": "/migration/to-v3-0/#application-class",
            "text": "The following changes were made to the  Zend\\Mvc\\Application  constructor:   The first  $configuration  argument was removed, as it was not used.  Three additional, optional arguments were added:  Zend\\EventManager\\EventManagerInterface $events = null  Zend\\Stdlib\\RequestInterface $request = null  Zend\\Stdlib\\ResponseInterface $response = null   End-users using the skeleton application and the default  Application  factory\nwill not notice a change. Those who are directly instantiating the  Application \ninstance (in production or test code) or who have created their own factory for\nthe class will need to update their code.",
            "title": "Application class"
        },
        {
            "location": "/migration/to-v3-0/#send-method",
            "text": "The  send()  method has been deprecated since the 2.2 release, and a no-op since\nthen as well. It is removed starting with the v3 release.",
            "title": "send method"
        },
        {
            "location": "/migration/to-v3-0/#controllerloader",
            "text": "The  ControllerLoader  service was deprecated early in the v2 lifecycle, and\naliased to  ControllerManager . The  ControllerLoader  factory was kept to\nprevent BC breaks due to extending the class.  v3 removes the  ControllerLoaderFactory , as well as the  ControllerLoader \nservice alias.",
            "title": "ControllerLoader"
        },
        {
            "location": "/migration/to-v3-0/#di-servicemanager-integration",
            "text": "The integration between  zend-servicemanager  and zend-di  has been moved to a new\nstandalone component,  zend-servicemanager-di .\nIn most cases, installing the component will restore the original behavior:  $ composer require zendframework/zend-servicemanager-di",
            "title": "DI-ServiceManager integration"
        },
        {
            "location": "/migration/to-v3-0/#manual-installation",
            "text": "The above assumes you're using the new component installer detailed in the dependency reduction  section, above. If you are not,\nyou will need to inject the zend-servicemanager-di module into your\napplication manually; follow the  instructions in the zend-servicemanager-di documentation \nto do so.   The new component also contains a  migration document \ndetailing potential issues for users migrating to version 3.",
            "title": "Manual installation"
        },
        {
            "location": "/migration/to-v3-0/#dispatchlistener",
            "text": "The  marshallControllerNotFoundEvent()  method was deprecated early in the ZF2\nlifecycle, and has proxied to  marshalControllerNotFoundEvent() . It is removed\nwith the v3 release.",
            "title": "DispatchListener"
        },
        {
            "location": "/migration/to-v3-0/#routing",
            "text": "Routing was removed from zend-mvc, and moved to a new component, zend-router , which is now a\ndependency of zend-mvc.  The changes that will impact users are:   Query route removal ;\n  this route had been deprecated since 2.3.0, and removed for the 3.0 release.  Namespace changes ;\n  with the separation to the zend-router component, all routes changed\n  namespaces from  Zend\\Mvc\\Router  to  Zend\\Router .   Follow the links above for more details on these changes, and how to migrate\nyour code.",
            "title": "Routing"
        },
        {
            "location": "/migration/to-v3-0/#console-tooling",
            "text": "Console tooling, including console routes, were split off to a new component, zend-mvc-console . If you\nwere using the console tooling, install zend-mvc-console:  $ composer require zendframework/zend-mvc-console  (Make sure you've already installed zend-component-installer before you do, to\nensure the component is registered with your application!)  zend-mvc-console exposes all of the same functionality as was in the v2 series\nof zend-mvc, but most components are in different namespaces. Please read the zend-mvc-console migration guide \nfor full details of what changes you may need to make to your application to\nensure console tooling continues to work.",
            "title": "Console tooling"
        },
        {
            "location": "/migration/to-v3-0/#migrate-your-console-tooling",
            "text": "Due to the amount of integration required to support console tooling via the\nMVC, we do not plan on supporting zend-mvc-console long-term. As such, we\nrecommend migrating your code to use standalone tools such as zf-console  or Aura.Cli .",
            "title": "Migrate your console tooling"
        },
        {
            "location": "/migration/to-v3-0/#filter-integration",
            "text": "In version 2, zend-mvc exposed a  FilterManager  service by default, and\nprovided specifications to zend-modulemanager's  ServiceListener \nto allow modules to provide filter configuration.  This functionality is now removed from zend-mvc. It is now exposed directly by\nthe  zend-filter  component\nitself. To add it, install zend-filter:  $ composer require zendframework/zend-filter  Note: the above assumes you have already installed zend-component-installer, per\nthe section above on  dependency reduction .",
            "title": "Filter integration"
        },
        {
            "location": "/migration/to-v3-0/#form-integration",
            "text": "In version 2, zend-mvc exposed several facilities related to zend-form:   FormElementManager  mapped to a factory in zend-mvc, but created a\n   Zend\\Form\\FormElementManager  instance.  FormAnnotationBuilder  mapped to a factory in zend-mvc, but created a\n   Zend\\Form\\Annotation\\AnnotationBuilder  instance.  The  ServiceListenerFactory  registered  Zend\\Form\\FormAbstractServiceFactory \n  as an abstract factory.  The  ModuleManagerFactory  registered specifications with the\n  zend-modulemanager  ServiceListener  to allow modules to provide form element\n  configuration.   The above functionality is now removed from zend-mvc, and exposed directly by\nthe  zend-form  component. To\nadd/enable it, install zend-form:  $ composer require zendframework/zend-form  Note: the above assumes you have already installed zend-component-installer, per\nthe section above on  dependency reduction .",
            "title": "Form integration"
        },
        {
            "location": "/migration/to-v3-0/#hydrator-integration",
            "text": "In version 2, zend-mvc exposed a  HydratorManager  service by default, and\nprovided specifications to zend-modulemanager's  ServiceListener \nto allow modules to provide hydrator configuration.  This functionality is now removed from zend-mvc. It is now exposed directly by\nthe  zend-hydrator  component\nitself. To add it, install zend-hydrator:  $ composer require zendframework/zend-hydrator  Note: the above assumes you have already installed zend-component-installer, per\nthe section above on  dependency reduction .",
            "title": "Hydrator integration"
        },
        {
            "location": "/migration/to-v3-0/#inputfilter-integration",
            "text": "In version 2, zend-mvc exposed a  InputFilterManager  service by default, and\nprovided specifications to zend-modulemanager's  ServiceListener \nto allow modules to provide validator configuration.  This functionality is now removed from zend-mvc. It is now exposed directly by\nthe  zend-inputfilter  component\nitself. To add it, install zend-inputfilter:  $ composer require zendframework/zend-inputfilter  Note: the above assumes you have already installed zend-component-installer, per\nthe section above on  dependency reduction .  zend-inputfilter now also exposes the  InputFilterAbstractServiceFactory  as an\nabstract factory by default.",
            "title": "InputFilter integration"
        },
        {
            "location": "/migration/to-v3-0/#i18n-integration",
            "text": "Internationalization tooling, including:   the integration translator ( MvcTranslator  service)  the \"dummy\" translator  the  TranslatorAwareTreeRouteStack  implementation  factories for the translator and translator loader managers   were removed, and re-assigned to the  zend-i18n \nand  zend-mvc-i18n  packages.\nIn most cases, you can install  zendframework/zend-mvc-i18n  to restore i18n\nfunctionality to your application:  $ composer require zendframework/zend-mvc-i18n  There are two categories of changes that could affect you on upgrading.  First, if you were using the  TranslatorAwareTreeRouteStack , the class name has\nchanged from  Zend\\Mvc\\Router\\Http\\TranslatorAwareTreeRouteStack  to Zend\\Mvc\\I18n\\Router\\TranslatorAwareTreeRouteStack ; updating your code to\nreflect that will allow it to work again.  Second, if you were extending one of the service factories for either the MvcTranslator  or the  TranslatorPluginManager , the namespaces for the\nfactories have changed. In such situations, you have two options:   Update your extensions to extend the new classes. See the  zend-mvc-i18n\n  migration guide \n  to determine what names have changed.  Instead of extending, consider using  delegator factories ,\n  as these decorate the service factory, regardless of what factory is used.",
            "title": "i18n integration"
        },
        {
            "location": "/migration/to-v3-0/#log-integration",
            "text": "In version 2, zend-mvc exposed  LogProcessorManager  and  LogWriterManager \nservices by default, and provided specifications to zend-modulemanager's ServiceListener  to allow modules to provide configuration for each.  This functionality is now removed from zend-mvc. It is now exposed directly by\nthe  zend-log  component\nitself. To add it, install zend-log:  $ composer require zendframework/zend-log  Note: the above assumes you have already installed zend-component-installer, per\nthe section above on  dependency reduction .  zend-log now also exposes  LogFilterManager  and  LogFormatterManager ,\ncorresponding to the following:     Service  Config Key  Provider Interface  Provider Method      LogFilterManager  log_filters  Zend\\Log\\Filter\\LogFilterProviderInterface  getLogFilterConfig()    LogFormatterManager  log_formatters  Zend\\Log\\Formatter\\LogFormatterProviderInterface  getLogFormatterConfig()     This additions allow you to provide additional plugins for every aspect zend-log\nexposes.",
            "title": "Log integration"
        },
        {
            "location": "/migration/to-v3-0/#plugins",
            "text": "The following plugins have been removed from the main zend-mvc repository, and\ninto their own standalone repositories. In all cases, please be sure to install\nthe  component installer as detailed above  before\ninstalling the plugins, to automate injection into your application\nconfiguration.",
            "title": "Plugins"
        },
        {
            "location": "/migration/to-v3-0/#fileprg",
            "text": "The  fileprg()  plugin is now provided via the zend-mvc-plugin-fileprg \ncomponent.  $ composer require zendframework/zend-mvc-plugin-fileprg  Zend\\Mvc\\Controller\\Plugin\\FilePostRedirectGet  becomes Zend\\Mvc\\Plugin\\FilePrg\\FilePostRedirectGet . However, it is still mapped as fileprg() .",
            "title": "fileprg()"
        },
        {
            "location": "/migration/to-v3-0/#flashmessenger",
            "text": "The  flashMessenger()  plugin is now provided via the zend-mvc-plugin-flashmessenger \ncomponent.  $ composer require zendframework/zend-mvc-plugin-flashmessenger  Zend\\Mvc\\Controller\\Plugin\\FlashMessenger  becomes Zend\\Mvc\\Plugin\\FlashMessenger\\FlashMessenger . However, it is still mapped as flashMessenger()  and  flashmessenger() .",
            "title": "flashMessenger()"
        },
        {
            "location": "/migration/to-v3-0/#identity",
            "text": "The  identity()  plugin is now provided via the zend-mvc-plugin-identity \ncomponent.  $ composer require zendframework/zend-mvc-plugin-identity  Zend\\Mvc\\Controller\\Plugin\\Identity  becomes Zend\\Mvc\\Plugin\\Identity\\Identity . However, it is still mapped as identity() .  Additionally,  Zend\\Mvc\\Controller\\Plugin\\Service\\IdentityFactory  now becomes Zend\\Mvc\\Plugin\\Identity\\IdentityFactory .",
            "title": "identity()"
        },
        {
            "location": "/migration/to-v3-0/#prg",
            "text": "The  prg()  plugin is now provided via the zend-mvc-plugin-prg \ncomponent.  $ composer require zendframework/zend-mvc-plugin-prg  Zend\\Mvc\\Controller\\Plugin\\PostRedirectGet  becomes Zend\\Mvc\\Plugin\\Prg\\PostRedirectGet . However, it is still mapped as  prg() .",
            "title": "prg()"
        },
        {
            "location": "/migration/to-v3-0/#serializer-integration",
            "text": "In version 2, zend-mvc exposed a  SerializerAdapterManager  service by default, and\nprovided specifications to zend-modulemanager's  ServiceListener \nto allow modules to provide serializer configuration.  This functionality is now removed from zend-mvc. It is now exposed directly by\nthe  zend-serializer  component\nitself. To add it, install zend-serializer  $ composer require zendframework/zend-serializer  Note: the above assumes you have already installed zend-component-installer, per\nthe section above on  dependency reduction .",
            "title": "Serializer integration"
        },
        {
            "location": "/migration/to-v3-0/#servicelocatoraware-initializers",
            "text": "Starting with zend-servicemanager v3, that component no longer defines the ServiceLocatorAwareInterface . Since zend-mvc pins against zend-servicemanager\nv3 with its own v3 release, the initializers that injected the application\ncontainer into implementations of that interface are no longer relevant. As\nsuch, they have now been removed from each of the Zend\\Mvc\\Service\\ServiceManagerConfig  and Zend\\Mvc\\Controller\\ControllerManager  classes.  Additionally, the duck-typed  ServiceLocatorAwareInterface  implementation in AbstractController  was removed, as messaged in the 2.7 release.  If you relied on this functionality, you are encouraged to update your code to\nuse factories to inject your  actual  dependencies.",
            "title": "ServiceLocatorAware initializers"
        },
        {
            "location": "/migration/to-v3-0/#validator-integration",
            "text": "In version 2, zend-mvc exposed a  ValidatorManager  service by default, and\nprovided specifications to zend-modulemanager's  ServiceListener \nto allow modules to provide validator configuration.  This functionality is now removed from zend-mvc. It is now exposed directly by\nthe  zend-validator  component\nitself. To add it, install zend-validator:  $ composer require zendframework/zend-validator  Note: the above assumes you have already installed zend-component-installer, per\nthe section above on  dependency reduction .",
            "title": "Validator integration"
        },
        {
            "location": "/migration/to-v3-0/#zendmvcviewinjecttemplatelistener",
            "text": "The  InjectTemplateListener  attempts to map a controller name to a\ntemplate using a variety of heuristics, including an explicit map provided\nduring configuration, or auto-detection based on the controller class name.  In version 2, the autodetection took into consideration the  __NAMESPACE__ \nroute match parameter to derive subnamespaces, or would omit them completely if __NAMESPACE__  was not present. This caused issues when multiple modules shared\na top-level namespace (e.g.,  ZF\\Apigility  and  ZF\\Apigility\\Admin ) and each\nhad a controller with the same name.  To avoid naming conflicts, version 3 removes this aspect of autodetection, and\ninstead provides exactly one workflow for mapping:   Strip the  Controller  subnamespace, if present (e.g., the namespace\n   Application\\Controller\\\\  is normalized to  Application\\\\ ).  Strip the  Controller  suffix in the class name, if present (e.g.,\n   IndexController  is normalized to  Index ).  Inflect CamelCasing to dash-separated (e.g.,  ShowUsers  becomes\n   show-users ).  Replace the namespace separator with a slash.   As a full example, the controller service name TestSomething\\With\\Controller\\CamelCaseController  will always map to test-something/with/camel-case , regardless of the  __NAMESPACE__  value\nprovided in routing configuration.  If needed, you can emulate the version 2 behavior in version 3 via namespace\nwhitelisting in the controller <=> template map.",
            "title": "Zend\\Mvc\\View\\InjectTemplateListener"
        },
        {
            "location": "/migration/to-v3-0/#zendmvcviewsendresponselistener",
            "text": "Zend\\Mvc\\View\\SendResponseListener  was deprecated with the 2.2 release, and\nhas been an extension of  Zend\\Mvc\\SendResponseListener  ever since. It is\nremoved with the v3 release.",
            "title": "Zend\\Mvc\\View\\SendResponseListener"
        },
        {
            "location": "/cookbook/automating-controller-factories/",
            "text": "Automating Controller Factories\n\n\nWriting a factory class for each and every controller that has dependencies\ncan be tedious, particularly in early development as you are still sorting\nout dependencies.\n\n\nAs of version 3.0.1, zend-mvc ships with \nZend\\Mvc\\Controller\\LazyControllerAbstractFactory\n,\nwhich provides a reflection-based approach to controller instantiation,\nresolving constructor dependencies to the relevant services. The factory may be\nused as either an abstract factory, or mapped to specific controller names as a\nfactory:\n\n\nuse Zend\\Mvc\\Controller\\LazyControllerAbstractFactory;\n\nreturn [\n    /* ... */\n    'controllers' => [\n        'abstract_factories' => [\n            LazyControllerAbstractFactory::class,\n        ],\n        'factories' => [\n            'MyModule\\Controller\\FooController' => LazyControllerAbstractFactory::class,\n        ],\n    ],\n    /* ... */\n];\n\n\n\nMapping controllers to the factory is more explicit and performant.\n\n\nThe factory operates with the following constraints/features:\n\n\n\n\nA parameter named \n$config\n typehinted as an array will receive the\n  application \"config\" service (i.e., the merged configuration).\n\n\nParameters typehinted against array, but not named \n$config\n, will\n  be injected with an empty array.\n\n\nScalar parameters will be resolved as null values.\n\n\nIf a service cannot be found for a given typehint, the factory will\n  raise an exception detailing this.\n\n\nSome services provided by Zend Framework components do not have\n  entries based on their class name (for historical reasons); the\n  factory contains a map of these class/interface names to the\n  corresponding service name to allow them to resolve. These include:\n\n\nZend\\Console\\Adapter\\AdapterInterface\n maps to \nConsoleAdapter\n,\n\n\nZend\\Filter\\FilterPluginManager\n maps to \nFilterManager\n,\n\n\nZend\\Hydrator\\HydratorPluginManager\n maps to \nHydratorManager\n,\n\n\nZend\\InputFilter\\InputFilterPluginManager\n maps to \nInputFilterManager\n,\n\n\nZend\\Log\\FilterPluginManager\n maps to \nLogFilterManager\n,\n\n\nZend\\Log\\FormatterPluginManager\n maps to \nLogFormatterManager\n,\n\n\nZend\\Log\\ProcessorPluginManager\n maps to \nLogProcessorManager\n,\n\n\nZend\\Log\\WriterPluginManager\n maps to \nLogWriterManager\n,\n\n\nZend\\Serializer\\AdapterPluginManager\n maps to \nSerializerAdapterManager\n,\n\n\nZend\\Validator\\ValidatorPluginManager\n maps to \nValidatorManager\n,\n\n\n\n\n\n\n\n\n$options\n passed to the factory are ignored in all cases, as we cannot\nmake assumptions about which argument(s) they might replace.\n\n\nOnce your dependencies have stabilized, we recommend writing a dedicated\nfactory, as reflection can introduce performance overhead.\n\n\nReferences\n\n\nThis feature was inspired by \na blog post by Alexandre Lemaire\n.",
            "title": "Automating controller factories"
        },
        {
            "location": "/cookbook/automating-controller-factories/#automating-controller-factories",
            "text": "Writing a factory class for each and every controller that has dependencies\ncan be tedious, particularly in early development as you are still sorting\nout dependencies.  As of version 3.0.1, zend-mvc ships with  Zend\\Mvc\\Controller\\LazyControllerAbstractFactory ,\nwhich provides a reflection-based approach to controller instantiation,\nresolving constructor dependencies to the relevant services. The factory may be\nused as either an abstract factory, or mapped to specific controller names as a\nfactory:  use Zend\\Mvc\\Controller\\LazyControllerAbstractFactory;\n\nreturn [\n    /* ... */\n    'controllers' => [\n        'abstract_factories' => [\n            LazyControllerAbstractFactory::class,\n        ],\n        'factories' => [\n            'MyModule\\Controller\\FooController' => LazyControllerAbstractFactory::class,\n        ],\n    ],\n    /* ... */\n];  Mapping controllers to the factory is more explicit and performant.  The factory operates with the following constraints/features:   A parameter named  $config  typehinted as an array will receive the\n  application \"config\" service (i.e., the merged configuration).  Parameters typehinted against array, but not named  $config , will\n  be injected with an empty array.  Scalar parameters will be resolved as null values.  If a service cannot be found for a given typehint, the factory will\n  raise an exception detailing this.  Some services provided by Zend Framework components do not have\n  entries based on their class name (for historical reasons); the\n  factory contains a map of these class/interface names to the\n  corresponding service name to allow them to resolve. These include:  Zend\\Console\\Adapter\\AdapterInterface  maps to  ConsoleAdapter ,  Zend\\Filter\\FilterPluginManager  maps to  FilterManager ,  Zend\\Hydrator\\HydratorPluginManager  maps to  HydratorManager ,  Zend\\InputFilter\\InputFilterPluginManager  maps to  InputFilterManager ,  Zend\\Log\\FilterPluginManager  maps to  LogFilterManager ,  Zend\\Log\\FormatterPluginManager  maps to  LogFormatterManager ,  Zend\\Log\\ProcessorPluginManager  maps to  LogProcessorManager ,  Zend\\Log\\WriterPluginManager  maps to  LogWriterManager ,  Zend\\Serializer\\AdapterPluginManager  maps to  SerializerAdapterManager ,  Zend\\Validator\\ValidatorPluginManager  maps to  ValidatorManager ,     $options  passed to the factory are ignored in all cases, as we cannot\nmake assumptions about which argument(s) they might replace.  Once your dependencies have stabilized, we recommend writing a dedicated\nfactory, as reflection can introduce performance overhead.",
            "title": "Automating Controller Factories"
        },
        {
            "location": "/cookbook/automating-controller-factories/#references",
            "text": "This feature was inspired by  a blog post by Alexandre Lemaire .",
            "title": "References"
        },
        {
            "location": "/cookbook/middleware-in-listeners/",
            "text": "Using middleware within event listeners\n\n\nWithin the MVC workflow, you can use middleware within event listeners by\nconverting the request and response objects composed in the event to PSR-7\nequivalents using \nzend-psr7bridge\n.\n\n\nAs an example, consider the following \nAuthorizationMiddleware\n:\n\n\nnamespace Application\\Middleware;\n\nuse Psr\\Http\\Message\\ServerRequestInterface as RequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\n\nclass AuthorizationMiddleware\n{\n    public function __invoke(RequestInterface $request, ResponseInterface $response, callable $next = null)\n    {\n        // handle authorization here...\n    }\n}\n\n\n\nSince the request and response composed in \nMvcEvent\n instances are specifically\nfrom zend-http, we will use zend-psr7bridge to convert them to PSR-7\nequivalents. As an example, consider the following module declaration, which\nregisters a \ndispatch\n listener to invoke the above middleware:\n\n\nnamespace Application;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Zend\\Psr7Bridge\\Psr7ServerRequest;\nuse Zend\\Psr7Bridge\\Psr7Response;\n\nclass Module\n{\n    public function onBootstrap($e)\n    {\n        $app          = $e->getApplication();\n        $eventManager = $app->getEventManager();\n        $services     = $app->getServiceManager();\n\n        $eventManager->attach($e::EVENT_DISPATCH, function ($e) use ($services) {\n            $request  = Psr7ServerRequest::fromZend($e->getRequest());\n            $response = Psr7Response::fromZend($e->getResponse());\n            $done     = function ($request, $response) {\n            };\n\n            $result   = ($services->get(Middleware\\AuthorizationMiddleware::class))(\n                $request,\n                $response,\n                $done\n            );\n\n            if ($result) {\n                return Psr7Response::toZend($result);\n            }\n        }, 2);\n    }\n}",
            "title": "Using middleware within event listeners"
        },
        {
            "location": "/cookbook/middleware-in-listeners/#using-middleware-within-event-listeners",
            "text": "Within the MVC workflow, you can use middleware within event listeners by\nconverting the request and response objects composed in the event to PSR-7\nequivalents using  zend-psr7bridge .  As an example, consider the following  AuthorizationMiddleware :  namespace Application\\Middleware;\n\nuse Psr\\Http\\Message\\ServerRequestInterface as RequestInterface;\nuse Psr\\Http\\Message\\ResponseInterface;\n\nclass AuthorizationMiddleware\n{\n    public function __invoke(RequestInterface $request, ResponseInterface $response, callable $next = null)\n    {\n        // handle authorization here...\n    }\n}  Since the request and response composed in  MvcEvent  instances are specifically\nfrom zend-http, we will use zend-psr7bridge to convert them to PSR-7\nequivalents. As an example, consider the following module declaration, which\nregisters a  dispatch  listener to invoke the above middleware:  namespace Application;\n\nuse Psr\\Http\\Message\\ResponseInterface;\nuse Zend\\Psr7Bridge\\Psr7ServerRequest;\nuse Zend\\Psr7Bridge\\Psr7Response;\n\nclass Module\n{\n    public function onBootstrap($e)\n    {\n        $app          = $e->getApplication();\n        $eventManager = $app->getEventManager();\n        $services     = $app->getServiceManager();\n\n        $eventManager->attach($e::EVENT_DISPATCH, function ($e) use ($services) {\n            $request  = Psr7ServerRequest::fromZend($e->getRequest());\n            $response = Psr7Response::fromZend($e->getResponse());\n            $done     = function ($request, $response) {\n            };\n\n            $result   = ($services->get(Middleware\\AuthorizationMiddleware::class))(\n                $request,\n                $response,\n                $done\n            );\n\n            if ($result) {\n                return Psr7Response::toZend($result);\n            }\n        }, 2);\n    }\n}",
            "title": "Using middleware within event listeners"
        }
    ]
}